QQRKSRC1
// This file has been written by QuArK 6.6
// It's the text version of file: UrT4.qrk

{
  Description = "Urban Terror 4 additional data"
  Game Directories.qctx =
  {
    Game = "Quake 3"
    SourceDir = "q3ut4"
    GameDir = "q3ut4"
  }
  Toolbox Folders.qtx =
  {
    Toolbox = "New map items..."
    Root = "Entities for urbanterror.def.qtxfolder"
    Entities for urbanterror.def.qtxfolder =
    {
      ;desc = "Created from urbanterror.def"
      cubemap_* entities.qtxfolder =
      {
        cubemap_probe:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      func_* entities.qtxfolder =
      {
        func_breakable:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_button:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_door:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_keyboard_interface:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_rotating_door:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_ut_train:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        func_wall:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
      }
      info_* entities.qtxfolder =
      {
        info_ut_bombsite:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        info_ut_spawn:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      other entities.qtxfolder =
      {
        worldspawn:b =
        {
        }
      }
      path_* entities.qtxfolder =
      {
        path_ut_stop:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      target_* entities.qtxfolder =
      {
        target_speaker:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      team_* entities.qtxfolder =
      {
        team_CAH_capturepoint:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      trigger_* entities.qtxfolder =
      {
        trigger_gravity:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        trigger_location:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_multiple:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
      }
      ut_* entities.qtxfolder =
      {
        ut_jumpcancel:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        ut_jumpstart:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        ut_jumpstop:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        ut_mrsentry:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
    }
  }
  Entity Forms.fctx =
  {
    func_button:form =
    {
      help = "When a button is touched by a player, it moves in the direction "
       "set by the "$22"angle"$22" key, triggers all its targets, stays presse"
       "d by an amount of time set by the "$22"wait"$22" key, then returns to "
       "it's original position where it can be operated again."$0D"-------- KE"
       "YS --------"$0D"angle : Determines the direction in which the button w"
       "ill move (up = -1, down = -2)."$0D"target : All entities with a matchi"
       "ng targetname will be triggered."$0D"speed : Speed of button's displac"
       "ement (default 40)."$0D"wait : Number of seconds button stays pressed "
       "(default 1, -1 = return immediately)."$0D"lip : Lip remaining at end o"
       "f move (default 4 units)."$0D"health : If set to a non-zero value, the"
       " button must be damaged by "$22"health"$22" amount of points to operat"
       "e."$0D"light : ConstantLight radius of .md3 model included with entity"
       ". Has no effect on the entity's brushes (default 0)."$0D"color : Const"
       "antLight color of .md3 model included with entity. Has no effect on th"
       "e entity's brushes (default 1 1 1)."$0D"model2 : Path/name of model to"
       " include (eg: models/mapobjects/pipe/pipe02.md3)."$0D"origin : Alterna"
       "te method of setting XYZ origin of .md3 model included with entity (Se"
       "e Notes)."$0D"notfree : When set to 1, entity will not spawn in "$22"F"
       "ree for all"$22" and "$22"Tournament"$22" modes."$0D"notteam : When se"
       "t to 1, entity will not spawn in "$22"Teamplay"$22" and "$22"CTF"$22" "
       "modes."$0D"notsingle : When set to 1, entity will not spawn in Single "
       "Player mode (bot play mode)."$0D"push_sound : Sound that gets played w"
       "hen button gets pushed ("$22"none"$22" for nothing, defaults to a elev"
       "ator Q3 sound)."$0D"-------- Q3MAP2 KEYS --------"$0D"targetname : Use"
       "d to attach a misc_model entity to this entity."$0D"_lightmapscale : F"
       "loating point value scales the resolution of lightmaps on brushes/patc"
       "hes in this entity (default 1.0)."$0D"_cs OR _castshadows : Allows per"
       "-entity control over shadow casting. Defaults to 0 on entities, 1 on w"
       "orld. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast sha"
       "dows on entities with _rs (or _receiveshadows) with the corresponding "
       "value, AND world. Negative values imply same, but DO NOT cast shadows "
       "on world."$0D"_rs OR _receiveshadows : Allows per-entity control over "
       "shadow reception. Defaults to 1 on everything (world shadows). 0 = rec"
       "eives NO shadows. > 1 = receive shadows only from corresponding keyed "
       "entities (see above) and world. < 1 = receive shadows ONLY from corres"
       "ponding keyed entities."$0D"_celshader : Sets the cel shader used for "
       "this geometry. Note: Omit the "$22"textures/"$22" prefix."$0D"--------"
       " Q3MAP2 TERRAIN KEYS --------"$0D"_indexmap OR alphamap : Path/name fo"
       "r the art file used to guide the mapping of textures on the terrain su"
       "rface."$0D"_layers OR layers : Integer value denotes number of unique "
       "root shaders that will be used on the terrain."$0D"_shader OR shader :"
       " Path to the metashader used to assign textures to the terrain entity."
       " Note: Omit the "$22"textures/"$22" prefix."$0D"-------- NOTES -------"
       "-"$0D"Setting the origin key is simply an alternate method to using an"
       " origin brush. When using the model2 key, the origin point of the mode"
       "l will correspond to the origin point defined by either the origin bru"
       "sh or the origin coordinate value."$0D"Target this entity with a misc_"
       "model to have the model attached to the entity (set the model's "$22"t"
       "arget"$22" key to the same value as this entity's "$22"targetname"$22")"
       "."$0D"When the entity activates its targets, all shaders/textures in t"
       "he map that were originally the same name as the targetShaderName valu"
       "e, will be changed to the targetShaderNewName value. For example, turn"
       "ing a light on:"$0D22"targetShaderName"$22" "$22"textures/proto2/redli"
       "ght_off"$220D22"targetShaderNewName"$22" "$22"textures/proto2/redlight"
       "_on"$220D"And this would turn it back off:"$0D22"targetShaderName"$22" "
       $22"textures/proto2/redlight_off"$220D22"targetShaderNewName"$22" "$22"t"
       "extures/proto2/redlight_off"$22
      angle: =
      {
        txt = "&"
        hint = "Determines the direction in which the button will move (up = -"
         "1, down = -2)."
      }
      target: =
      {
        txt = "&"
        hint = "All entities with a matching targetname will be triggered."
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of button's displacement (default 40)."
      }
      wait: =
      {
        txt = "&"
        hint = "Number of seconds button stays pressed (default 1, -1 = return"
         " immediately)."
      }
      lip: =
      {
        txt = "&"
        hint = "Lip remaining at end of move (default 4 units)."
      }
      health: =
      {
        txt = "&"
        hint = "If set to a non-zero value, the button must be damaged by "$22
         "$22"$22"health"$22"$22"$22" amount of points to operate."
      }
      light: =
      {
        txt = "&"
        hint = "ConstantLight radius of .md3 model included with entity. Has n"
         "o effect on the entity's brushes (default 0)."
      }
      color: =
      {
        txt = "&"
        hint = "ConstantLight color of .md3 model included with entity. Has no"
         " effect on the entity's brushes (default 1 1 1)."
      }
      model2: =
      {
        txt = "&"
        hint = "Path/name of model to include (eg: models/mapobjects/pipe/pipe"
         "02.md3)."
      }
      origin: =
      {
        txt = "&"
        hint = "Alternate method of setting XYZ origin of .md3 model included "
         "with entity (See Notes)."
      }
      notfree: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
      push_sound: =
      {
        txt = "&"
        hint = "Sound that gets played when button gets pushed ("$22"$22"$22"n"
         "one"$22"$22"$22" for nothing, defaults to a elevator Q3 sound)."
      }
      sep: =
      {
        txt = "-------- Q3MAP2 KEYS --------"
        typ = "S"
      }
      targetname: =
      {
        txt = "&"
        hint = "Used to attach a misc_model entity to this entity."
      }
      _lightmapscale: =
      {
        txt = "&"
        hint = "Floating point value scales the resolution of lightmaps on bru"
         "shes/patches in this entity (default 1.0)."
      }
      _cs OR _castshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow casting. Defaults to 0 o"
         "n entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on w"
         "orld. > 1 = cast shadows on entities with _rs (or _receiveshadows) w"
         "ith the corresponding value, AND world. Negative values imply same, "
         "but DO NOT cast shadows on world."
      }
      _rs OR _receiveshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow reception. Defaults to 1"
         " on everything (world shadows). 0 = receives NO shadows. > 1 = recei"
         "ve shadows only from corresponding keyed entities (see above) and wo"
         "rld. < 1 = receive shadows ONLY from corresponding keyed entities."
      }
      _celshader: =
      {
        txt = "&"
        hint = "Sets the cel shader used for this geometry. Note: Omit the "$22
         "$22"$22"textures/"$22"$22"$22" prefix."
      }
      sep: =
      {
        txt = "-------- Q3MAP2 TERRAIN KEYS --------"
        typ = "S"
      }
      _indexmap OR alphamap: =
      {
        txt = "&"
        hint = "Path/name for the art file used to guide the mapping of textur"
         "es on the terrain surface."
      }
      _layers OR layers: =
      {
        txt = "&"
        hint = "Integer value denotes number of unique root shaders that will "
         "be used on the terrain."
      }
      _shader OR shader: =
      {
        txt = "&"
        hint = "Path to the metashader used to assign textures to the terrain "
         "entity. Note: Omit the "$22"$22"$22"textures/"$22"$22"$22" prefix."
      }
    }
    func_door:form =
    {
      help = "Normal sliding door entity. By default, the door will activate w"
       "hen player walks close to it or when damage is inflicted to it."$0D"--"
       "------ KEYS --------"$0D"angle : Determines the opening direction of d"
       "oor (up = -1, down = -2)."$0D"speed : Determines how fast the door mov"
       "es (default 100)."$0D"wait : Number of seconds before door returns (de"
       "fault 2, -1 = return immediately)."$0D"lip : Lip remaining at end of m"
       "ove (default 8)."$0D"targetname : If set, a func_button or trigger is "
       "required to activate the door."$0D"health : If set to a non-zero value"
       ", the door must be damaged by "$22"health"$22" amount of points to act"
       "ivate (default 0)."$0D"dmg : Damage to inflict on player when he block"
       "s operation of door (default 4). Door will reverse direction when bloc"
       "ked unless CRUSHER spawnflag is set."$0D"team : Assign the same team n"
       "ame to multiple doors that should operate together (see notes)."$0D"on"
       "ly : Set to allow only one team to use this entity, used for CTF or ot"
       "her respawn type modes to create spawn rooms. Values: blue or red - De"
       "fault: anyone"$0D"CloseWhenIdle: When set to 1, the door will close as"
       " soon as there are no players in the triggering brush (For CTF Spawn R"
       "oom doors, SEE NOTES!)"$0D"trigger_only : Set to 1 if the door can onl"
       "y be opened by a switch or trigger (ie: prevents a player from opening"
       " it manually)"$0D"pos1 : Sound to play when door starts moving ("$22"n"
       "one"$22" for nothing, defaults to a creak)"$0D"pos2 : Sound to play wh"
       "en door stops moving ("$22"none"$22" for nothing, defaults to a creak)"
       $0D"noise : Looping sound as door is moving"$0D"light : ConstantLight r"
       "adius of .md3 model included with entity. Has no effect on the entity'"
       "s brushes (default 0)."$0D"color : ConstantLight color of .md3 model i"
       "ncluded with entity. Has no effect on the entity's brushes (default 1 "
       "1 1)."$0D"model2 : Path/name of model to include (.md3 files only, e.g"
       ". models/mapobjects/pipe/pipe02.md3)."$0D"origin : Alternate method of"
       " setting XYZ origin of .md3 model included with entity (see notes)."$0D
       "notfree : When set to 1, entity will not spawn in "$22"Free for all"$22
       " and "$22"Tournament"$22" modes."$0D"notteam : When set to 1, entity w"
       "ill not spawn in "$22"Teamplay"$22" and "$22"CTF"$22" modes."$0D"notsi"
       "ngle : When set to 1, entity will not spawn in Single Player mode (bot"
       " play mode)."$0D"-------- Q3MAP2 KEYS --------"$0D"_lightmapscale : Fl"
       "oating point value scales the resolution of lightmaps on brushes/patch"
       "es in this entity (default 1.0)."$0D"_cs OR _castshadows : Allows per-"
       "entity control over shadow casting. Defaults to 0 on entities, 1 on wo"
       "rld. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shad"
       "ows on entities with _rs (or _receiveshadows) with the corresponding v"
       "alue, AND world. Negative values imply same, but DO NOT cast shadows o"
       "n world."$0D"_rs OR _receiveshadows : Allows per-entity control over s"
       "hadow reception. Defaults to 1 on everything (world shadows). 0 = rece"
       "ives NO shadows. > 1 = receive shadows only from corresponding keyed e"
       "ntities (see above) and world. < 1 = receive shadows ONLY from corresp"
       "onding keyed entities."$0D"_celshader : Sets the cel shader used for t"
       "his geometry. Note: Omit the "$22"textures/"$22" prefix."$0D"-------- "
       "Q3MAP2 TERRAIN KEYS --------"$0D"_indexmap OR alphamap : Path/name for"
       " the art file used to guide the mapping of textures on the terrain sur"
       "face."$0D"_layers OR layers : Integer value denotes number of unique r"
       "oot shaders that will be used on the terrain."$0D"_shader OR shader : "
       "Path to the metashader used to assign textures to the terrain entity. "
       "Note: Omit the "$22"textures/"$22" prefix."$0D"-------- SPAWNFLAGS ---"
       "-----"$0D"START_OPEN : The door will spawn in the open state and opera"
       "te in reverse."$0D"CRUSHER : Door will not reverse direction when bloc"
       "ked and will keep damaging player until he dies or gets out of the way"
       "."$0D"-------- NOTES --------"$0D"To use the CloseWhenIdle setting for"
       " CTF Spawn Room doors, you must also set trigger_only, and use a trigg"
       "er_multiple to open the door. This will cause the door to remain open "
       "only as long as a player is in the triggering brush.  Set the 'wait' k"
       "ey on the trigger_multiple to a very low value( < 1 like .25 )"$0D"Unl"
       "ike in Quake 2, doors that touch are NOT automatically teamed. If you "
       "want doors to operate together, you have to team them manually by assi"
       "gning the same team name to all of them. Setting the origin key is sim"
       "ply an alternate method to using an origin brush. When using the model"
       "2 key, the origin point of the model will correspond to the origin poi"
       "nt defined by either the origin brush or the origin coordinate value."
      spawnflags: =
      {
        txt = "&"
        hint = "The door will spawn in the open state and operate in reverse."
        typ = "X1"
        cap = "START_OPEN"
      }
      spawnflags: =
      {
        txt = "&"
        hint = "Door will not reverse direction when blocked and will keep dam"
         "aging player until he dies or gets out of the way."
        typ = "X4"
        cap = "CRUSHER"
      }
      angle: =
      {
        txt = "&"
        hint = "Determines the opening direction of door (up = -1, down = -2)."
      }
      speed: =
      {
        txt = "&"
        hint = "Determines how fast the door moves (default 100)."
      }
      wait: =
      {
        txt = "&"
        hint = "Number of seconds before door returns (default 2, -1 = return "
         "immediately)."
      }
      lip: =
      {
        txt = "&"
        hint = "Lip remaining at end of move (default 8)."
      }
      targetname: =
      {
        txt = "&"
        hint = "If set, a func_button or trigger is required to activate the d"
         "oor."
      }
      health: =
      {
        txt = "&"
        hint = "If set to a non-zero value, the door must be damaged by "$22"$"
         "22"$22"health"$22"$22"$22" amount of points to activate (default 0)."
      }
      dmg: =
      {
        txt = "&"
        hint = "Damage to inflict on player when he blocks operation of door ("
         "default 4). Door will reverse direction when blocked unless CRUSHER "
         "spawnflag is set."
      }
      team: =
      {
        txt = "&"
        hint = "Assign the same team name to multiple doors that should operat"
         "e together (see notes)."
      }
      only: =
      {
        txt = "&"
        hint = "Set to allow only one team to use this entity, used for CTF or"
         " other respawn type modes to create spawn rooms. Values: blue or red"
         " - Default: anyone"
      }
      CloseWhenIdle: =
      {
        txt = "&"
        hint = "When set to 1, the door will close as soon as there are no pla"
         "yers in the triggering brush (For CTF Spawn Room doors, SEE NOTES!)"
      }
      trigger_only: =
      {
        txt = "&"
        hint = "Set to 1 if the door can only be opened by a switch or trigger"
         " (ie: prevents a player from opening it manually)"
      }
      pos1: =
      {
        txt = "&"
        hint = "Sound to play when door starts moving ("$22"$22"$22"none"$22"$"
         "22"$22" for nothing, defaults to a creak)"
      }
      pos2: =
      {
        txt = "&"
        hint = "Sound to play when door stops moving ("$22"$22"$22"none"$22"$2"
         "2"$22" for nothing, defaults to a creak)"
      }
      noise: =
      {
        txt = "&"
        hint = "Looping sound as door is moving"
      }
      light: =
      {
        txt = "&"
        hint = "ConstantLight radius of .md3 model included with entity. Has n"
         "o effect on the entity's brushes (default 0)."
      }
      color: =
      {
        txt = "&"
        hint = "ConstantLight color of .md3 model included with entity. Has no"
         " effect on the entity's brushes (default 1 1 1)."
      }
      model2: =
      {
        txt = "&"
        hint = "Path/name of model to include (.md3 files only, e.g. models/ma"
         "pobjects/pipe/pipe02.md3)."
      }
      origin: =
      {
        txt = "&"
        hint = "Alternate method of setting XYZ origin of .md3 model included "
         "with entity (see notes)."
      }
      notfree: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
      sep: =
      {
        txt = "-------- Q3MAP2 KEYS --------"
        typ = "S"
      }
      _lightmapscale: =
      {
        txt = "&"
        hint = "Floating point value scales the resolution of lightmaps on bru"
         "shes/patches in this entity (default 1.0)."
      }
      _cs OR _castshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow casting. Defaults to 0 o"
         "n entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on w"
         "orld. > 1 = cast shadows on entities with _rs (or _receiveshadows) w"
         "ith the corresponding value, AND world. Negative values imply same, "
         "but DO NOT cast shadows on world."
      }
      _rs OR _receiveshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow reception. Defaults to 1"
         " on everything (world shadows). 0 = receives NO shadows. > 1 = recei"
         "ve shadows only from corresponding keyed entities (see above) and wo"
         "rld. < 1 = receive shadows ONLY from corresponding keyed entities."
      }
      _celshader: =
      {
        txt = "&"
        hint = "Sets the cel shader used for this geometry. Note: Omit the "$22
         "$22"$22"textures/"$22"$22"$22" prefix."
      }
      sep: =
      {
        txt = "-------- Q3MAP2 TERRAIN KEYS --------"
        typ = "S"
      }
      _indexmap OR alphamap: =
      {
        txt = "&"
        hint = "Path/name for the art file used to guide the mapping of textur"
         "es on the terrain surface."
      }
      _layers OR layers: =
      {
        txt = "&"
        hint = "Integer value denotes number of unique root shaders that will "
         "be used on the terrain."
      }
      _shader OR shader: =
      {
        txt = "&"
        hint = "Path to the metashader used to assign textures to the terrain "
         "entity. Note: Omit the "$22"$22"$22"textures/"$22"$22"$22" prefix."
      }
    }
    func_rotating_door:form =
    {
      help = "-------- KEYS --------"$0D"pos1 : sound to play when door starts"
       " moving ("$22"none"$22" for nothing, defaults to a creak)"$0D"pos2 : s"
       "ound to play when door stops moving ("$22"none"$22" for nothing, defau"
       "lts to a creak)"$0D"noise : looping sound to play as door is moving (d"
       "efaults to no sound)"$0D"targetname : name of a target to trigger when"
       " door opens"$0D"color :    constantLight color"$0D"light : constantLig"
       "ht radius"$0D"direction : force door to open in a set direction: -1 is"
       " clockwise, 1 is ccw"$0D"speed : defaults to 100, speed at which door "
       "opens"$0D"wait : how long to wait until door auto-closes (default is 0"
       ", which means stay open)"$0D"trigger_only : set to 1 if the door can o"
       "nly be opened by a switch or trigger(ie: prevents a player from openin"
       "g it manually)"$0D"axis : door rotation axis, values: 0 (for x-axis), "
       "1(for y-axis), 2(for z-axis) (if not given, default is 2 for z-axis)"$0D
       "damage : damage door does to a player if they block it (leave out in m"
       "ost cases)"$0D"gamemode_open : gametypes to have the door locked in th"
       "e open position"$0D"gamemode_shut : gametypes to have the door locked "
       "in the closed position"$0D"only : set to allow only one team to use th"
       "is entity, used for CTF or other respawn type modes to create spawn ro"
       "oms. Values: blue or red - Default: anyone"$0D"-------- NOTES --------"
       $0D"Rotating doors cannot be shot open, and will only close or open if "
       "activated by a player.  They will not automatically close after a peri"
       "od either.  In game modes not listed under either gamemode_open or gam"
       "emode_shut, the doors will open and close normally."$0D"You construct "
       "a rotating door just like a FUNC_ROTATING: it needs an origin brush to"
       " act as the hinge."$0D"Urban Terror gametype mappings are:"$0D"Free Fo"
       "r All 0"$0D"Last Man Standing 1 (use FFA 0 for entities)"$0D"Team Deat"
       "hmatch 3"$0D"Team Survivor 4"$0D"Assasins 5"$0D"Capture And Hold 6"$0D
       "Capture The Flag 7"$0D"Bomb 8"$0D"Jump Mode 9"
      pos1: =
      {
        txt = "&"
        hint = "sound to play when door starts moving ("$22"$22"$22"none"$22"$"
         "22"$22" for nothing, defaults to a creak)"
      }
      pos2: =
      {
        txt = "&"
        hint = "sound to play when door stops moving ("$22"$22"$22"none"$22"$2"
         "2"$22" for nothing, defaults to a creak)"
      }
      noise: =
      {
        txt = "&"
        hint = "looping sound to play as door is moving (defaults to no sound)"
      }
      targetname: =
      {
        txt = "&"
        hint = "name of a target to trigger when door opens"
      }
      color: =
      {
        txt = "&"
        hint = "constantLight color"
      }
      light: =
      {
        txt = "&"
        hint = "constantLight radius"
      }
      direction: =
      {
        txt = "&"
        hint = "force door to open in a set direction: -1 is clockwise, 1 is c"
         "cw"
      }
      speed: =
      {
        txt = "&"
        hint = "defaults to 100, speed at which door opens"
      }
      wait: =
      {
        txt = "&"
        hint = "how long to wait until door auto-closes (default is 0, which m"
         "eans stay open)"
      }
      trigger_only: =
      {
        txt = "&"
        hint = "set to 1 if the door can only be opened by a switch or trigger"
         "(ie: prevents a player from opening it manually)"
      }
      axis: =
      {
        txt = "&"
        hint = "door rotation axis, values: 0 (for x-axis), 1(for y-axis), 2(f"
         "or z-axis) (if not given, default is 2 for z-axis)"
      }
      damage: =
      {
        txt = "&"
        hint = "damage door does to a player if they block it (leave out in mo"
         "st cases)"
      }
      gamemode_open: =
      {
        txt = "&"
        hint = "gametypes to have the door locked in the open position"
      }
      gamemode_shut: =
      {
        txt = "&"
        hint = "gametypes to have the door locked in the closed position"
      }
      only: =
      {
        txt = "&"
        hint = "set to allow only one team to use this entity, used for CTF or"
         " other respawn type modes to create spawn rooms. Values: blue or red"
         " - Default: anyone"
      }
    }
    func_breakable:form =
    {
      help = "A breakable thing just sits there, doing nothing,"$0D"but will b"
       "reak if damaged or collided with."$0D"-------- KEYS --------"$0D"model"
       "2 : path/name of model to include (eg: models/mapobjects/pipe/pipe02.m"
       "d3)."$0D"color : constantLight color"$0D"light : constantLight radius"$0D
       "type : 0: glass 1: wood 2: ceramic 3: plastic 4: metal-normal 5: metal"
       "-explosives 6: metal-hk69 7: stone-explosives 8: stone-hk69 9: wood-ex"
       "plosives 10: wood-hk69(SEE NOTES)"$0D"axis : 1 - x, 2 - y, 4 - z"$0D"h"
       "ealth : health of object"$0D"model2 : path/name of model to include (e"
       "g: models/mapobjects/pipe/pipe02.md3)."$0D"shards : number of shards o"
       "bject should shatter into (0-255)"$0D"bombable : allows the entity to "
       "be destroyed by the bomb in bomb mode. The size of blast shown when th"
       "e entity breaks is determined by this value (Values : 1 none - 255 hug"
       "e blast)."$0D"-------- NOTES --------"$0D"- For glass windows that bre"
       "ak easily, set health to 1."$0D"- Any func_breakable with a health of "
       "less than 10 will slowly weaken if a player is in contact with it.  Yo"
       "u can make a roof that collapses in after a period of time by setting "
       "the health to a value like 5.  This will mean that a player standing o"
       "n such a surface for around 5 seconds will fall thru.  The effect is c"
       "umulative: if you stand there for 3 seconds and then come back you can"
       " only stand on it for another 2 seconds."$0D"- The type parameter sele"
       "cts the shader that is used for fragments and sets the sound the objec"
       "t makes when it breaks."$0D"- If the brush you are making is on an ang"
       "le (for example, a skylight in a sloping roof) then you will need to s"
       "et the break axis to "$22"4"$22" if you want it to break when people s"
       "tand on it."$0D"- You can build anything to break using the breakables"
       ". You can make a model breakable without having to use the model2 key."
       " Just right click with it selected and choose func_breakable."$0D"- Se"
       "t shards as high as you want (it maxes out at 32 anyway) - players can"
       " reduce the number of shards they see using cg_maxFragments"$0D"- Bomb"
       "able key is to be used for things that can only be broken by the Bomb "
       "Mode bomb explosion. For example a large propane tank near a bomb targ"
       "et. The key's value will determine the size of the explosion graphics "
       "from this entity when broken, with a value of 1 being no explosion and"
       " a value of 255 being a large secondary blast."$0D"- Type values info "
       "for 1,2,3,4 - The game will attenuate the damage caused by each hit to"
       " a value of 1-3. Health values above 10 will choose a random health be"
       "tween 6 and 10. Specifics are as follows: 0: is for glass/windows 1: i"
       "s for all woods 2: is for ceramics and pottery 3: is for various plast"
       "ics 4: is for metal that can be broken by normal means"$0D"- Type valu"
       "es info for 5,6,7,8,9,10 - The game will use the literal health value "
       "compared to the weapon damages. They should be set quite high (metals "
       "and stone at 50+). Specifics are as follows: 5: is for metal that requ"
       "ires explosives to break (HE grenade or hk69) 6: is for metal that req"
       "uires the hk69 to break 7: is for stone that requires explosives to br"
       "eak (HE grenade or hk69) 8: is for stone that requires the hk69 to bre"
       "ak 9: is for wood that requires explosives to break (HE grenade or hk6"
       "9) 10: is for wood that requires the hk69 to break"
      model2: =
      {
        txt = "&"
        hint = "path/name of model to include (eg: models/mapobjects/pipe/pipe"
         "02.md3)."
      }
      color: =
      {
        txt = "&"
        hint = "constantLight color"
      }
      light: =
      {
        txt = "&"
        hint = "constantLight radius"
      }
      type: =
      {
        txt = "&"
        hint = "0: glass 1: wood 2: ceramic 3: plastic 4: metal-normal 5: meta"
         "l-explosives 6: metal-hk69 7: stone-explosives 8: stone-hk69 9: wood"
         "-explosives 10: wood-hk69(SEE NOTES)"
      }
      axis: =
      {
        txt = "&"
        hint = "1 - x, 2 - y, 4 - z"
      }
      health: =
      {
        txt = "&"
        hint = "health of object"
      }
      model2: =
      {
        txt = "&"
        hint = "path/name of model to include (eg: models/mapobjects/pipe/pipe"
         "02.md3)."
      }
      shards: =
      {
        txt = "&"
        hint = "number of shards object should shatter into (0-255)"
      }
      bombable: =
      {
        txt = "&"
        hint = "allows the entity to be destroyed by the bomb in bomb mode. Th"
         "e size of blast shown when the entity breaks is determined by this v"
         "alue (Values : 1 none - 255 huge blast)."
      }
    }
    func_wall:form =
    {
      help = "-------- KEYS --------"$0D"gametype : gametypes to have the wall"
       " appear in, list types in this format: 01234 (default none)"$0D"------"
       "-- NOTES --------"$0D"This entity is any brush or combination of brush"
       "es that you wish to have appear in gametypes specified."$0D"Common use"
       "s are to cut of map sections to streamline gameplay for TS, or to expa"
       "nd the map for CTF or Bomb."$0D"You cannot use a model as a func_wall."
       $0D"Create your brush(es), select it (or them), then make them a func_w"
       "all and set gametype keys."$0D"Urban Terror gametype mappings are:"$0D
       "Free For All 0"$0D"Last Man Standing 1 (use FFA 0 for entities)"$0D"Te"
       "am Deathmatch 3"$0D"Team Survivor 4"$0D"Assasins 5"$0D"Capture And Hol"
       "d 6"$0D"Capture The Flag 7"$0D"Bomb 8"$0D"Jump Mode 9"
      gametype: =
      {
        txt = "&"
        hint = "gametypes to have the wall appear in, list types in this forma"
         "t: 01234 (default none)"
      }
    }
    func_ut_train:form =
    {
      help = "A train is a mover that moves between path_ut_stop target points"
       "."$0D"-------- KEYS --------"$0D"model2 : .md3 model to also draw"$0D"n"
       "ame : to associate with a set of control buttons"$0D"noise : looping s"
       "ound to play when the train is in motion"$0D"color : constantLight col"
       "or"$0D"light : constantLight radius"$0D"speed : default 350"$0D"dmg : "
       "default 0"$0D"target : first path_ut_stop, train spawns here"$0D"inter"
       "face : the targetname of the func_keyboard_interface that belongs to t"
       "his train"$0D"id : to uniquely associate it with a set of control butt"
       "ons"$0D"startSound : sound to play when train begins moving to a new d"
       "estination"$0D"stopSound : sound to play when train arrives at a final"
       " stop"$0D"noise : constant looping sound to always be playing where th"
       "e train is"$0D"-------- NOTES --------"$0D"- Trains MUST HAVE AN ORIGI"
       "N BRUSH."$0D"- The train spawns at the first target it is pointing at."
       $0D"- The train will move to any stop from any stop. See the descriptio"
       "n for the func_keyboard_interface for more info."
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "START_ON"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "TOGGLE"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "BLOCK_STOPS"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "CRUSHER"
      }
      model2: =
      {
        txt = "&"
        hint = ".md3 model to also draw"
      }
      name: =
      {
        txt = "&"
        hint = "to associate with a set of control buttons"
      }
      noise: =
      {
        txt = "&"
        hint = "looping sound to play when the train is in motion"
      }
      color: =
      {
        txt = "&"
        hint = "constantLight color"
      }
      light: =
      {
        txt = "&"
        hint = "constantLight radius"
      }
      speed: =
      {
        txt = "&"
        hint = "default 350"
      }
      dmg: =
      {
        txt = "&"
        hint = "default 0"
      }
      target: =
      {
        txt = "&"
        hint = "first path_ut_stop, train spawns here"
      }
      interface: =
      {
        txt = "&"
        hint = "the targetname of the func_keyboard_interface that belongs to "
         "this train"
      }
      id: =
      {
        txt = "&"
        hint = "to uniquely associate it with a set of control buttons"
      }
      startSound: =
      {
        txt = "&"
        hint = "sound to play when train begins moving to a new destination"
      }
      stopSound: =
      {
        txt = "&"
        hint = "sound to play when train arrives at a final stop"
      }
      noise: =
      {
        txt = "&"
        hint = "constant looping sound to always be playing where the train is"
      }
    }
    func_keyboard_interface:form =
    {
      help = "keyboard menu interface"$0D"-------- KEYS --------"$0D"display :"
       " if 0, menu is not dispayed, if 1, menu is displayed, default 1"$0D"id"
       " : id of the func_ut_train that this interface associates with"$0D"tar"
       "getname : id for the func_ut_train key "$22"interface"$22" to associat"
       "e it with the right func_ut_train"$0D"option1 : text message to descri"
       "be the first destination"$0D"option2 : text message to describe the se"
       "cond destination"$0D"option3 : text message to describe the third dest"
       "ination"$0D"option4 : text message to describe the fourth destination"$0D
       "option5 : text message to describe the five destination"$0D"stop1 : ta"
       "rgetname of first destination"$0D"stop2 : targetname of second destina"
       "tion"$0D"stop3 : targetname of third destination"$0D"stop4 : targetnam"
       "e of fourth destination"$0D"stop5 : targetname of fifth destination"$0D
       "stop2from1 : beginning of path from 1 to 2"$0D"stop3from1 : beginning "
       "of path from 1 to 3"$0D"stop4from1 : beginning of path from 1 to 4"$0D
       "stop5from1 : beginning of path from 1 to 5"$0D"stop1from2 : beginning "
       "of path from 2 to 1"$0D"stop3from2 : beginning of path from 2 to 3"$0D
       "stop4from2 : beginning of path from 2 to 4"$0D"stop5from2 : beginning "
       "of path from 2 to 5"$0D"stop1from3 : beginning of path from 3 to 1"$0D
       "stop2from3 : beginning of path from 3 to 2"$0D"stop4from3 : beginning "
       "of path from 3 to 4"$0D"stop5from3 : beginning of path from 3 to 5"$0D
       "stop1from4 : beginning of path from 4 to 1"$0D"stop2from4 : beginning "
       "of path from 4 to 2"$0D"stop3from4 : beginning of path from 4 to 3"$0D
       "stop5from4 : beginning of path from 4 to 5"$0D"stop1from5 : beginning "
       "of path from 5 to 1"$0D"stop2from5 : beginning of path from 5 to 2"$0D
       "stop3from5 : beginning of path from 5 to 3"$0D"stop4from5 : beginning "
       "of path from 5 to 4"$0D"-------- NOTES --------"$0D"- All the stopXfro"
       "mY (where X and Y are numbers) should target a path_ut_stop"$0D"- The "
       "stopX keys (where X is a number) should target the ending path_ut_stop"
       ", i.e. the last stop at location X."$0D"- The optionX keys (where X is"
       " a number) corresponds to the stopX keys. So if you set the name "$22"t"
       "op floor"$22" for option1, make sure that stop1 actually is at the "$22
       "top floor"$22
      display: =
      {
        txt = "&"
        hint = "if 0, menu is not dispayed, if 1, menu is displayed, default 1"
      }
      id: =
      {
        txt = "&"
        hint = "id of the func_ut_train that this interface associates with"
      }
      targetname: =
      {
        txt = "&"
        hint = "id for the func_ut_train key "$22"$22"$22"interface"$22"$22"$22
         " to associate it with the right func_ut_train"
      }
      option1: =
      {
        txt = "&"
        hint = "text message to describe the first destination"
      }
      option2: =
      {
        txt = "&"
        hint = "text message to describe the second destination"
      }
      option3: =
      {
        txt = "&"
        hint = "text message to describe the third destination"
      }
      option4: =
      {
        txt = "&"
        hint = "text message to describe the fourth destination"
      }
      option5: =
      {
        txt = "&"
        hint = "text message to describe the five destination"
      }
      stop1: =
      {
        txt = "&"
        hint = "targetname of first destination"
      }
      stop2: =
      {
        txt = "&"
        hint = "targetname of second destination"
      }
      stop3: =
      {
        txt = "&"
        hint = "targetname of third destination"
      }
      stop4: =
      {
        txt = "&"
        hint = "targetname of fourth destination"
      }
      stop5: =
      {
        txt = "&"
        hint = "targetname of fifth destination"
      }
      stop2from1: =
      {
        txt = "&"
        hint = "beginning of path from 1 to 2"
      }
      stop3from1: =
      {
        txt = "&"
        hint = "beginning of path from 1 to 3"
      }
      stop4from1: =
      {
        txt = "&"
        hint = "beginning of path from 1 to 4"
      }
      stop5from1: =
      {
        txt = "&"
        hint = "beginning of path from 1 to 5"
      }
      stop1from2: =
      {
        txt = "&"
        hint = "beginning of path from 2 to 1"
      }
      stop3from2: =
      {
        txt = "&"
        hint = "beginning of path from 2 to 3"
      }
      stop4from2: =
      {
        txt = "&"
        hint = "beginning of path from 2 to 4"
      }
      stop5from2: =
      {
        txt = "&"
        hint = "beginning of path from 2 to 5"
      }
      stop1from3: =
      {
        txt = "&"
        hint = "beginning of path from 3 to 1"
      }
      stop2from3: =
      {
        txt = "&"
        hint = "beginning of path from 3 to 2"
      }
      stop4from3: =
      {
        txt = "&"
        hint = "beginning of path from 3 to 4"
      }
      stop5from3: =
      {
        txt = "&"
        hint = "beginning of path from 3 to 5"
      }
      stop1from4: =
      {
        txt = "&"
        hint = "beginning of path from 4 to 1"
      }
      stop2from4: =
      {
        txt = "&"
        hint = "beginning of path from 4 to 2"
      }
      stop3from4: =
      {
        txt = "&"
        hint = "beginning of path from 4 to 3"
      }
      stop5from4: =
      {
        txt = "&"
        hint = "beginning of path from 4 to 5"
      }
      stop1from5: =
      {
        txt = "&"
        hint = "beginning of path from 5 to 1"
      }
      stop2from5: =
      {
        txt = "&"
        hint = "beginning of path from 5 to 2"
      }
      stop3from5: =
      {
        txt = "&"
        hint = "beginning of path from 5 to 3"
      }
      stop4from5: =
      {
        txt = "&"
        hint = "beginning of path from 5 to 4"
      }
    }
    path_ut_stop:form =
    {
      help = "Train path stops."$0D"-------- KEYS --------"$0D"target : next p"
       "ath stop and other targets to fire"$0D"trainID : the id of the train t"
       "hat this stop is for"$0D"wait : the amount of time train should wait a"
       "t this stop, default is 0"$0D"rotationTime : the amount of time (in mi"
       "lleseconds) that the train should rotate for at this stop according to"
       " yawSpeed, pitchSpeed, and rollSpeed"$0D"yawSpeed : the speed of yaw r"
       "otation that the train will do once at this stop for rotationTime amou"
       "nd of milleseconds"$0D"pitchSpeed : the speed of pitch rotation that t"
       "he train will do once at this stop for rotationTime amound of millesec"
       "onds"$0D"rollSpeed : the speed of roll rotation that the train will do"
       " once at this stop for rotationTime amound of milleseconds"$0D"-------"
       "- NOTES --------"$0D"- Pitch and roll doesn't work very well right now"
       " because of the collision handling of Q3. This makes it hard to make t"
       "hings that the player is supposed to ride work properly. Trial and err"
       "or would probably be the best method to find out what works and what d"
       "oesn't."$0D"- You can have the path_ut_stop trigger almost anything. F"
       "or example, you could use it to open a door or to trigger a func_butto"
       "n."
      bbox = '-8 -8 -8 8 8 8'
      target: =
      {
        txt = "&"
        hint = "next path stop and other targets to fire"
      }
      trainID: =
      {
        txt = "&"
        hint = "the id of the train that this stop is for"
      }
      wait: =
      {
        txt = "&"
        hint = "the amount of time train should wait at this stop, default is "
         "0"
      }
      rotationTime: =
      {
        txt = "&"
        hint = "the amount of time (in milleseconds) that the train should rot"
         "ate for at this stop according to yawSpeed, pitchSpeed, and rollSpee"
         "d"
      }
      yawSpeed: =
      {
        txt = "&"
        hint = "the speed of yaw rotation that the train will do once at this "
         "stop for rotationTime amound of milleseconds"
      }
      pitchSpeed: =
      {
        txt = "&"
        hint = "the speed of pitch rotation that the train will do once at thi"
         "s stop for rotationTime amound of milleseconds"
      }
      rollSpeed: =
      {
        txt = "&"
        hint = "the speed of roll rotation that the train will do once at this"
         " stop for rotationTime amound of milleseconds"
      }
    }
    trigger_location:form =
    {
      help = "Specifies the name of a location when the player is within this "
       "trigger."$0D"-------- KEYS --------"$0D"message : Name of the location"
       " (text string). Displayed in parentheses in front of all team chat and"
       " order messages."$0D"count : Color of the location text displayed in p"
       "arentheses during team chat. Set to 0-7 for color."$0D"//Attacking_Tea"
       "m : For Bomb Mode ONLY - when set to 1, the BLUE team will be the atta"
       "cker, set to 0 if you want the RED team to attack. Default 0 (RED is A"
       "ttacker)"$0D"notfree : when set to 1, entity will not spawn in "$22"Fr"
       "ee for all"$22" and "$22"Tournament"$22" modes."$0D"notteam : when set"
       " to 1, entity will not spawn in "$22"Teamplay"$22" and "$22"CTF"$22" m"
       "odes."$0D"notsingle : when set to 1, entity will not spawn in Single P"
       "layer mode (bot play mode)."$0D"-------- NOTES --------"$0D"The values"
       " for the colors that can be set in the count key are as follows:"$0D"0"
       " : white (default)"$0D"1 : red"$0D"2 : green"$0D"3 : yellow"$0D"4 : bl"
       "ue"$0D"5 : cyan"$0D"6 : magenta"$0D"7 : white"
      message: =
      {
        txt = "&"
        hint = "Name of the location (text string). Displayed in parentheses i"
         "n front of all team chat and order messages."
      }
      count: =
      {
        txt = "&"
        hint = "Color of the location text displayed in parentheses during tea"
         "m chat. Set to 0-7 for color."
      }
      //Attacking_Team: =
      {
        txt = "&"
        hint = "For Bomb Mode ONLY - when set to 1, the BLUE team will be the "
         "attacker, set to 0 if you want the RED team to attack. Default 0 (RE"
         "D is Attacker)"
      }
      notfree: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
    }
    target_speaker:form =
    {
      help = "Sound generating entity that plays .wav files. Normal non-loopin"
       "g sounds play each time the target_speaker is triggered. Looping sound"
       "s can be set to play by themselves (no activating trigger) or be toggl"
       "ed on/off by a trigger."$0D"-------- KEYS --------"$0D"noise : Path/na"
       "me of .wav file to play (e.g. sound/world/growl1.wav - see notes)."$0D
       "wait : Delay in seconds between each time the sound is played ("$22"ra"
       "ndom"$22" key must be set - see notes)."$0D"random : Random time varia"
       "nce in seconds added or subtracted from "$22"wait"$22" delay ("$22"wai"
       "t"$22" key must be set - see notes)."$0D"targetname : The activating b"
       "utton or trigger points to this."$0D"notfree : When set to 1, entity w"
       "ill not spawn in "$22"Free for all"$22" and "$22"Tournament"$22" modes"
       "."$0D"notteam : When set to 1, entity will not spawn in "$22"Teamplay"$22
       " and "$22"CTF"$22" modes."$0D"notsingle : When set to 1, entity will n"
       "ot spawn in Single Player mode (bot play mode)."$0D"gametype : Specifi"
       "es gametypes to play the sound in. If this key is not used, sound will"
       " play in all gametypes. List types in this format: 01234"$0D"-------- "
       "SPAWNFLAGS --------"$0D"LOOPED_ON : Sound will loop and initially star"
       "t on in level (will toggle on/off when triggered)."$0D"LOOPED_OFF : So"
       "und will loop and initially start off in level (will toggle on/off whe"
       "n triggered)."$0D"GLOBAL : Sound will play full volume throughout the "
       "level."$0D"ACTIVATOR : Sound will play only for the player that activa"
       "ted the target."$0D"-------- NOTES --------"$0D"The path portion value"
       " of the "$22"noise"$22" key can be replaced by the implicit folder cha"
       "racter "$22"*"$22" for triggered sounds that belong to a particular pl"
       "ayer model. For example, if you want to create a "$22"bottomless pit"$22
       " in which the player screams and dies when he falls into, you would pl"
       "ace a trigger_multiple over the floor of the pit and target a target_s"
       "peaker with it. Then, you would set the "$22"noise"$22" key to "$22"*f"
       "alling1.wav"$22". The * character means the current player model's sou"
       "nd folder. So if your current player model is Visor, * = sound/player/"
       "visor, if your current player model is Sarge, * = sound/player/sarge, "
       "etc. This cool feature provides an excellent way to create "$22"player"
       "-specific"$22" triggered sounds in your levels."$0D"The combination of"
       " the "$22"wait"$22" and "$22"random"$22" keys can be used to play non-"
       "looping sounds without requiring an activating trigger but both keys m"
       "ust be used together. The value of the "$22"random"$22" key is used to"
       " calculate a minimum and a maximum delay. The final time delay will be"
       " a random value anywhere between the minimum and maximum values: (min "
       "delay = wait - random) (max delay = wait + random)."
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        txt = "&"
        hint = "Sound will loop and initially start on in level (will toggle o"
         "n/off when triggered)."
        typ = "X1"
        cap = "LOOPED_ON"
      }
      spawnflags: =
      {
        txt = "&"
        hint = "Sound will loop and initially start off in level (will toggle "
         "on/off when triggered)."
        typ = "X2"
        cap = "LOOPED_OFF"
      }
      spawnflags: =
      {
        txt = "&"
        hint = "Sound will play full volume throughout the level."
        typ = "X4"
        cap = "GLOBAL"
      }
      spawnflags: =
      {
        txt = "&"
        hint = "Sound will play only for the player that activated the target."
        typ = "X8"
        cap = "ACTIVATOR"
      }
      noise: =
      {
        txt = "&"
        hint = "Path/name of .wav file to play (e.g. sound/world/growl1.wav - "
         "see notes)."
      }
      wait: =
      {
        txt = "&"
        hint = "Delay in seconds between each time the sound is played ("$22"$"
         "22"$22"random"$22"$22"$22" key must be set - see notes)."
      }
      random: =
      {
        txt = "&"
        hint = "Random time variance in seconds added or subtracted from "$22"$"
         "22"$22"wait"$22"$22"$22" delay ("$22"$22"$22"wait"$22"$22"$22" key m"
         "ust be set - see notes)."
      }
      targetname: =
      {
        txt = "&"
        hint = "The activating button or trigger points to this."
      }
      notfree: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
      gametype: =
      {
        txt = "&"
        hint = "Specifies gametypes to play the sound in. If this key is not u"
         "sed, sound will play in all gametypes. List types in this format: 01"
         "234"
      }
    }
    trigger_multiple:form =
    {
      help = "Variable size repeatable trigger. It will fire the entities it t"
       "argets when touched by player. Can be made to operate like a trigger_o"
       "nce entity by setting the "$22"wait"$22" key to -1. It can also be act"
       "ivated by another trigger that targets it."$0D"-------- KEYS --------"$0D
       "target : This points to the entity to activate."$0D"targetname : Activ"
       "ating trigger points to this."$0D"targetShaderName : Points to the nam"
       "e of the original shader to swap out for triggerable shader entities ("
       "see notes)."$0D"targetShaderNewName : Points to the name of the new sh"
       "ader to swap in for triggerable shader entities (see notes)."$0D"wait "
       ": Time in seconds until trigger becomes re-triggerable after it's been"
       " touched (default 0.2, -1 = trigger once, see notes)."$0D"random : Ran"
       "dom time variance in seconds added or subtracted from "$22"wait"$22" d"
       "elay (default 0 - see notes)."$0D"only : set to allow only one team to"
       " use this entity, used for CTF or other respawn type modes to create s"
       "pawn rooms. Values: blue or red - Default: anyone"$0D"notfree : When s"
       "et to 1, entity will not spawn in "$22"Free for all"$22" and "$22"Tour"
       "nament"$22" modes."$0D"notteam : When set to 1, entity will not spawn "
       "in "$22"Teamplay"$22" and "$22"CTF"$22" modes."$0D"notsingle : When se"
       "t to 1, entity will not spawn in Single Player mode (bot play mode)."$0D
       "-------- NOTES --------"$0D"Set the 'wait' key to .25 if using the Clo"
       "seWhenIdle key when triggering a door."$0D"Do not set the 'wait' key t"
       "o 0 as it causes the trigger to malfunction and not trigger again most"
       " of the time after one activation."$0D"When the random key is set, its"
       " value is used to calculate a minimum and a maximum delay. The final t"
       "ime delay will be a random value anywhere between the minimum and maxi"
       "mum values: (min delay = wait - random) (max delay = wait + random)."$0D
       "When the entity activates its targets, all shaders/textures in the map"
       " that were originally the same name as the targetShaderName value, wil"
       "l be changed to the targetShaderNewName value. For example, turning a "
       "light on:"$0D22"targetShaderName"$22" "$22"textures/proto2/redlight_of"
       "f"$220D22"targetShaderNewName"$22" "$22"textures/proto2/redlight_on"$22
       $0D"And this would turn it back off:"$0D22"targetShaderName"$22" "$22"t"
       "extures/proto2/redlight_off"$220D22"targetShaderNewName"$22" "$22"text"
       "ures/proto2/redlight_off"$22
      target: =
      {
        txt = "&"
        hint = "This points to the entity to activate."
      }
      targetname: =
      {
        txt = "&"
        hint = "Activating trigger points to this."
      }
      targetShaderName: =
      {
        txt = "&"
        hint = "Points to the name of the original shader to swap out for trig"
         "gerable shader entities (see notes)."
      }
      targetShaderNewName: =
      {
        txt = "&"
        hint = "Points to the name of the new shader to swap in for triggerabl"
         "e shader entities (see notes)."
      }
      wait: =
      {
        txt = "&"
        hint = "Time in seconds until trigger becomes re-triggerable after it'"
         "s been touched (default 0.2, -1 = trigger once, see notes)."
      }
      random: =
      {
        txt = "&"
        hint = "Random time variance in seconds added or subtracted from "$22"$"
         "22"$22"wait"$22"$22"$22" delay (default 0 - see notes)."
      }
      only: =
      {
        txt = "&"
        hint = "set to allow only one team to use this entity, used for CTF or"
         " other respawn type modes to create spawn rooms. Values: blue or red"
         " - Default: anyone"
      }
      notfree: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "When set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
    }
    info_ut_spawn:form =
    {
      help = "potential spawning position for Urban Terror."$0D"-------- KEYS "
       "--------"$0D"team : team that this spawn belongs to ("$22"red"$22" or "
       $22"blue"$22")"$0D"group : this spawn groups with others of same groupI"
       "D. A team chooses spawns from a certain group."$0D"g_gametype : a list"
       " of gametypes on which to use this spawn eg: "$22"3, 5, 6"$220D"------"
       "-- NOTES --------"$0D"Urban Terror gametype mappings are:"$0D"Free For"
       " All 0"$0D"Last Man Standing 1 (use FFA 0 for entities)"$0D"Team Death"
       "match 3"$0D"Team Survivor 4"$0D"Assasins 5"$0D"Capture And Hold 6"$0D"C"
       "apture The Flag 7"$0D"Bomb 8"$0D"Jump Mode 9"$0D"You would use the gro"
       "ups key in maps if you wanted to make sure a team will spawn together "
       "in a certain location, so you might take 8 spawn points, give them all"
       " gametypes of "$22"3, 5, 6, 7, 8"$22" (all teamplays except gametype 4"
       " TS, gametype 4 should be in separate groups for each team) and then a"
       "ssign all eight a group id of "$22"1"$22" then you might do another ei"
       "ght and make their group id all "$22"2"$22". Then do the same for the "
       "other team e.g.: 8 spawns for both red and blue teams with group 1 and"
       " another 8 spawns for both red and blue teams with group 2. UT will ch"
       "oose a "$22"group"$22" at the begining of a round and spawn all member"
       "s of the "$22"teams"$22" there. Normally you'd have a few groups of sp"
       "awns so you could have lots of potential team starting positions. Note"
       ": The game treats TS (gametype 4) spawns differently. It chooses the s"
       "pawns based on furthest distance from each other rather than in paired"
       " groups. So if you wanted two spawn areas for each team you would do t"
       "eam blue group 1, team red group 2, team blue group 3, team red group "
       "4."
      bbox = '-16 -16 -24 16 16 32'
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "initial"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "angle"
      }
      team: =
      {
        txt = "&"
        hint = "team that this spawn belongs to ("$22"$22"$22"red"$22"$22"$22" "
         "or "$22"$22"$22"blue"$22"$22"$22")"
      }
      group: =
      {
        txt = "&"
        hint = "this spawn groups with others of same groupID. A team chooses "
         "spawns from a certain group."
      }
      g_gametype: =
      {
        txt = "&"
        hint = "a list of gametypes on which to use this spawn eg: "$22"$22"$22
         "3, 5, 6"$22"$22"$22
      }
    }
    team_CAH_capturepoint:form =
    {
      help = "zone that can be captured in the Capture and Hold gametype (CAH)"
       $0D"-------- NOTES --------"$0D"The capture point will be represented w"
       "ith a flag and a player must touch the flag to capture it."$0D"The nam"
       "e of the location of the capturepoint will be retrieved from either th"
       "e trigger_location or the nearest target_location."
      bbox = '-32 -32 -16 32 32 76'
    }
    info_ut_bombsite:form =
    {
      help = "-------- NOTES --------"$0D"This entity cannot hover, it must be"
       " placed directly on the surface that you wish the bomb to be placed on"
       "."$0D"NEW in 3.2: Bomb plant range is locked to 64 units. Once the bom"
       "b is planted, it will snap to the center of the entity for easier diff"
       "using."$0D"WARNING: You MUST have 2 bomb sites per map or the map will"
       " crash upon loading into bomb mode."
      bbox = '-16 -16 -24 16 16 32'
    }
    ut_mrsentry:form =
    {
      help = "Spawn location for the CTF Spawn Room Sentry Cannon."$0D"-------"
       "- KEYS --------"$0D"team : Team that Mr. Sentry belongs to. Will elimi"
       "nate opposing team members within range (SEE NOTES). ("$22"red"$22" or"
       " "$22"blue"$22")"$0D"angle : Inital and idle angle for the turret. Gen"
       "erally point this at or near the Spawn Room doors for highest effectiv"
       "eness."$0D"gametype : gametypes to have Mr. Sentry appear in, list typ"
       "es in this format: 01234"$0D"-------- NOTES --------"$0D"Mr. Sentry is"
       " designed to be used in conjunction with CTF Spawn Rooms (see the Note"
       "s on the func_door entity) to prevent enemy team players from survivin"
       "g if they enter the opposing team's spawn room. Even though the proper"
       "ly set up doors will generally prevent this, Mr. Sentry also has one o"
       "ther function. It will kill any Flag Carrier that enters it's range no"
       " matter what team that player is on. This will prevent players from gr"
       "abbing the flag and retreating the the complete safety of their Spawn "
       "Room and waiting out the rest of the map time with the flag."$0D"For t"
       "he anti-flag-camp feature to work properly, the entire spawn room must"
       " be enclosed with a 'nodrop' (a brush with the 'nodrop' texture on all"
       " sides). If this brush (or group of brushes) isn't placed, then Mr. Se"
       "ntry will kill the Flag Carrier, and the flag will remain at that loca"
       "tion, which is bad."
      bbox = '-16 -16 -24 16 16 32'
      team: =
      {
        txt = "&"
        hint = "Team that Mr. Sentry belongs to. Will eliminate opposing team "
         "members within range (SEE NOTES). ("$22"$22"$22"red"$22"$22"$22" or "
         $22"$22"$22"blue"$22"$22"$22")"
      }
      angle: =
      {
        txt = "&"
        hint = "Inital and idle angle for the turret. Generally point this at "
         "or near the Spawn Room doors for highest effectiveness."
      }
      gametype: =
      {
        txt = "&"
        hint = "gametypes to have Mr. Sentry appear in, list types in this for"
         "mat: 01234"
      }
    }
    cubemap_probe:form =
    {
      help = "Location of camera for cube map for specular mapping. Place at h"
       "ead height in the centre of an area. There are no keys."
      bbox = '-8 -8 -8 8 8 8'
    }
    trigger_gravity:form =
    {
      help = "Any player that touches this will change his gravity"$0D"-------"
       "- KEYS --------"$0D"gravity: fraction of gravity to use. (Default 1.0)"
       $0D"target : this points to the entity to activate."$0D"targetname : ac"
       "tivating trigger points to this."$0D"notfree : when set to 1, entity w"
       "ill not spawn in "$22"Free for all"$22" and "$22"Tournament"$22" modes"
       "."$0D"notteam : when set to 1, entity will not spawn in "$22"Teamplay"$22
       " and "$22"CTF"$22" modes."$0D"notsingle : when set to 1, entity will n"
       "ot spawn in Single Player mode (bot play mode)."
      bbox = '-12 -12 -12 12 12 12'
      gravity: =
      {
        txt = "&"
        hint = "fraction of gravity to use. (Default 1.0)"
      }
      target: =
      {
        txt = "&"
        hint = "this points to the entity to activate."
      }
      targetname: =
      {
        txt = "&"
        hint = "activating trigger points to this."
      }
      notfree: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"Tournament"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      notsingle: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in Single Player mode (bo"
         "t play mode)."
      }
    }
    ut_jumpstart:form =
    {
      help = "Start line for jump maps.Attach this entity to a trigger where y"
       "ou want the timer to be tripped at the beginning of the jump route."$0D
       "-------- KEYS --------"$0D"targetname : activating trigger points to t"
       "his."$0D"notfree : when set to 1, entity will not spawn in "$22"Free f"
       "or all"$22" and "$22"LMS"$22" modes."$0D"notteam : when set to 1, enti"
       "ty will not spawn in "$22"Teamplay"$22" and "$22"CTF"$22" modes."$0D"n"
       "ame : Name of the way that the gamer will see when he crosses the star"
       "t line."$0D"type : Way number for alternate routes."
      bbox = '-16 -16 -16 16 16 16'
      targetname: =
      {
        txt = "&"
        hint = "activating trigger points to this."
      }
      notfree: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"LMS"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      name: =
      {
        txt = "&"
        hint = "Name of the way that the gamer will see when he crosses the st"
         "art line."
      }
      type: =
      {
        txt = "&"
        hint = "Way number for alternate routes."
      }
    }
    ut_jumpstop:form =
    {
      help = "Stop line for jump maps. Attach this entity to a trigger where y"
       "ou want the timer to stop at the end of the jump route."$0D"-------- K"
       "EYS --------"$0D"targetname : activating trigger points to this."$0D"n"
       "otfree : when set to 1, entity will not spawn in "$22"Free for all"$22
       " and "$22"LMS"$22" modes."$0D"notteam : when set to 1, entity will not"
       " spawn in "$22"Teamplay"$22" and "$22"CTF"$22" modes."$0D"name : Name "
       "of the way that the gamer will see when he crosses the start line."$0D
       "type : Way number for alternate routes."
      bbox = '-16 -16 -16 16 16 16'
      targetname: =
      {
        txt = "&"
        hint = "activating trigger points to this."
      }
      notfree: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"LMS"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      name: =
      {
        txt = "&"
        hint = "Name of the way that the gamer will see when he crosses the st"
         "art line."
      }
      type: =
      {
        txt = "&"
        hint = "Way number for alternate routes."
      }
    }
    ut_jumpcancel:form =
    {
      help = "Timer cancelation for jump maps. Attach this entity to a trigger"
       " where you want the timer to cancel timing a particular route eg: a by"
       "-pass for beginners around a difficult jump."$0D"-------- KEYS -------"
       "-"$0D"name : Name of the way that the gamer will see when he cancels t"
       "he run."$0D"type : Way number for alternate routes. Should match the t"
       "ype number of the route you want to cancel or 0 to cancel all routes."$0D
       "targetname : activating trigger points to this."$0D"notfree : when set"
       " to 1, entity will not spawn in "$22"Free for all"$22" and "$22"LMS"$22
       " modes."$0D"notteam : when set to 1, entity will not spawn in "$22"Tea"
       "mplay"$22" and "$22"CTF"$22" modes."$0D"color: If not used, it will de"
       "fault to white."$0D"Valid color numbers are:"$0D"0 Black"$0D"1 Red"$0D
       "2 Green"$0D"3 Yellow"$0D"4 Blue"$0D"5 Cyan"$0D"6 Magenta"$0D"7 White"
      bbox = '-16 -16 -16 16 16 16'
      name: =
      {
        txt = "&"
        hint = "Name of the way that the gamer will see when he cancels the ru"
         "n."
      }
      type: =
      {
        txt = "&"
        hint = "Way number for alternate routes. Should match the type number "
         "of the route you want to cancel or 0 to cancel all routes."
      }
      targetname: =
      {
        txt = "&"
        hint = "activating trigger points to this."
      }
      notfree: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Free for "
         "all"$22"$22"$22" and "$22"$22"$22"LMS"$22"$22"$22" modes."
      }
      notteam: =
      {
        txt = "&"
        hint = "when set to 1, entity will not spawn in "$22"$22"$22"Teamplay"$22
         "$22"$22" and "$22"$22"$22"CTF"$22"$22"$22" modes."
      }
      color: =
      {
        txt = "&"
        hint = "If not used, it will default to white."
      }
      Valid color numbers are: =
      {
        txt = "&"
        hint = $0D0A"0 Black"$0D0A"1 Red"$0D0A"2 Green"$0D0A"3 Yellow"$0D0A"4 "
         "Blue"$0D0A"5 Cyan"$0D0A"6 Magenta"$0D0A"7 White"
      }
    }
    worldspawn:form =
    {
      help = "Only used for the world."$0D"-------- KEYS --------"$0D"message "
       ": Text to print at user logon. Used for name of level."$0D"music : Pat"
       "h/name of looping .wav file used for level's music (e.g. music/sonic5."
       "wav)."$0D"_ambient OR ambient : Adds a constant value to overall light"
       "ing. Use is not recommended. Ambient light will have a tendency to fla"
       "tten out variations in light and shade."$0D"_color : RGB value for amb"
       "ient light color (default 0 0 0)."$0D"gravity : Gravity of level (defa"
       "ult 800 = normal gravity)."$0D"enablePrecip : 0 - (default) none, 1 - "
       "rain, 2 - snow"$0D"precipAmount : up to 1024, number of drops/flakes ("
       "256 is good)"$0D"gridsize : Granularity of the lightgrid created by q3"
       "map. Value is three integers separated by spaces, representing number "
       "of units between grid points in X Y Z. Default gridsize value is 128 1"
       "28 256. Use larger powers of 2 to reduce BSP size and compile time on "
       "very large maps."$0D"_blocksize : Q3Map always splits the BSP tree alo"
       "ng the planes X=_blocksize*n and Y=_blocksize*n. Increase the blocksiz"
       "e using larger powers of 2 to reduce compile times on very large maps "
       "with a low structural brush density (default 1024 1024 0, 0 values = d"
       "isable)."$0D"-------- Q3MAP2 KEYS --------"$0D"_floodlight : RGB dista"
       "nce intensity eg; .8 .8 .8 512 32. Adds radiosity lighting."$0D"lightd"
       "ensity : New key that allows the mapper to brighten the textures more "
       "than is possible normally. You can test this in game by starting a dev"
       "map and using /r_lightdensity 1.3 (or whatever value you like)."$0D"_c"
       "olor : RGB value for ambient light color."$0D"globalfog : RGB density "
       "eg: .25 .25 0 0.00001 Adds a soft global haze. Not to be used for conv"
       "ential fog. This can be tested in game by starting a devmap and using "
       "r_fogdensity "$22"0.0001"$22" r_fog_r "$22".25"$22" r_fog_g "$22".25"$22
       " r_fog_b "$22".25"$22"."$0D"_minlight : Minimum light value, levelwide"
       ". Uses the _color key to set color. Does not add, unlike ambient."$0D"_"
       "minvertexlight : Minimum vertex lighting, levelwide."$0D"_mingridlight"
       " : Minimum lightgrid (dynamic entity lighting) levelwide."$0D"_keeplig"
       "hts : Keep light entities in the BSP. Normally stripped out by the BSP"
       " process and read from the .map file by the lighting phase."$0D"_nosha"
       "dersun : Ignore q3map_sun/sun directives in sky shaders and ONLY use e"
       "ntity sun lights."$0D"_farplanedist : Limit on how many units the vis "
       "phase of compilation can see. Used in combination with level-wide fog,"
       " it can help reduce r_speeds on large, open maps."$0D"_foghull : Shade"
       "r to use for "$22"fog hull"$22". Foghull shader should be a sky shader"
       ". Omit the "$22"textures/"$22" prefix."$0D"_lightmapscale : Floating p"
       "oint value scales the resolution of lightmaps on brushes/patches in th"
       "e world. Can be overridden in func_group (or other entities) (default "
       "1.0)."$0D"_cs OR _castshadows : Allows per-entity control over shadow "
       "casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting."
       " 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (o"
       "r _receiveshadows) with the corresponding value, AND world. Negative v"
       "alues imply same, but DO NOT cast shadows on world."$0D"_rs OR _receiv"
       "eshadows : Allows per-entity control over shadow reception. Defaults t"
       "o 1 on everything (world shadows). 0 = receives NO shadows. > 1 = rece"
       "ive shadows only from corresponding keyed entities (see above) and wor"
       "ld. < 1 = receive shadows ONLY from corresponding keyed entities."$0D"_"
       "celshader : Sets the cel shader used for this geometry. Note: Omit the"
       " "$22"textures/"$22" prefix. Overridable in entities."$0D"_styleNalpha"
       "Gen : *IMPORTANT* Replace "$22"N"$22" in the key "$22"_styleNalphaGen"$22
       " with an integer between 1 and 31 as your style index. Values takes st"
       "andard shader waveform functions (e.g. wave sin 0.5 0.3 0.25 1.5)"$0D"_"
       "styleNrgbGen : *IMPORTANT* Replace "$22"N"$22" in the key "$22"_styleN"
       "rgbGen"$22" with an integer between 1 and 31 as your style index. Valu"
       "es take standard shader waveform functions (e.g. wave sin 0.5 0.3 0.25"
       " 1.5)"$0D"-------- Q3MAP2 TERRAIN KEYS --------"$0D"_indexmap OR alpha"
       "map : Path/name for the art file used to guide the mapping of textures"
       " on the terrain surface."$0D"_layers OR layers : Integer value denotes"
       " number of unique root shaders that will be used on the terrain."$0D"_"
       "shader OR shader : Path to the metashader used to assign textures to t"
       "he terrain entity. Note: Omit the "$22"textures/"$22" prefix."
      message: =
      {
        txt = "&"
        hint = "Text to print at user logon. Used for name of level."
      }
      music: =
      {
        txt = "&"
        hint = "Path/name of looping .wav file used for level's music (e.g. mu"
         "sic/sonic5.wav)."
      }
      _ambient OR ambient: =
      {
        txt = "&"
        hint = "Adds a constant value to overall lighting. Use is not recommen"
         "ded. Ambient light will have a tendency to flatten out variations in"
         " light and shade."
      }
      _color: =
      {
        txt = "&"
        hint = "RGB value for ambient light color (default 0 0 0)."
      }
      gravity: =
      {
        txt = "&"
        hint = "Gravity of level (default 800 = normal gravity)."
      }
      enablePrecip: =
      {
        txt = "&"
        hint = "0 - (default) none, 1 - rain, 2 - snow"
      }
      precipAmount: =
      {
        txt = "&"
        hint = "up to 1024, number of drops/flakes (256 is good)"
      }
      gridsize: =
      {
        txt = "&"
        hint = "Granularity of the lightgrid created by q3map. Value is three "
         "integers separated by spaces, representing number of units between g"
         "rid points in X Y Z. Default gridsize value is 128 128 256. Use larg"
         "er powers of 2 to reduce BSP size and compile time on very large map"
         "s."
      }
      _blocksize: =
      {
        txt = "&"
        hint = "Q3Map always splits the BSP tree along the planes X=_blocksize"
         "*n and Y=_blocksize*n. Increase the blocksize using larger powers of"
         " 2 to reduce compile times on very large maps with a low structural "
         "brush density (default 1024 1024 0, 0 values = disable)."
      }
      sep: =
      {
        txt = "-------- Q3MAP2 KEYS --------"
        typ = "S"
      }
      _floodlight: =
      {
        txt = "&"
        hint = "RGB distance intensity eg; .8 .8 .8 512 32. Adds radiosity lig"
         "hting."
      }
      lightdensity: =
      {
        txt = "&"
        hint = "New key that allows the mapper to brighten the textures more t"
         "han is possible normally. You can test this in game by starting a de"
         "vmap and using /r_lightdensity 1.3 (or whatever value you like)."
      }
      _color: =
      {
        txt = "&"
        hint = "RGB value for ambient light color."
      }
      globalfog: =
      {
        txt = "&"
        hint = "RGB density eg: .25 .25 0 0.00001 Adds a soft global haze. Not"
         " to be used for convential fog. This can be tested in game by starti"
         "ng a devmap and using r_fogdensity "$22"$22"$22"0.0001"$22"$22"$22" "
         "r_fog_r "$22"$22"$22".25"$22"$22"$22" r_fog_g "$22"$22"$22".25"$22"$"
         "22"$22" r_fog_b "$22"$22"$22".25"$22"$22"$22"."
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light value, levelwide. Uses the _color key to set col"
         "or. Does not add, unlike ambient."
      }
      _minvertexlight: =
      {
        txt = "&"
        hint = "Minimum vertex lighting, levelwide."
      }
      _mingridlight: =
      {
        txt = "&"
        hint = "Minimum lightgrid (dynamic entity lighting) levelwide."
      }
      _keeplights: =
      {
        txt = "&"
        hint = "Keep light entities in the BSP. Normally stripped out by the B"
         "SP process and read from the .map file by the lighting phase."
      }
      _noshadersun: =
      {
        txt = "&"
        hint = "Ignore q3map_sun/sun directives in sky shaders and ONLY use en"
         "tity sun lights."
      }
      _farplanedist: =
      {
        txt = "&"
        hint = "Limit on how many units the vis phase of compilation can see. "
         "Used in combination with level-wide fog, it can help reduce r_speeds"
         " on large, open maps."
      }
      _foghull: =
      {
        txt = "&"
        hint = "Shader to use for "$22"$22"$22"fog hull"$22"$22"$22". Foghull "
         "shader should be a sky shader. Omit the "$22"$22"$22"textures/"$22"$"
         "22"$22" prefix."
      }
      _lightmapscale: =
      {
        txt = "&"
        hint = "Floating point value scales the resolution of lightmaps on bru"
         "shes/patches in the world. Can be overridden in func_group (or other"
         " entities) (default 1.0)."
      }
      _cs OR _castshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow casting. Defaults to 0 o"
         "n entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on w"
         "orld. > 1 = cast shadows on entities with _rs (or _receiveshadows) w"
         "ith the corresponding value, AND world. Negative values imply same, "
         "but DO NOT cast shadows on world."
      }
      _rs OR _receiveshadows: =
      {
        txt = "&"
        hint = "Allows per-entity control over shadow reception. Defaults to 1"
         " on everything (world shadows). 0 = receives NO shadows. > 1 = recei"
         "ve shadows only from corresponding keyed entities (see above) and wo"
         "rld. < 1 = receive shadows ONLY from corresponding keyed entities."
      }
      _celshader: =
      {
        txt = "&"
        hint = "Sets the cel shader used for this geometry. Note: Omit the "$22
         "$22"$22"textures/"$22"$22"$22" prefix. Overridable in entities."
      }
      _styleNalphaGen: =
      {
        txt = "&"
        hint = "*IMPORTANT* Replace "$22"$22"$22"N"$22"$22"$22" in the key "$22
         "$22"$22"_styleNalphaGen"$22"$22"$22" with an integer between 1 and 3"
         "1 as your style index. Values takes standard shader waveform functio"
         "ns (e.g. wave sin 0.5 0.3 0.25 1.5)"
      }
      _styleNrgbGen: =
      {
        txt = "&"
        hint = "*IMPORTANT* Replace "$22"$22"$22"N"$22"$22"$22" in the key "$22
         "$22"$22"_styleNrgbGen"$22"$22"$22" with an integer between 1 and 31 "
         "as your style index. Values take standard shader waveform functions "
         "(e.g. wave sin 0.5 0.3 0.25 1.5)"
      }
      sep: =
      {
        txt = "-------- Q3MAP2 TERRAIN KEYS --------"
        typ = "S"
      }
      _indexmap OR alphamap: =
      {
        txt = "&"
        hint = "Path/name for the art file used to guide the mapping of textur"
         "es on the terrain surface."
      }
      _layers OR layers: =
      {
        txt = "&"
        hint = "Integer value denotes number of unique root shaders that will "
         "be used on the terrain."
      }
      _shader OR shader: =
      {
        txt = "&"
        hint = "Path to the metashader used to assign textures to the terrain "
         "entity. Note: Omit the "$22"$22"$22"textures/"$22"$22"$22" prefix."
      }
    }
  }
}
