QQRKSRC1
//
//$Header$
// ----------- REVISION HISTORY ------------
//$Log$
//Revision 1.4  2005/01/11 02:28:14  alexander
//improved model selection form
//
//Revision 1.3  2005/01/02 16:31:22  alexander
//specifics for broken glass added
//
//Revision 1.2  2004/12/19 10:39:01  alexander
//first useable versions, added rcs headers
//
//
{
  QuArKProtected = "1"
  Description = "HL2 DM Entities"
  t_player_size:incl = { bbox = '-16 -16 -24 16 16 32' }
  Toolbox Folders.qtx =
  {
    Toolbox = "New map items..."
    Root = "Entities for HL2 Deathmatch.qtxfolder"
    Entities for HL2 Deathmatch.qtxfolder =
    {
      ;desc = "converted 2004-12-18"
      info_* entities.qtxfolder =
      {
        info_npc_spawn_destination:e =
        {
          origin = "0 0 0"
          ;desc = "NPC Spawn Destination. (Consult npc_template_maker help for"
           " more info)"
          ReuseDelay = "1"
        }
        info_ladder_dismount:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to handle endpoints for multiple ladders that are"
           " too close to each other."
        }
        info_projecteddecal:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that projects a decal onto the world (or props). "
           "If the decal has no target name, it will immediately apply itself "
           "when the level is loaded. If it has a name specified, it won't app"
           "ly until it receives the 'Activate' input."
          Distance = "64"
        }
        info_no_dynamic_shadow:e =
        {
          origin = "0 0 0"
          ;desc = "Use this entity to mark surfaces that shouldn't receive dyn"
           "amic shadows."
        }
        info_player_start:e =
        {
          origin = "0 0 0"
          ;desc = "This entity indicates the position and facing direction at "
           "which the player will spawn. Any number of info_player_start entit"
           "ies may be placed in a map for when working in cordoned-off portio"
           "ns of the map. When multiple info_player_start entities are presen"
           "t in a map, set the 'Master' spawnflag on one of them to indicate "
           "which one should be used when running the entire map."
        }
        info_overlay:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that places an overlay on the world."
          RenderOrder = "0"
          StartU = "0.0"
          EndU = "1.0"
          StartV = "0.0"
          EndV = "1.0"
        }
        info_intermission:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that defines an intermission spot where dead play"
           "ers will float until they respawn."
        }
        info_landmark:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts as a landmark for transitions to anothe"
           "r level. There should be a corresponding info_landmark entity in t"
           "he next map. Entities will be transitioned to the next level relat"
           "ive to the info_landmark entities."
        }
        info_null:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that's immediately removed on spawning. Useful as"
           " a spotlight target."
        }
        info_target:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does nothing. Very useful as a positioning e"
           "ntity for other entities to refer to (i.e. the endpoint of an env_"
           "beam)"
        }
        info_lighting:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to change the lighting origin of"
           " a prop_static. Set the prop_static's Lighting Origin to point at "
           "this entity to make the prop_static light as if it was at the info"
           "_lighting's origin. Good for prop_static entities that are embedde"
           "d in world geometry (like rocks/windows/etc)."
        }
        info_teleport_destination:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does nothing itself, but is used to specify "
           "the destination for a trigger_teleport entity."
        }
        info_node:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for ground moving NPCs. Navigation nodes "
           "are baked into the nodegraph so that NPCs can move to them. Ground"
           " nodes fall to the ground when they spawn."
        }
        info_node_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for ground moving NPCs that includes some"
           " context information for NPCs that are interested in it. The hint "
           "might indicate a window that could be looked out of, or an item of"
           " interest that could be commented on. Many hint nodes are NPC-spec"
           "ific, so it's helpful to use naming conventions like 'Crow: Fly to"
           " point' in the hint choices list. The angles of a hint node indica"
           "te what direction the NPC should face to perform the hint behavior"
           ".\n\nIt's important to understand the distinction between scripts,"
           " such as scripted_sequence and scripted_schedule, and info_hint en"
           "tities. Scripts summon NPCs to specific cue points to play their p"
           "arts, while hints provide context information to the AI that they "
           "use to perform their behaviors. Hints require code support in the "
           "NPC, while scripts are generic and may require only animations to "
           "play. Use a hint if the behavior is driven by the AI, use a script"
           " if the behavior is driven by the map."
        }
        info_node_air:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for flying NPCs. Air navigation nodes are"
           " baked into the nodegraph so that NPCs can move to them. Air nodes"
           " do not fall to the ground when they spawn."
          nodeheight = "0"
        }
        info_node_air_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for flying NPCs that includes some contex"
           "t information for NPCs that are interested in it. The hint might i"
           "ndicate a window that could be looked into, or an item of interest"
           " that could be commented on. Many hint nodes are NPC-specific, so "
           "it's helpful to use naming conventions like 'Crow: Fly to point' i"
           "n the hint choices list. The angles of a hint node indicate what d"
           "irection the NPC should face to perform the hint behavior."
          nodeheight = "0"
        }
        info_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A hint that is not used for navigation. They don't go into "
           "the nodegraph, nor do they fall to the ground. Use these to provid"
           "e some spatial context for NPCs, such as 'look here if you can't f"
           "ind the player' or 'throw rocks at this spot'."
        }
        info_node_link:e =
        {
          origin = "0 0 0"
          ;desc = "A dynamic connection between two navigation nodes. You spec"
           "ify the node IDs of the start and end nodes, and then you can use "
           "entity I/O to turn on and off the connection. This could be used t"
           "o create or destroy a connection in the nodegraph because of some "
           "event in your map (a bridge being created/destroyed, etc)."
          initialstate = "1"
        }
        info_node_link_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls all connections between nodes that "
           "intersect the controller's volume. This allows for mass enabling/d"
           "isabling of all node connections through a volume."
          mins = "-8 -32 -36"
          maxs = "8 32 36"
          initialstate = "1"
        }
        info_node_climb:e =
        {
          origin = "0 0 0"
          ;desc = "A climb-node for AI navigation. Only usable by NPCs that ca"
           "n climb."
        }
        info_constraint_anchor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to attach constraints to a local position on"
           " an entity. Usually constraints will attach to the center of mass "
           "of an object. Attach the desired constraint to this entity, and th"
           "en parent this entity to the entity you want the constraint to app"
           "ly to."
          massScale = "1"
        }
        info_mass_center:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that overrides the mass center of the target phys"
           "ics prop, or func_physbox, by moving it to the info_mass_center's "
           "location."
        }
        info_camera_link:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can use point_cameras to render images for m"
           "aterials used by entities. To author the material, use the special"
           " identifier _rt_Camera for the $baseTexture (or whatever texture y"
           "ou want, like envmap, etc.) in the .vmt then connect the 'target' "
           "field to the entity which uses that material, and the 'PointCamera"
           "' field to the point_camera you want to have appear on that entity"
           "'s material"
        }
        info_snipertarget:e =
        {
          origin = "0 0 0"
          ;desc = "Sniper Target"
          speed = "2"
        }
        info_target_gunshipcrash:e =
        {
          origin = "0 0 0"
          ;desc = "Gunship Crash Target"
        }
        info_apc_missile_hint:b =
        {
          ;incl = "defpoly"
          ;desc = "Something that helps APC missiles guide. If the missile can"
           " hit the associated target entitybetween the time it takes the cur"
           "rent enemy to enter + leave the hint, then the missile will guide "
           "to the entity."
        }
        info_teleporter_countdown:e =
        {
          origin = "0 0 0"
          ;desc = "Countdown timer for the teleporter. The status of the telep"
           "orter will appear on vgui_screen entities whose panel is 'teleport"
           "_countdown_screen'."
        }
        info_player_deathmatch:e =
        {
          origin = "0 0 0"
          ;desc = "This entity indicates the position and facing direction at "
           "which the player will spawn during a deathmatch map. Any number of"
           " info_player_deathmatch entities may be placed in a map."
        }
      }
      npc_* entities.qtxfolder =
      {
        npc_template_maker:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates NPCs. The NPCs it creates are clones"
           " of a template NPC. NPCs are spawned around this maker's origin, o"
           "r at specified destination points."
          Radius = "256"
          CriterionVisibility = "2"
          CriterionDistance = "2"
        }
        npc_furniture:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used for non-NPCs that need to synchronise their "
           "animation with an NPC in a scripted_sequence. Usually a pieceof fu"
           "rniture or door that an NPC needs to manipulate within a scripted_"
           "sequence."
        }
        npc_combine_camera:e =
        {
          origin = "0 0 0"
          ;desc = "Combine security camera"
          spawnflags = "32"
          innerradius = "300"
          outerradius = "450"
          minhealthdmg = "0"
        }
        npc_turret_ground:e =
        {
          origin = "0 0 0"
          ;desc = "Combine ground turret"
        }
        npc_turret_ceiling:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Ceiling Turret"
          spawnflags = "32"
          minhealthdmg = "0"
        }
        npc_turret_floor:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Floor Turret"
        }
        npc_vehicledriver:e =
        {
          origin = "0 0 0"
          ;desc = "NPC used to drive a target vehicle."
          drivermaxspeed = "1"
          driverminspeed = "0"
        }
        npc_cranedriver:e =
        {
          origin = "0 0 0"
          ;desc = "NPC used to drive cranes."
          releasepause = "0"
        }
        npc_apcdriver:e =
        {
          origin = "0 0 0"
          ;desc = "NPC used to drive an APC vehicle."
          drivermaxspeed = "1"
          driverminspeed = "0"
        }
        npc_apc:e =
        {
          origin = "0 0 0"
          ;desc = "The APC."
        }
        npc_roller:e =
        {
          origin = "0 0 0"
          ;desc = "Roller"
        }
        npc_rollerturret:e =
        {
          origin = "0 0 0"
          ;desc = "Roller Turret"
        }
        npc_rollerdozer:e =
        {
          origin = "0 0 0"
          ;desc = "Roller Dozer"
        }
        npc_rollerbuddy:e =
        {
          origin = "0 0 0"
          ;desc = "Roller Buddy"
        }
        npc_rollerbull:e =
        {
          origin = "0 0 0"
          ;desc = "Roller Bull"
        }
        npc_rollermine:e =
        {
          origin = "0 0 0"
          ;desc = "Roller Mine"
          startburied = "No"
        }
        npc_missiledefense:e =
        {
          origin = "0 0 0"
          ;desc = "Missile Defense"
        }
        npc_sniper:e =
        {
          origin = "0 0 0"
          ;desc = "Sniper"
          radius = "0"
          misses = "0"
          beambrightness = "100"
          shielddistance = "64"
          shieldradius = "48"
        }
        npc_antlion:e =
        {
          origin = "0 0 0"
          ;desc = "Antlions will run away from ai_sound, type: Thumper."
          startburrowed = "No"
          radius = "256"
          eludedist = "1024"
          ignorebugbait = "No"
        }
        npc_antlionguard:e =
        {
          origin = "0 0 0"
          ;desc = "Antlion Guard"
          startburrowed = "No"
          allowbark = "No"
        }
        npc_crow:e =
        {
          origin = "0 0 0"
          ;desc = "Crow"
        }
        npc_seagull:e =
        {
          origin = "0 0 0"
          ;desc = "Seagull"
        }
        npc_pigeon:e =
        {
          origin = "0 0 0"
          ;desc = "Pigeon"
        }
        npc_ichthyosaur:e =
        {
          origin = "0 0 0"
          ;desc = "Ichthyosaur"
        }
        npc_assassin:e =
        {
          origin = "0 0 0"
          ;desc = "Assassin"
        }
        npc_headcrab:e =
        {
          origin = "0 0 0"
          ;desc = "Headcrab"
        }
        npc_headcrab_fast:e =
        {
          origin = "0 0 0"
          ;desc = "Fast Headcrab"
        }
        npc_headcrab_black:e =
        {
          origin = "0 0 0"
          ;desc = "Black Headcrab"
        }
        npc_stalker:e =
        {
          origin = "0 0 0"
          ;desc = "Stalker"
          BeamPower = "Low"
        }
        npc_bullseye:e =
        {
          origin = "0 0 0"
          ;desc = "Bullseye"
          health = "35"
        }
        npc_enemyfinder:e =
        {
          origin = "0 0 0"
          ;desc = "EnemyFinder"
          spawnflags = "65536"
          FieldOfView = "0.2"
          MinSearchDist = "0"
          MaxSearchDist = "2048"
          freepass_timetotrigger = "0"
          freepass_duration = "0"
          freepass_movetolerance = "120"
          freepass_refillrate = "0.5"
          freepass_peektime = "0"
          StartOn = "1"
        }
        npc_citizen:e =
        {
          origin = "0 0 0"
          ;desc = "Citizen"
          spawnflags = "262144"
          additionalequipment = "0"
          ammosupply = "SMG1"
          ammoamount = "1"
          citizentype = "Default"
          expressiontype = "Random"
          model = "models/humans/group01/male_01.mdl"
          notifynavfailblocked = "0"
        }
        npc_fisherman:e =
        {
          origin = "0 0 0"
          ;desc = "Fisherman"
        }
        npc_barney:e =
        {
          origin = "0 0 0"
          ;desc = "Barney"
          additionalequipment = "weapon_pistol"
        }
        npc_combine_s:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Soldier"
          model = "models/combine_soldier.mdl"
        }
        npc_launcher:e =
        {
          origin = "0 0 0"
          ;desc = "Launcher"
          spawnflags = "65536"
          StartOn = "0"
          MissileModel = "models/Weapons/wscanner_grenade.mdl"
          LaunchSound = "npc/waste_scanner/grenade_fire.wav"
          FlySound = "ambient/objects/machine2.wav"
          SmokeTrail = "1"
          LaunchSmoke = "1"
          LaunchDelay = "8"
          LaunchSpeed = "200"
          HomingSpeed = "0"
          HomingStrength = "10"
          HomingDelay = "0"
          HomingRampUp = "0.5"
          HomingDuration = "5"
          HomingRampDown = "1.0"
          Gravity = "1.0"
          MinRange = "100"
          MaxRange = "2048"
          SpinMagnitude = "0"
          SpinSpeed = "0"
          Damage = "50"
          DamageRadius = "200"
        }
        npc_vortigaunt:e =
        {
          origin = "0 0 0"
          ;desc = "Vortigaunt"
          model = "models/vortigaunt.mdl"
          ArmorRechargeEnabled = "1"
        }
        npc_particlestorm:e =
        {
          origin = "0 0 0"
          ;desc = "Particle Storm"
        }
        npc_wscanner:e =
        {
          origin = "0 0 0"
          ;desc = "Wasteland Scanner"
        }
        npc_sscanner:e =
        {
          origin = "0 0 0"
          ;desc = "Shield Scanner"
        }
        npc_spotlight:e =
        {
          origin = "0 0 0"
          ;desc = "Spotlight"
          spawnflags = "196608"
          health = "100"
          YawRange = "90"
          PitchMin = "35"
          PitchMax = "50"
          IdleSpeed = "2"
          AlertSpeed = "5"
          spotlightlength = "500"
          spotlightwidth = "50"
          rendercolor = "255 255 255"
        }
        npc_strider:e =
        {
          origin = "0 0 0"
          ;desc = "Strider"
          disablephysics = "0"
        }
        npc_barnacle:e =
        {
          origin = "0 0 0"
          ;desc = "Barnacle"
          RestDist = "16"
        }
        npc_combinegunship:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Gunship"
        }
        npc_combinedropship:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Dropship"
          GunRange = "2048"
          Invulnerable = "0"
          CrateType = "2"
        }
        npc_helicopter:e =
        {
          origin = "0 0 0"
          ;desc = "Helicopter"
          InitialSpeed = "0"
          GracePeriod = "2.0"
          PatrolSpeed = "0"
        }
        npc_heli_avoidsphere:e =
        {
          origin = "0 0 0"
          ;desc = "Helicopter avoidance sphere"
          radius = "128"
        }
        npc_heli_avoidbox:b =
        {
          ;incl = "defpoly"
          ;desc = "Helicopter avoidance box"
        }
        npc_heli_nobomb:b =
        {
          ;incl = "defpoly"
          ;desc = "Helicopter bombing suppressor"
        }
        npc_fastzombie:e =
        {
          origin = "0 0 0"
          ;desc = "Fast Zombie"
        }
        npc_zombie:e =
        {
          origin = "0 0 0"
          ;desc = "Zombie"
        }
        npc_zombie_torso:e =
        {
          origin = "0 0 0"
          ;desc = "Zombie Torso"
        }
        npc_poisonzombie:e =
        {
          origin = "0 0 0"
          ;desc = "A bloated, disgusting, fluid-spurting zombie created by a p"
           "oison headcrab."
          crabcount = "3"
        }
        npc_cscanner:e =
        {
          origin = "0 0 0"
          ;desc = "City Scanner"
          spotlightlength = "500"
          spotlightwidth = "50"
          spotlightdisabled = "0"
          ShouldInspect = "1"
          OnlyInspectPlayers = "0"
          NeverInspectPlayers = "0"
        }
        npc_manhack:e =
        {
          origin = "0 0 0"
          ;desc = "Manhack"
        }
        npc_mortarsynth:e =
        {
          origin = "0 0 0"
          ;desc = "Mortar Synth"
        }
        npc_metropolice:e =
        {
          origin = "0 0 0"
          ;desc = "MetroPolice"
          additionalequipment = "weapon_pistol"
          manhacks = "0"
          weapondrawn = "0"
        }
        npc_crabsynth:e =
        {
          origin = "0 0 0"
          ;desc = "Crab Synth"
        }
        npc_odell:e =
        {
          origin = "0 0 0"
          ;desc = "ODell"
        }
        npc_monk:e =
        {
          origin = "0 0 0"
          ;desc = "Monk"
          additionalequipment = "weapon_annabelle"
          HasGun = "1"
        }
        npc_alyx:e =
        {
          origin = "0 0 0"
          ;desc = "Alyx"
          model = "models/alyx.mdl"
          additionalequipment = "weapon_alyxgun"
        }
        npc_kleiner:e =
        {
          origin = "0 0 0"
          ;desc = "Kleiner"
        }
        npc_eli:e =
        {
          origin = "0 0 0"
          ;desc = "Eli Vance"
          model = "models/eli.mdl"
        }
        npc_breen:e =
        {
          origin = "0 0 0"
          ;desc = "Dr Breen"
          model = "models/breen.mdl"
        }
        npc_mossman:e =
        {
          origin = "0 0 0"
          ;desc = "Dr Mossman"
        }
        npc_gman:e =
        {
          origin = "0 0 0"
          ;desc = "The G-Man"
        }
        npc_dog:e =
        {
          origin = "0 0 0"
          ;desc = "d0g"
        }
        npc_maker:e =
        {
          origin = "0 0 0"
          ;desc = "NPC Maker"
          additionalequipment = "0"
        }
        npc_antlion_template_maker:e =
        {
          origin = "0 0 0"
          ;desc = "Antlion Template Maker"
          spawnradius = "512"
          vehicledistance = "1"
          ignorebugbait = "0"
          pool_start = "0"
          pool_max = "0"
          pool_regen_amount = "0"
          pool_regen_time = "0"
        }
      }
      other entities.qtxfolder =
      {
        worldspawn:b =
        {
          ;desc = "This is the world entity. Each map can only contain one, an"
           "d it's automatically created for you."
        }
        cycler:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to display a model for testing purposes. Sho"
           "oting it with cycle through the model's animations."
          skin = "0"
          sequence = "0"
        }
        gibshooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that shoots out gibs. Style of body part depends "
           "on language type."
        }
        infodecal:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that places a decal on the world. If the decal ha"
           "s no target name, it will immediately apply itself when the level "
           "is loaded. If it has a name specified, it won't apply until it rec"
           "eives the 'Activate' input."
          LowPriority = "0"
        }
        light:e =
        {
          origin = "0 0 0"
          ;desc = "An invisible lightsource."
          _distance = "0"
        }
      }
      ambient_* entities.qtxfolder =
      {
        ambient_generic:e =
        {
          origin = "0 0 0"
          ;desc = "Universal ambient sound. Use it to play and control a singl"
           "e sound."
          health = "10"
          preset = "0"
          volstart = "0"
          fadein = "0"
          fadeout = "0"
          pitch = "100"
          pitchstart = "100"
          spinup = "0"
          spindown = "0"
          lfotype = "0"
          lforate = "0"
          lfomodpitch = "0"
          lfomodvol = "0"
          cspinup = "0"
          radius = "1250"
          spawnflags = "48"
        }
      }
      func_* entities.qtxfolder =
      {
        func_lod:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush-built model that fades out over a specified distance."
           " Useful for creating world detail that doesn't need to be drawn fa"
           "r away, for performance reasons."
          DisappearDist = "2000"
          Solid = "0"
        }
        func_ladder:b =
        {
          ;incl = "defpoly"
          ;desc = "Ladder"
        }
        func_useableladder:e =
        {
          origin = "0 0 0"
          ;desc = "A Half-Life 2 ladder. Handles player auto mount/unmount. Se"
           "e also 'func_ladderendpoint', used to specify the two endpoints of"
           " a ladder, and 'info_ladder_dismount', used to specify ladder auto"
           "-dismount points."
          StartDisabled = "0"
        }
        func_ladderendpoint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to specify the endpoints of a ladder. To be "
           "valid, a full sized player hull traced between the start and end p"
           "oints must not be obstructed at level activation time. The angle d"
           "etermines in which direction the player leaves the ladder if the p"
           "layer presses the +jump button."
        }
        func_areaportalwindow:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that can be used to optimize the visibility in a "
           "map. If you seal off an area with them, then when the viewer moves"
           " a certain distance away from them, they will go opaque and the pa"
           "rts inside the area will not be drawn. The 'target' bmodel should "
           "enclose the func_areaportal window so no parts of it are culled by"
           " the window. If you use the optional foreground bmodel, then it sh"
           "ould enclose the 'target' bmodel."
          FadeStartDist = "128"
          FadeDist = "512"
          TranslucencyLimit = "0.2"
        }
        func_wall:b =
        {
          ;incl = "defpoly"
          ;desc = "Legacy support. Use func_brush instead."
        }
        func_clip_vphysics:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that's considered solid to vphysics."
        }
        func_brush:b =
        {
          ;incl = "defpoly"
          ;desc = "An brush built entity with various features."
          Solidity = "0"
          solidbsp = "0"
        }
        func_movelinear:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that moves linearly along a given distance, "
           "in a given direction."
          movedir = "0 0 0"
          startposition = "0"
          speed = "100"
          movedistance = "100"
          blockdamage = "0"
        }
        func_water_analog:b =
        {
          ;incl = "defpoly"
          ;desc = "A water brush entity that moves linearly along a given dist"
           "ance, in a given direction"
          movedir = "0 0 0"
          startposition = "0"
          speed = "100"
          movedistance = "100"
          WaveHeight = "3.0"
        }
        func_rotating:b =
        {
          ;incl = "defpoly"
          ;desc = "A rotating brush entity."
          maxspeed = "100"
          fanfriction = "20"
          volume = "10"
          spawnflags = "512"
          dmg = "0"
          solidbsp = "0"
        }
        func_platrot:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that moves vertically, and can rotate while "
           "doing so."
          spawnflags = "1"
          speed = "50"
          height = "0"
          rotation = "0"
        }
        func_button:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that's designed to be used for a player-usea"
           "ble button. When used by the player, it moves to a pressed positio"
           "n."
          movedir = "0 0 0"
          speed = "5"
          health = "0"
          lip = "0"
          sounds = "0"
          wait = "3"
          spawnflags = "1024"
          locked_sound = "0"
          unlocked_sound = "0"
          locked_sentence = "0"
          unlocked_sentence = "0"
        }
        func_rot_button:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that's designed to be used for a rotating pl"
           "ayer-useable button. When used by the player, it rotates to a pres"
           "sed position."
          speed = "50"
          health = "0"
          sounds = "21"
          wait = "3"
          distance = "90"
        }
        func_door:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity for use as a player-useable door."
          movedir = "0 0 0"
        }
        func_door_rotating:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity for use as a rotating player-useable door."
          distance = "90"
          solidbsp = "0"
        }
        func_dustmotes:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that spawns sparkling dust motes within it's"
           " volume."
          SizeMin = "10"
          SizeMax = "20"
          Alpha = "255"
        }
        func_smokevolume:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that spawns smoke particles within it's volu"
           "me."
          Color1 = "255 255 255"
          Color2 = "255 255 255"
          material = "particle/smoke_grenade1"
          ParticleDrawWidth = "120"
          ParticleSpacingDistance = "80"
          DensityRampSpeed = "1"
          RotationSpeed = "10"
          MovementSpeed = "10"
          Density = "1"
        }
        func_dustcloud:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that spawns a translucent dust cloud within "
           "it's volume."
          Alpha = "30"
          SizeMin = "100"
          SizeMax = "200"
        }
        func_physbox:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that's physically simulated."
          spawnflags = "524288"
          Damagetype = "0"
          massScale = "0"
          damagetoenablemotion = "0"
          forcetoenablemotion = "0"
          health = "0"
          preferredcarryangles = "0 0 0"
          notsolid = "0"
        }
        func_areaportal:b =
        {
          ;incl = "defpoly"
          ;desc = "A portal brush used to manage visibility in maps. Portals d"
           "efine areas, which are spaces that are connected in the map. Both "
           "sides of a portal cannot touch the same area, for example, a dough"
           "nut shaped map would require at least two portals to divide the ma"
           "p into two areas. A linear map could be divided into two areas wit"
           "h a single area portal."
          StartOpen = "0"
        }
        func_occluder:b =
        {
          ;incl = "defpoly"
          ;desc = "A occluder brush used to manage dynamic visibility in maps."
           " Occluders are used to dynamically determine what things are behin"
           "d them, to prevent trying to draw them at all."
          StartActive = "1"
        }
        func_breakable:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that can be broken from damage, or an input."
          minhealthdmg = "0"
          physdamagescale = "1.0"
        }
        func_breakable_surf:b =
        {
          ;incl = "defpoly"
          ;desc = "A breakable surface, for partially breakable glass / tile /"
           " etc.  All faces but the desired visible one must be marked as NOD"
           "RAW and thatface must be 4 sided.  The material applied to the vis"
           "ible face must be set up to be breakable."
          health = "5"
          fragility = "100"
          surfacetype = "0"
          upperleft = "0 0 0"
          upperright = "0 0 0"
          lowerright = "0 0 0"
          lowerleft = "0 0 0"
        }
        func_conveyor:b =
        {
          ;incl = "defpoly"
          ;desc = "Conveyor Belt"
          movedir = "0 0 0"
          speed = "100"
        }
        func_detail:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that turns it's brushes into detail brushes. Deta"
           "il brushes do NOT contribute to visibility in the PVS. World geome"
           "try is not clipped to detail brushes, so if you have a small detai"
           "l clump attached to a wall, the wall won't be cut up by the detail"
           " brush.func_detail is great for high-frequency brush geometry that"
           "'s visual detail only. It's also ideal for reducing map VIS time."
        }
        func_illusionary:b =
        {
          ;incl = "defpoly"
          ;desc = "Legacy support. Use func_brush instead."
        }
        func_precipitation:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that creates rain and snow inside its volume"
           "."
          renderamt = "5"
          rendercolor = "100 100 100"
          preciptype = "0"
        }
        func_wall_toggle:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that can be toggle on/off. When off, the bru"
           "sh will be non-solid and invisible."
        }
        func_water:b =
        {
          ;incl = "defpoly"
          ;desc = "Liquid"
          movedir = "0 0 0"
          WaveHeight = "3.0"
        }
        func_guntarget:b =
        {
          ;incl = "defpoly"
          ;desc = "This is a moving target that moves along a path of path_tra"
           "cks. It can be shot and killed."
          speed = "100"
          health = "0"
        }
        func_trackautochange:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that works as a rotating/moving platform that wil"
           "l carry a train to a new track. It must be larger in X-Y planar ar"
           "ea than the train, since it must contain the train within these di"
           "mensions in order to operate when the train is near it."
        }
        func_trackchange:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that works as a rotating/moving platform that wil"
           "l carry a train to a new track. It must be larger in X-Y planar ar"
           "ea than the train, since it must contain the train within these di"
           "mensions in order to operate when the train is near it."
        }
        func_tracktrain:b =
        {
          ;incl = "defpoly"
          ;desc = "A moving platform that the player can ride. It follows a pa"
           "th of path_track entities.\nNOTE: Build your train so that the fro"
           "nt of the train is facing down the X axis. When it spawns it will "
           "automatically rotate to face the next path_track on the path."
        }
        func_tanktrain:b =
        {
          ;incl = "defpoly"
          ;desc = "A moving train that follows a path of path_track entities, "
           "shoots at the player, and can be killed.\nNOTE: Build your train s"
           "o that the front of the train is facing down the X axis. When it s"
           "pawns it will automatically rotate to face the next path_track on "
           "the path."
          health = "100"
        }
        func_traincontrols:b =
        {
          ;incl = "defpoly"
          ;desc = "When used by the player, this entity overrides the player's"
           " controls to let them drive a train."
        }
        func_combine_ball_spawner:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that bestows super armor to the player"
          spawnflags = "4096"
          ballcount = "3"
          minspeed = "300.0"
          maxspeed = "600.0"
          ballradius = "20.0"
          balltype = "Combine Energy Ball 1"
          ballrespawntime = "4.0f"
        }
        func_healthcharger:b =
        {
          ;incl = "defpoly"
          ;desc = "Wall health recharger"
        }
        func_healthcharger:b =
        {
          ;incl = "defpoly"
          ;desc = "Wall health recharger"
        }
        func_recharge:b =
        {
          ;incl = "defpoly"
          ;desc = "Battery recharger"
        }
        func_extinguishercharger:b =
        {
          ;incl = "defpoly"
          ;desc = "Wall fire extinguisher recharger"
        }
        func_vehicleclip:b =
        {
          ;incl = "defpoly"
          ;desc = "Vehicle Clip"
        }
        func_lookdoor:b =
        {
          ;incl = "defpoly"
          ;desc = "A door that moves either when looked by a targeted object o"
           "r when a target object comes near the door.  Behavior can be eithe"
           "r based on viewing direction or proximity alone, or on a combinati"
           "on of both.  If inverted the doors behavior will be the opposite."
          ProximityDistance = "0.0"
          ProximityOffset = "0.0"
          FieldOfView = "0.0"
        }
        func_tank:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush Gun Turret"
          bullet = "0"
        }
        func_tankpulselaser:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush Pulse Laser"
          PulseSpeed = "1000"
          PulseColor = "255 0 0"
          PulseWidth = "20"
          PulseLife = "2"
          PulseLag = "0.05"
        }
        func_tanklaser:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush Laser Turret"
        }
        func_tankrocket:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush Rocket Turret"
          rocketspeed = "800"
        }
        func_tankairboatgun:b =
        {
          ;incl = "defpoly"
          ;desc = "Airboat Gun Turret"
        }
        func_tankapcrocket:b =
        {
          ;incl = "defpoly"
          ;desc = "APC Rocket Turret"
          rocketspeed = "800"
          burstcount = "10"
        }
        func_tankmortar:b =
        {
          ;incl = "defpoly"
          ;desc = "Brush Mortar Turret"
          iMagnitude = "100"
          firedelay = "2"
          warningtime = "1"
          firevariance = "0"
        }
        func_tankphyscannister:b =
        {
          ;incl = "defpoly"
          ;desc = "PhysCannister Turret"
        }
        func_monitor:b =
        {
          ;incl = "defpoly"
          ;desc = "A monitor that renders the view from a given point_camera e"
           "ntity."
        }
      }
      env_* entities.qtxfolder =
      {
        env_zoom:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to control the player's FOV. Use"
           "ful for scenes where the player's view is being controlled, or pla"
           "yer usable binoculars / telescopes, etc."
          Rate = "1.0"
          FOV = "75"
        }
        env_screenoverlay:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can display and control a set of screen over"
           "lays, to be displayed over the player's view. Useful for view effe"
           "cts like drunkenness, or teleporter afterimages, etc."
          OverlayTime1 = "1.0"
          OverlayTime2 = "1.0"
          OverlayTime3 = "1.0"
          OverlayTime4 = "1.0"
          OverlayTime5 = "1.0"
          OverlayTime6 = "1.0"
          OverlayTime7 = "1.0"
          OverlayTime8 = "1.0"
          OverlayTime9 = "1.0"
          OverlayTime10 = "1.0"
        }
        env_texturetoggle:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that allows you to change the textures on other b"
           "rush-built entities."
        }
        env_splash:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a splash effect at it's origin. If t"
           "he 'find water surface' spawnflag is set, it will instead trace do"
           "wn below itself to find the water surface on which to create splas"
           "hes."
          scale = "8.0"
          spawnflags = "2"
        }
        env_particlelight:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to light the smoke particles emi"
           "tted by env_smokestack entities. Currently does not light any othe"
           "r particles."
          Color = "255 0 0"
          Intensity = "5000"
          directional = "0"
        }
        env_sun:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control & draw a sun effect in the sky."
          use_angles = "0"
          pitch = "0"
          rendercolor = "100 80 80"
          size = "16"
        }
        env_lightglow:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that puts an additive glow in the world, mostly u"
           "sed over light sources."
          rendercolor = "255 255 255"
          VerticalGlowSize = "30"
          HorizontalGlowSize = "30"
          MinDist = "500"
          MaxDist = "2000"
          OuterMaxDist = "0"
          GlowProxySize = "2.0"
        }
        env_smokestack:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that spits out a constant stream of smoke. See pa"
           "rticlezoo.vmf for sample usage. You can place up to two env_partic"
           "lelight entities near the smoke stack to add ambient light to its "
           "particles."
          InitialState = "0"
          BaseSpread = "20"
          SpreadSpeed = "15"
          Speed = "30"
          StartSize = "20"
          EndSize = "30"
          Rate = "20"
          JetLength = "180"
          WindAngle = "0"
          WindSpeed = "0"
          SmokeMaterial = "particle/SmokeStack.vmt"
          twist = "0"
          rendercolor = "255 255 255"
          renderamt = "255"
        }
        env_fade:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls screen fades."
          duration = "2"
          holdtime = "0"
          renderamt = "255"
          rendercolor = "0 0 0"
        }
        env_player_surface_trigger:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that monitors the material of the surface the pla"
           "yer is standing on, and fires outputs whenever it changes to/from "
           "a specific material."
          gamematerial = "0"
        }
        env_tonemap_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the HDR tonemapping for the player."
           " Think of it as a method of controlling the exposure of the player"
           "'s eyes."
        }
        env_beam:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a visible beam between two points. T"
           "he points can be attached to entities to make the beam move around"
           "."
          renderamt = "100"
          rendercolor = "255 255 255"
          Radius = "256"
          life = "1"
          BoltWidth = "2"
          NoiseAmplitude = "0"
          texture = "sprites/laserbeam.spr"
          TextureScroll = "35"
          framerate = "0"
          framestart = "0"
          StrikeTime = "1"
          damage = "0"
          TouchType = "0"
        }
        env_beverage:e =
        {
          origin = "0 0 0"
          ;desc = "HL1 Legacy: Beverage Dispenser."
          health = "10"
          beveragetype = "0"
        }
        env_embers:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity used to create a volume in which to spawn fire em"
           "bers."
          particletype = "0"
          density = "50"
          lifetime = "4"
          speed = "32"
          rendercolor = "255 255 255"
        }
        env_funnel:e =
        {
          origin = "0 0 0"
          ;desc = "HL1 Legacy: Large Portal Funnel"
        }
        env_blood:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to spawn blood effects."
          spraydir = "0 0 0"
          color = "0"
          amount = "100"
        }
        env_bubbles:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity used to create a volume in which to spawn bubbles"
           "."
          density = "2"
          frequency = "2"
          current = "0"
        }
        env_explosion:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates an explosion at it's origin."
          iMagnitude = "100"
          iRadiusOverride = "0"
          fireballsprite = "sprites/zerogxplode.spr"
          rendermode = "5"
        }
        env_smoketrail:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a smoke trail."
          opacity = "0.75"
          spawnrate = "20"
          lifetime = "5.0"
          startcolor = "192 192 192"
          endcolor = "160 160 160"
          emittime = "0"
          minspeed = "10"
          maxspeed = "20"
          mindirectedspeed = "0"
          maxdirectedspeed = "0"
          startsize = "15"
          endsize = "50"
          spawnradius = "15"
          firesprite = "sprites/firetrail.spr"
          smokesprite = "sprites/whitepuff.spr"
        }
        env_global:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control a global game state."
          initialstate = "0"
        }
        env_physexplosion:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates an explosion at it's origin. If the "
           "no-damage spawnflag is set, the explosion won't be visible, but wi"
           "ll apply force to any physics objects within it's radius."
          magnitude = "100"
          radius = "0"
          spawnflags = "1"
        }
        env_physimpact:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that will cause a physics impact on another entit"
           "y."
          angles = "0 0 0"
          magnitude = "100"
          distance = "0"
        }
        env_fire:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that handles a single flame at it's origin. The f"
           "lame causes heat 'damage' to other env_fire entities around it, an"
           "d will eventually ignite non-flaming env_fire entities nearby, cau"
           "sing the fire to spread."
          health = "30"
          firesize = "64"
          fireattack = "4"
          firetype = "0"
          ignitionpoint = "32"
          damagescale = "1.0"
        }
        env_firesource:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that provides heat to all nearby env_fire entitie"
           "s. Cannot be extinguished."
          fireradius = "128"
          firedamage = "10"
        }
        env_firesensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects changes in heat nearby."
          spawnflags = "1"
          fireradius = "128"
          heatlevel = "32"
          heattime = "0"
        }
        env_entity_igniter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that catches a target entity on fire. If the enti"
           "ty is an animating model, it will have sprite flames attached to i"
           "ts skeleton. Otherwise the entity will emit particle flame puffs."
          lifetime = "10"
        }
        env_fog_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the fog and view distance in the ma"
           "p."
          fogenable = "0"
          fogblend = "0"
          use_angles = "0"
          fogcolor = "255 255 255"
          fogcolor2 = "255 255 255"
          fogdir = "1 0 0"
          fogstart = "500.0"
          fogend = "2000.0"
          farz = "-1"
        }
        env_steam:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to create a jet of steam."
          InitialState = "0"
          type = "0"
          SpreadSpeed = "15"
          Speed = "120"
          StartSize = "10"
          EndSize = "25"
          Rate = "26"
          rendercolor = "255 255 255"
          JetLength = "80"
          renderamt = "255"
        }
        env_laser:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a laser beam between itself and a gi"
           "ven target."
          renderamt = "100"
          rendercolor = "255 255 255"
          width = "2"
          NoiseAmplitude = "0"
          texture = "sprites/laserbeam.spr"
          TextureScroll = "35"
          framestart = "0"
          damage = "100"
          dissolvetype = "None"
        }
        env_message:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that draws a text message on player's HUDs."
          messagevolume = "10"
          messageattenuation = "0"
        }
        env_hudhint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the display of HUD hints. HUD hints ar"
           "e used to show the player what key is bound to a particular comman"
           "d."
        }
        env_shake:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control screen shake on players."
          amplitude = "4"
          radius = "500"
          duration = "1"
          frequency = "2.5"
        }
        env_shooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that shoots models, or sprites, out of it's origi"
           "n."
          shootsounds = "-1"
          simulation = "0"
          skin = "0"
        }
        env_rotorshooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates gibs when it's within the influence "
           "of a helicopter's rotor wash."
          shootsounds = "-1"
          simulation = "0"
          skin = "0"
          rotortime = "1"
          rotortimevariance = "0.3"
        }
        env_soundscape_proxy:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a soundscape but gets all of its s"
           "ound parameters from another env_soundscape entity."
          radius = "128"
        }
        env_soundscape:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control sound in an area. The active soundscap"
           "e at any time is the last one that had line-of-sight to the player"
           ", and was within the radius."
          radius = "128"
          soundscape = "Nothing"
        }
        env_soundscape_triggerable:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that works like env_soundscape except that it wor"
           "ks in conjunction with trigger_soundscape to determine when a play"
           "er hears it."
        }
        env_spark:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to create sparks at it's origin."
          MaxDelay = "0"
          Magnitude = "1"
          TrailLength = "1"
        }
        env_sprite:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the drawing of a sprite in the worl"
           "d."
          framerate = "10.0"
          model = "sprites/glow01.spr"
          GlowProxySize = "2.0"
        }
        env_wind:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control wind in the map. Unfinished."
          minwind = "20"
          maxwind = "50"
          mingust = "100"
          maxgust = "250"
          mingustdelay = "10"
          maxgustdelay = "20"
          gustdirchange = "20"
        }
        env_cubemap:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a sample point for the Cubic Environ"
           "ment Map."
          cubemapsize = "0"
        }
        env_dustpuff:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can emit dust puffs."
          scale = "8"
          speed = "16"
          color = "128 128 128"
        }
        env_particlescript:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that has special animation events that can be fir"
           "ed by a model with an animation inside it's .qc designed foruse by"
           " this entity."
          model = "models/fire_equipment/w_weldtank.mdl"
        }
        env_effectscript:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that allows you to script beams."
          model = "models/fire_equipment/w_weldtank.mdl"
        }
        env_microphone:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts as a microphone. It works in one of two"
           " modes. If it has a 'Speaker' set, it picks up all sounds within t"
           "he specified sound range, and rebroadcasts them through the Speake"
           "r entity. In this Speaker mode, it ignores the Hears X spawnflags "
           "and does not fire the SoundLevel output. If it has no Speaker set,"
           " it measures the sound level at a point, and outputs the sound lev"
           "el as a value between 0 and 1. In Measuring mode, it only hears so"
           "unds that match the Hear X spawnflags."
          speaker_dsp_preset = "0"
          spawnflags = "15"
          Sensitivity = "1"
          SmoothFactor = "0"
          MaxRange = "240"
        }
        env_entity_maker:e =
        {
          origin = "0 0 0"
          ;desc = "Spawns the specified entity template at it's origin. If set"
           " to auto-spawn, it will spawn the template whenever there's room a"
           "nd the player is looking elsewhere."
        }
        env_credits:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the rolling credits."
        }
        env_gunfire:e =
        {
          origin = "0 0 0"
          ;desc = "Gunfire Effect"
          minburstsize = "2"
          maxburstsize = "7"
          minburstdelay = "2"
          maxburstdelay = "5"
          rateoffire = "10"
          spread = "5"
          bias = "1"
          collisions = "0"
          shootsound = "Weapon_AR2.NPC_Single"
          tracertype = "AR2TRACER"
        }
        env_headcrabcanister:e =
        {
          origin = "0 0 0"
          ;desc = "Headcrab canister"
          HeadcrabType = "0"
          HeadcrabCount = "6"
          FlightSpeed = "3000"
          FlightTime = "5"
          StartingHeight = "0"
          MinSkyboxRefireTime = "0"
          MaxSkyboxRefireTime = "0"
          SkyboxCannisterCount = "1"
          Damage = "150"
          DamageRadius = "750"
          SmokeLifetime = "30"
        }
        env_rotorwash:e =
        {
          origin = "0 0 0"
          ;desc = "Rotorwash Effect"
        }
        env_ar2explosion:e =
        {
          origin = "0 0 0"
          ;desc = "AR2 explosion visual effect. Big, volume-filling brown clou"
           "d. Does not cause damage or emit sound."
          material = "particle/particle_noisesphere"
        }
        env_starfield:e =
        {
          origin = "0 0 0"
          ;desc = "Starfield effect"
        }
        env_flare:e =
        {
          origin = "0 0 0"
          ;desc = "Flare"
          scale = "1"
          duration = "30"
        }
        env_extinguisherjet:e =
        {
          origin = "0 0 0"
          ;desc = "Fire Extinguisher Jet"
          length = "128"
          size = "8"
          radius = "32"
          strength = "0.97"
          enabled = "1"
        }
        env_muzzleflash:e =
        {
          origin = "0 0 0"
          ;desc = "Muzzle Flash"
          scale = "1"
        }
        env_terrainmorph:e =
        {
          origin = "0 0 0"
          ;desc = "Morphs terrain by pulling vertices along a normal.\n\nPlace"
           " this entity the desired distance from a terrain surface and set A"
           "NGLES to the normal along which you want to pull the surface's ver"
           "tices. If you set the INSTANT spawnflag, the morph will take place"
           " instantly instead of over time.\n"
          startradius = "500"
          goalradius = "100"
          duration = "3"
          fraction = "1"
        }
        env_speaker:e =
        {
          origin = "0 0 0"
          ;desc = "Announcement Speaker"
        }
        env_citadel_energy_core:e =
        {
          origin = "0 0 0"
          ;desc = "Special effect for the energy cores in citadel."
          scale = "1"
        }
        env_alyxemp:e =
        {
          origin = "0 0 0"
          ;desc = "Special effect for the Alyx's EMP device."
          Type = "0"
        }
      }
      game_* entities.qtxfolder =
      {
        game_ragdoll_manager:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the number of ragdolls in the world, f"
           "or performance reasons."
          MaxRagdollCount = "-1"
        }
        game_weapon_manager:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to limit the number of a particular weapon t"
           "ype in the world. Useful in places where NPCs are spawning rapidly"
           ", dying, and dropping weapons."
          maxpieces = "0"
        }
        game_end:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that ends a multiplayer game."
        }
        game_player_equip:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that gives equipment to the player who activates "
           "it. To use, add new keys to this entity, where each key is the cla"
           "ssname of a weapon/item, and the corresponding value is the number"
           " of those weapons/items to give to the player who uses this entity"
           ". If the 'Use Only' spawnflag isn't set, then players can just tou"
           "ch this entity to get the equipment."
        }
        game_player_team:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that changes the team of the player who activates"
           " it."
        }
        game_score:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that awards/deducts points from the player who ac"
           "tivates it."
          points = "1"
        }
        game_text:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that displays text on player's screens."
          x = "-1"
          y = "-1"
          effect = "0"
          color = "100 100 100"
          color2 = "240 110 0"
          fadein = "1.5"
          fadeout = "0.5"
          holdtime = "1.2"
          fxtime = "0.25"
          channel = "1"
        }
        game_ui:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to override player input when the player's l"
           "ooking at it."
          spawnflags = "480"
          FieldOfView = "-1.0"
        }
        game_zone_player:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity used to count the number of players within a zone"
           "."
        }
      }
      vgui_* entities.qtxfolder =
      {
        vgui_screen:e =
        {
          origin = "0 0 0"
          ;desc = "A VGUI screen. Useful for in-world monitors."
        }
      }
      sky_* entities.qtxfolder =
      {
        sky_camera:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to control the 3D Skybox. It's origin is use"
           "d to determine the 3D Skybox's position relative to the map. Place"
           " this entity, in the 3D Skybox, at the point where the origin of t"
           "he map should be."
          scale = "16"
          fogenable = "0"
          fogblend = "0"
          use_angles = "0"
          fogcolor = "255 255 255"
          fogcolor2 = "255 255 255"
          fogdir = "1 0 0"
          fogstart = "500.0"
          fogend = "2000.0"
        }
      }
      point_* entities.qtxfolder =
      {
        point_enable_motion_fixup:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to move a motion-disabled prop when it enabl"
           "es motion. Parent this entity to the prop, and when the prop has i"
           "t's motion enabled, it will immediately teleport to the origin of "
           "this entity."
        }
        point_message:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that displays a text message in the world, at it'"
           "s origin."
          radius = "128"
          developeronly = "0"
        }
        point_spotlight:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to draw a spotlight. Will draw a beam when the pl"
           "ayer views it side on, and a halo when it's facing towards the pla"
           "yer. Unless the 'No Dynamic Light' spawnflag is checked, it will a"
           "lso create a dynamic light wherever the end of the spotlight rests"
           "."
          spawnflags = "1"
          spotlightlength = "500"
          spotlightwidth = "50"
          rendercolor = "255 255 255"
        }
        point_tesla:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates tesla lightning arcs around it's ori"
           "gin."
          m_SoundName = "DoSpark"
          texture = "sprites/physbeam.vmt"
          m_Color = "255 255 255"
          m_flRadius = "200"
          beamcount_min = "6"
          beamcount_max = "8"
          thick_min = "4"
          thick_max = "5"
          lifetime_min = "0.3"
          lifetime_max = "0.3"
          interval_min = "0.5"
          interval_max = "2"
        }
        point_clientcommand:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that issues commands to the client console, as if"
           " it was typed in by the player (if activator is a player, or the l"
           "ocal player in single player)."
        }
        point_servercommand:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that issues commands to the server console."
        }
        point_viewcontrol:e =
        {
          origin = "0 0 0"
          ;desc = "A camera entity that controls the player's view. While it's"
           " active, the player will see out of the camera."
          wait = "10"
          spawnflags = "3"
          speed = "0"
          acceleration = "500"
          deceleration = "500"
        }
        point_template:e =
        {
          origin = "0 0 0"
          ;desc = "Turns an entity, or set of entities, into a single template"
           " that can be instanced anywhere, and multiple times. If there are "
           "interdependencies (entity I/O, hierarchy, or other name references"
           ") between the entities in the template, the entities in the templa"
           "te will have their names changed and the interdependencies will be"
           " reconnected to the changes names. The name change format is as fo"
           "llows: '<original name>&0000', where the 0000 will be replaced wit"
           "h the current global template instance, so wildcard searches for '"
           "<original name>*' will still find them.\nIf you don't want the nam"
           "e fixup to happen, because you're only spawning the template once,"
           " or you want inputs to trigger all instances of the template, chec"
           "k the 'Preserve entity names' spawnflag. \nTo spawn the template i"
           "n other places, use an env_entity_maker."
          spawnflags = "2"
        }
        point_anglesensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects if another entity points in a given "
           "direction for a period of time."
        }
        point_angularvelocitysensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects if another entity's angular velocity"
           " meets or exceeds a threshold value."
          threshold = "0"
        }
        point_teleport:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that teleports a target entity to this position a"
           "nd angles. If 'Teleport Home' spawn flag is set, teleports the tar"
           "get entity to its spawn position instead.If object is physically s"
           "imulated, simulation is turned off when teleported."
        }
        point_hurt:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does damage to all entities in a radius arou"
           "nd itself, with a specified delay.If 'Target Entity' is specified,"
           " the damage is only done to that entity."
          DamageRadius = "256"
          Damage = "5"
          DamageDelay = "1"
          DamageType = "0"
        }
        point_playermoveconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that constrains players to a radius around itself"
           ", slowing them down the closer they get to the edge of the radius."
          radius = "256"
          width = "75.0"
          speedfactor = "0.15"
        }
        point_antlion_repellant:e =
        {
          origin = "0 0 0"
          ;desc = "Antlion Repellant"
          repelradius = "512"
        }
        point_bugbait:e =
        {
          origin = "0 0 0"
          ;desc = "Bugbait sensor point"
          Enabled = "1"
          radius = "512"
        }
        point_camera:e =
        {
          origin = "0 0 0"
          ;desc = "Camera"
          FOV = "90"
          UseScreenAspectRatio = "0"
          fogEnable = "0"
          fogColor = "0 0 0"
          fogStart = "2048"
          fogEnd = "4096"
        }
        point_apc_controller:e =
        {
          origin = "0 0 0"
          ;desc = "APC Controller"
          yawrate = "30"
          yawtolerance = "15"
          pitchrate = "0"
          pitchtolerance = "20"
          minRange = "0"
          maxRange = "0"
        }
      }
      phys_* entities.qtxfolder =
      {
        phys_ragdollmagnet:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a magnet for ragdolls. Useful for "
           "crafting exaggerated ragdoll behavior (i.e. guys falling over rail"
           "s on death). If the Bar Magnet spawnflag is set, the magnet works "
           "like it was a cylindrical magnet i.e. it attracts ragdolls to the "
           "nearest point on a line."
          radius = "512"
          force = "5000"
        }
        phys_constraintsystem:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to manage a group of interacting constraints"
           " and keep them stable. All constraints on a set of entities should"
           " be placed in the same system, or they will fight each other durin"
           "g simulation."
          additionaliterations = "0"
        }
        phys_keepupright:e =
        {
          origin = "0 0 0"
          ;desc = "A controller that tries to keep an entity facing a particul"
           "ar direction."
          angularlimit = "15"
        }
        phys_spring:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated spring.'Length' is what's known as t"
           "he 'natural spring length'.  This is how long the spring would be "
           "if it was at rest (nothing hanging on it or attached).  When you a"
           "ttach something to the spring, it will stretch longer than its 'na"
           "tural length'.  The amount of stretch is determined by the 'Sprint"
           " Constant'.  The larger the spring constant the less stretch the s"
           "pring."
          length = "0"
          constant = "50"
          damping = "2.0"
          relativedamping = "0.1"
          breaklength = "0"
        }
        phys_hinge:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated hinge. Use the helper to define the "
           "axis of rotation."
          hingefriction = "0"
          SystemLoadScale = "1"
        }
        phys_ballsocket:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that keeps the position of two objects fixed, "
           "relative to the constraint's origin. It does not affect rotation."
        }
        phys_constraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that keeps the relative position and orientati"
           "on of two objects fixed."
          spawnflags = "1"
        }
        phys_pulleyconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that is essentially two length constraints and"
           " two points. Imagine it as a virtual rope connected to two objects"
           ", each suspended from a pulley above them.The constraint keeps the"
           " sum of the distances between the pulley points and their suspende"
           "d objects constant."
          addlength = "0"
          gearratio = "1"
          spawnflags = "1"
        }
        phys_slideconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that constrains an entity along a line segment"
           "."
          spawnflags = "1"
          slidefriction = "0"
          SystemLoadScale = "1"
        }
        phys_lengthconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that preserves the distance between two entiti"
           "es. If the 'Keep Rigid' flag is set, think of it as a rod. If not,"
           " think off it as a virtual rope."
          addlength = "0"
          minlength = "0"
          attachpoint = "The position the rope attaches to object 2"
          spawnflags = "1"
        }
        phys_ragdollconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that fixes the position of two entities, relat"
           "ive to this constraint's origin. Also allows for limits on the rot"
           "ation around each axis, in the space of this constraint."
          spawnflags = "1"
          xmin = "-90"
          xmax = "90"
          ymin = "0"
          ymax = "0"
          zmin = "0"
          zmax = "0"
          xfriction = "0"
          yfriction = "0"
          zfriction = "0"
        }
        phys_convert:e =
        {
          origin = "0 0 0"
          ;desc = "Turns an arbitrary entity into a physically simulated entit"
           "y. i.e. brush entities will behave like func_physbox, model entiti"
           "es behave like prop_physics."
        }
        phys_thruster:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to apply constant acceleration to a physics "
           "object. The force and torque is calculated using the position and "
           "direction of the thruster as an impulse. So moving those off the o"
           "bject's center will cause torque as well. Torque can be removed by"
           " unchecking the 'apply torque' flag. The position of the thruster "
           "can be forced to be at the object's center by checking to 'ignore "
           "pos' flag."
          force = "0"
        }
        phys_torque:e =
        {
          origin = "0 0 0"
          ;desc = "An angular thruster. Use it to apply angular force to an en"
           "tity."
          force = "0"
        }
        phys_motor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that tries to spin a target entity at a particula"
           "r speed."
          speed = "0"
          spinup = "1"
          inertiafactor = "1.0"
          spawnflags = "5"
        }
        phys_magnet:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a magnet, attaching metallic physi"
           "cs objects to itself when they touch it."
          forcelimit = "0"
          torquelimit = "0"
          massScale = "0"
          maxobjects = "0"
        }
        phys_constraintsystem:e =
        {
          origin = "0 0 0"
          ;desc = "Used to manage a group of interacting constraints and keep "
           "them stable."
        }
      }
      light_* entities.qtxfolder =
      {
        light_environment:e =
        {
          origin = "0 0 0"
          ;desc = "Sets the color and angle of the light from the sun and sky."
          pitch = "0"
          _light = "255 255 255 200"
          _ambient = "255 255 255 20"
        }
        light_spot:e =
        {
          origin = "0 0 0"
          ;desc = "Spotlight."
          _inner_cone = "30"
          _cone = "45"
          _exponent = "1"
          _distance = "0"
          pitch = "-90"
        }
        light_dynamic:e =
        {
          origin = "0 0 0"
          ;desc = "An invisible lightsource that changes in some way over time"
           "."
          _light = "255 255 255 200"
          brightness = "0"
          _inner_cone = "30"
          _cone = "45"
          pitch = "-90"
          distance = "120"
          spotlight_radius = "80"
          style = "0"
        }
      }
      shadow_* entities.qtxfolder =
      {
        shadow_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the shadows in the map."
          angles = "80 30 0"
          color = "128 128 128"
          distance = "75"
        }
      }
      keyframe_* entities.qtxfolder =
      {
        keyframe_track:e =
        {
          origin = "0 0 0"
          ;desc = "Animation KeyFrame"
        }
        keyframe_rope:e =
        {
          origin = "0 0 0"
          ;desc = "A node entity that marks a point in a rope. The first node "
           "in the rope should be a move_rope, followed by 1 or more keyframe_"
           "ropes."
        }
      }
      move_* entities.qtxfolder =
      {
        move_keyframed:e =
        {
          origin = "0 0 0"
          ;desc = "Keyframed Move Behavior"
        }
        move_track:e =
        {
          origin = "0 0 0"
          ;desc = "Track Move Behavior"
          WheelBaseLength = "50"
          Damage = "0"
          NoRotate = "0"
        }
        move_rope:e =
        {
          origin = "0 0 0"
          ;desc = "The first node in set of nodes that are used to place ropes"
           " in the world. It should connect to 1 or more keyframe_rope entiti"
           "es."
          PositionInterpolator = "2"
        }
      }
      momentary_* entities.qtxfolder =
      {
        momentary_rot_button:b =
        {
          ;incl = "defpoly"
          ;desc = "A brush entity that's designed to be used for rotating whee"
           "ls, where the player can rotate them to arbitrary positions before"
           " stopping."
          speed = "50"
          sounds = "0"
          distance = "90"
          returnspeed = "0"
          spawnflags = "1057"
          startposition = "0"
          startdirection = "Forward"
          solidbsp = "0"
        }
      }
      prop_* entities.qtxfolder =
      {
        prop_door_rotating:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to place a door in the world."
          hardware = "1"
          ajarangles = "0 0 0"
          spawnpos = "0"
          distance = "90"
          speed = "100"
          returndelay = "-1"
          dmg = "0"
          health = "0"
          forceclosed = "0"
          spawnflags = "8192"
        }
        prop_detail:e =
        {
          origin = "0 0 0"
          ;desc = "Detail Prop"
        }
        prop_static:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that doesn't move and doesn't animate."
        }
        prop_dynamic:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that can be placed in hierarchy and can play animati"
           "ons. It can also be configured to break when it takes enough damag"
           "e. Note that the health of the object will be overridden by the he"
           "alth inside the model, to ensure consistent health game-wide. If t"
           "he model used by the prop is configured to be used as a prop_physi"
           "cs (i.e. it should be physically simulated) then it CANNOT be used"
           " as a prop_dynamic. Upon level load it will display a warning in t"
           "he console and remove itself. Use a prop_physics instead."
        }
        prop_dynamic_override:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that can be placed in hierarchy and can play animati"
           "ons. It can also be configured to break when it takes enough damag"
           "e.\nprop_dynamic_override is a prototyping entity only. It will al"
           "low the use of models designed to be used as prop_physics."
          health = "0"
        }
        prop_physics_override:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that physically simulates as a single rigid body. It"
           " can be constrained to other physics objects using hinges or other"
           " constraints. It can also be configured to break when it takes eno"
           "ugh damage. Health can be overridden on this version."
          health = "0"
        }
        prop_physics:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that physically simulates as a single rigid body. It"
           " can be constrained to other physics objects using hinges or other"
           " constraints. It can also be configured to break when it takes eno"
           "ugh damage. Note that the health of the object will be overridden "
           "by the health inside the model, to ensure consistent health game-w"
           "ide. If the model used by the prop is configured to be used as a p"
           "rop_dynamic (i.e. it should not be physically simulated) then it C"
           "ANNOT be used as a prop_physics. Upon level load it will display a"
           " warning in the console and remove itself. Use a prop_dynamic inst"
           "ead."
        }
        prop_ragdoll:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that physically simulates and can be articulated wit"
           "h internal joints. The joint constraints are part of the physics m"
           "odel."
          spawnflags = "4"
          fademindist = "-1"
          fademaxdist = "0"
          fadescale = "1"
        }
        prop_dynamic_ornament:e =
        {
          origin = "0 0 0"
          ;desc = "A way to attach one studio model to another as an ornament."
           " It will render in the way that player/NPC weapons render."
          solid = "0"
        }
        prop_physics_multiplayer:e =
        {
          origin = "0 0 0"
          ;desc = "This class is the same as prop_physics, except the runtime "
           "collisions use a more bouncy method that avoids the prediction err"
           "ors normal physics objects get."
        }
        prop_combine_ball:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that physically simulates as a single rigid body. It"
           " can be constrained to other physics objects using hinges or other"
           " constraints. It can also be configured to break when it takes eno"
           "ugh damage."
        }
        prop_thumper:e =
        {
          origin = "0 0 0"
          ;desc = "Thumper"
          model = "models/props_combine/CombineThumper002.mdl"
          dustscale = "Small Thumper"
        }
        prop_vehicle:e =
        {
          origin = "0 0 0"
          ;desc = "Studiomodel vehicle that can be driven via inputs."
        }
        prop_vehicle_driveable:e =
        {
          origin = "0 0 0"
          ;desc = "Generic driveable studiomodel vehicle."
        }
        prop_vehicle_apc:e =
        {
          origin = "0 0 0"
          ;desc = "APC with mounted guns, can only be driven by a vehicle driv"
           "er or a npc_apcdriver."
        }
        prop_vehicle_jeep:e =
        {
          origin = "0 0 0"
          ;desc = "Driveable studiomodel jeep."
        }
        prop_vehicle_airboat:e =
        {
          origin = "0 0 0"
          ;desc = "Driveable studiomodel airboat."
          model = "models/airboat.mdl"
          vehiclescript = "scripts/vehicles/airboat.txt"
          EnableGun = "0"
        }
        prop_vehicle_cannon:e =
        {
          origin = "0 0 0"
          ;desc = "Driveable studiomodel cannon."
        }
        prop_vehicle_crane:e =
        {
          origin = "0 0 0"
          ;desc = "Driveable studiomodel crane."
        }
        prop_vehicle_prisoner_pod:e =
        {
          origin = "0 0 0"
          ;desc = "Combine prisoner pod that the player can ride in."
          model = "models/vehicles/prisoner_pod.mdl"
          vehiclescript = "scripts/vehicles/prisoner_pod.txt"
        }
        prop_physics_respawnable:e =
        {
          origin = "0 0 0"
          ;desc = "This class is the same as prop_physics, except it respawns "
           "after it breaks"
          RespawnTime = "60"
        }
      }
      logic_* entities.qtxfolder =
      {
        logic_auto:e =
        {
          origin = "0 0 0"
          ;desc = "Fires outputs when a map spawns.If 'Remove on fire' flag is"
           " set the logic_auto is deleted after firing. It can be set to chec"
           "k a global state before firing. This allows you to only fire event"
           "s based on what took place in a previous map."
          spawnflags = "1"
        }
        logic_compare:e =
        {
          origin = "0 0 0"
          ;desc = "Compares an input value to another value. If the input valu"
           "e is less than the compare value, the OnLessThan output is fired w"
           "ith the input value. If the input value is equal to the compare va"
           "lue, the OnEqualTo output is fired with the input value. If the in"
           "put value is greater than the compare value, the OnGreaterThan out"
           "put is fired with the input value."
        }
        logic_branch:e =
        {
          origin = "0 0 0"
          ;desc = "Tests a boolean value and fires an output based on whether "
           "the value is true or false. Use this entity to branch between two "
           "potential sets of events."
        }
        logic_case:e =
        {
          origin = "0 0 0"
          ;desc = "Compares an input to up to 16 preset values. If the input v"
           "alue is the same as any of the preset values, an output correspond"
           "ing to that value is fired.\n\nFor example: if Case01 is set to 2 "
           "and Case02 is set to 5, and the input value is 5, the OnCase02 out"
           "put will be fired.\n\nThis entity can also be used to select from "
           "a number of random targets via the PickRandom input. One of the On"
           "Case outputs that is connected to another entity will be picked at"
           " random and fired."
        }
        logic_multicompare:e =
        {
          origin = "0 0 0"
          ;desc = "Compares a set of inputs to each other. If they are all the"
           " same, fires an OnEqual output. If any are different, fires the On"
           "NotEqual output."
          ShouldComparetoValue = "0"
        }
        logic_relay:e =
        {
          origin = "0 0 0"
          ;desc = "A message forwarder. Fires an OnTrigger output when trigger"
           "ed, and can be disabled to prevent forwarding outputs.\n\nUseful a"
           "s an intermediary between one entity and another for turning on or"
           " off an I/O connection, or as a container for holding a set of out"
           "puts that can be triggered from multiple places."
        }
        logic_timer:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that fires a timer event at regular, or random, i"
           "ntervals. It can also be set to oscillate betweena high and low en"
           "d, in which case it will fire alternating high/low outputs each ti"
           "me it fires."
          UseRandomTime = "0"
        }
        logic_collision_pair:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to enables/disable vphysics coll"
           "isions between two target entities."
          startdisabled = "1"
        }
        logic_lineto:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that calculates and outputs a vector from one ent"
           "ity to another."
        }
        logic_navigation:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that is used to set navigation properties on othe"
           "r entities."
          target = "Name of the entity to set navigation properties on."
          spawnflags = "1"
          navprop = "Ignore"
        }
        logic_autosave:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that is used to force an autosave."
          NewLevelUnit = "0"
        }
        logic_measure_movement:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can measure the movement of an entity relati"
           "ve to another entity and apply that movement to a third entity."
          TargetScale = "1"
          MeasureType = "0"
        }
        logic_choreographed_scene:e =
        {
          origin = "0 0 0"
          ;desc = "Manages a choreographed scene of one or more actors."
          busyactor = "0"
        }
      }
      math_* entities.qtxfolder =
      {
        math_remap:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that remaps a range of input values to a given ra"
           "nge of output values."
          spawnflags = "1"
          in1 = "0"
          in2 = "1"
        }
        math_colorblend:e =
        {
          origin = "0 0 0"
          ;desc = "Used to create a blend between two colors for controlling t"
           "he color of another entity."
          spawnflags = "1"
          inmin = "0"
          inmax = "1"
          colormin = "0 0 0"
          colormax = "255 255 255"
        }
        math_counter:e =
        {
          origin = "0 0 0"
          ;desc = "Holds a numeric value and performs arithmetic operations up"
           "on it. If either the minimum or maximum legal value is nonzero, Ou"
           "tValue will be clamped to the legal range, and the OnHitMin/OnHitM"
           "ax outputs will be fired at the appropriate times. If both min and"
           " max are set to zero, no clamping is performed and only the OutVal"
           "ue output will be fired."
          startvalue = "0"
          min = "0"
          max = "0"
        }
      }
      filter_* entities.qtxfolder =
      {
        filter_multi:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that tests the activator against multiple filters."
           " This allows you to build more complex filters, such as'Allow anyo"
           "ne on Team 1 who is also class engineer', or 'Allow everyone excep"
           "t classes npc_zombie and npc_headcrab'."
          filtertype = "0"
          Negated = "0"
        }
        filter_activator_name:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that filters by the name of the activator."
        }
        filter_activator_class:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that filters by the class name of the activator."
        }
        filter_activator_team:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that filters by the team of the activator."
          filterteam = "1"
        }
        filter_damage_type:e =
        {
          origin = "0 0 0"
          ;desc = "A damage filter that filters by the type of damage inflicte"
           "d. This can only be used as a damage filter, not as an activator f"
           "ilter."
          damagetype = "64"
        }
      }
      physics_* entities.qtxfolder =
      {
        physics_cannister:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated gas cannister that can have it's cap"
           " shot off, at which point gas will start escaping and cause the ca"
           "nnister to fly around. If it takes enough damage, it will explode."
          model = "models/fire_equipment/w_weldtank.mdl"
          spawnflags = "2"
          expdamage = "200.0"
          expradius = "250.0"
          health = "25"
          thrust = "3000.0"
          fuel = "12.0"
          rendercolor = "255 255 255"
          renderamt = "128"
          gassound = "ambient/objects/cannister_loop.wav"
        }
      }
      tanktrain_* entities.qtxfolder =
      {
        tanktrain_aitarget:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that changes the target of a tanktrain_ai entity."
        }
        tanktrain_ai:e =
        {
          origin = "0 0 0"
          ;desc = "Train chase AI"
          startsound = "vehicles/diesel_start1.wav"
          enginesound = "vehicles/diesel_turbo_loop1.wav"
          movementsound = "vehicles/tank_treads_loop1.wav"
        }
      }
      path_* entities.qtxfolder =
      {
        path_track:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to build paths for other entities to follow."
           " Each path_track is a node on the path, each holding the name of t"
           "he next path_track in the path."
          speed = "0"
          radius = "0"
          orientationtype = "1"
        }
        path_corner:e =
        {
          origin = "0 0 0"
          ;desc = "Generic path point"
          wait = "0"
          speed = "0"
          yaw_speed = "0"
        }
        path_corner_crash:e =
        {
          origin = "0 0 0"
          ;desc = "Helicopter Crash Path"
        }
      }
      test_* entities.qtxfolder =
      {
        test_traceline:e =
        {
          origin = "0 0 0"
          ;desc = "A debugging tool for testing tracelines."
        }
        test_sidelist:e =
        {
          origin = "0 0 0"
          ;desc = "Test entity for Ken!"
        }
      }
      trigger_* entities.qtxfolder =
      {
        trigger_autosave:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that autosaves when the player touches it."
          NewLevelUnit = "0"
        }
        trigger_changelevel:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that triggers a level change.\nPlace an info_land"
           "mark in both maps that marks the 'same' location in each map.\nTIP"
           "S & TRICKS: To fire events in the next level, use the OnLevelChang"
           "e output to turn on an env_global in the current level.  Create an"
           " auto_trigger in the next level that checks for the state set by t"
           "he env_global.\n\nTo control which entities go through the level t"
           "ransition, create one or more trigger_transitions and give them th"
           "e same name as the landmark. Any entities within the trigger_trans"
           "ition(s) will go to the next map."
        }
        trigger_gravity:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that changes the gravity on any entity tha"
           "t touches it."
          gravity = "1"
        }
        trigger_playermovement:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity that can be used to disable player's automatic du"
           "cking/unducking when jumping."
          spawnflags = "128"
        }
        trigger_soundscape:b =
        {
          ;incl = "defpoly"
          ;desc = "Soundscape trigger.It is not necessary to create outputs fo"
           "r this trigger. It automatically will trigger the soundscape refer"
           "red to by its 'Soundscape' property."
        }
        trigger_hurt:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that damages entities that touch it."
          damage = "10"
          damagecap = "20"
          damagetype = "0"
          damagemodel = "0"
        }
        trigger_remove:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that removes any entities that touch it. B"
           "e careful, removing some entities can cause instability. This is n"
           "ot the same as killing entities. i.e. NPCs removed in this manner "
           "will not fire their OnKilled outputs."
        }
        trigger_multiple:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that can be triggered multiple times."
          wait = "1"
        }
        trigger_once:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that removes itself after it is triggered "
           "once."
        }
        trigger_look:b =
        {
          ;incl = "defpoly"
          ;desc = "An entity used to trigger something when the player looks a"
           "t something. It fires 'OnTrigger' when the player looks at a targe"
           "t entity for the given amount of time, while within the trigger vo"
           "lume.  If the player leaves the trigger or looks away from the tar"
           "get entity the clock resets. If the 'Use Velocity instead of facin"
           "g' spawnflag is checked, the trigger uses the player's velocity in"
           "stead of the player's view, so it determines whenever the player i"
           "s moving toward the target entity. Useful for triggering when play"
           "ers are driving a vehicle at something.NOTE: Only designed for sin"
           "gle-player game. "
          spawnflags = "128"
          LookTime = "0.5"
          FieldOfView = "0.9"
          Timeout = "0"
        }
        trigger_push:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that pushes entities that touch it."
          pushdir = "0 0 0"
          speed = "40"
        }
        trigger_wind:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that pushes physics objects that touch it."
          Speed = "200"
          SpeedNoise = "0"
          DirectionNoise = "10"
          HoldTime = "0"
          HoldNoise = "0"
        }
        trigger_impact:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that can be told to push all physics objec"
           "ts that are inside of it in the direction specified by this trigge"
           "r's angles.\nAlso outputs the force at the time of impact for anyo"
           "ne else that wants to use it."
          Magnitude = "200"
          noise = "0.1"
          viewkick = "0.05"
        }
        trigger_proximity:b =
        {
          ;incl = "defpoly"
          ;desc = "Measures the distance of the player within the trigger volu"
           "me from a given point (and within a given radius). The NearestPlay"
           "erDistance output will be 0 when the player is at the center point"
           ", and 1 when the player is at the radius."
          radius = "256"
        }
        trigger_teleport:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that teleports entities that touch it. Ent"
           "ities are teleported to the Remote Destination, and have their ang"
           "les set to that of the Remote Destination's. If a Local Destinatio"
           "n Landmark is specified, teleported entities are offset from the t"
           "arget by their initial offset from the landmark, and their angles "
           "are left alone."
        }
        trigger_transition:b =
        {
          ;incl = "defpoly"
          ;desc = "A volume that's used to control which entities go through t"
           "he level transition. Create one or more trigger_transitions and gi"
           "ve them the same name as the changelevel landmark. Any entities wi"
           "thin the trigger_transition(s) will go to the next map.See trigger"
           "_changelevel for more info."
        }
        trigger_waterydeath:b =
        {
          ;incl = "defpoly"
          ;desc = "A trigger volume that spawns leeches around entities inside"
           " it, and does damage to them until they die. Used to prevent playe"
           "rs entering deep water."
        }
        trigger_physics_trap:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that disintegrates enemies"
          dissolvetype = "Energy"
        }
        trigger_weapon_dissolve:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that dissolves all weapons within it"
        }
        trigger_weapon_strip:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that strips combat characters of all w"
           "eapons"
          KillWeapons = "No"
        }
        trigger_super_armor:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that bestows super armor to the player"
        }
        trigger_rpgfire:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that triggers whenever an RPG is fired"
           " within it."
        }
        trigger_vphysics_motion:b =
        {
          ;incl = "defpoly"
          ;desc = "A volumetric trigger that affects the motion of vphysics ob"
           "jects that touch it."
          StartDisabled = "0"
          SetGravityScale = "1.0"
          SetAdditionalAirDensity = "0"
          SetVelocityLimit = "0.0"
          SetVelocityLimitDelta = "0.0"
          SetVelocityScale = "1.0"
          SetAngVelocityLimit = "0.0"
          SetAngVelocityScale = "1.0"
          SetLinearForce = "0.0"
          SetLinearForceAngles = "0 0 0"
          ParticleTrailLifetime = "4"
          ParticleTrailStartSize = "2"
          ParticleTrailEndSize = "3"
        }
      }
      material_* entities.qtxfolder =
      {
        material_modify_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to directly control material var"
           "s. To use it, you need to read the .vmt of the material you intend"
           " to change. Parent this entity to a brush model entity who's mater"
           "ial you want to control."
        }
      }
      ai_* entities.qtxfolder =
      {
        ai_speechfilter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to control the idle speech patte"
           "rns of a set of NPCs."
          IdleModifier = "1.0"
          NeverSayHello = "0"
        }
        ai_relationship:e =
        {
          origin = "0 0 0"
          ;desc = "AI Relationship - Sets relationships between groups of NPCs"
           " in the AI."
          disposition = "3"
          radius = "0"
          rank = "0"
          StartActive = "0"
          Reciprocal = "0"
        }
        ai_ally_manager:e =
        {
          origin = "0 0 0"
          ;desc = "AI Ally Manager"
          maxallies = "5"
          maxmedics = "1"
        }
        ai_goal_lead:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Lead"
          SearchType = "0"
        }
        ai_goal_lead_weapon:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Lead (Weapon). A version of the ai_goal_lead entity"
           " that requires the player to have the specified weapon before the "
           "Actor(s) will lead the player to their target."
          WeaponName = "weapon_bugbait"
          SearchType = "0"
        }
        ai_goal_follow:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Follow"
          SearchType = "0"
          StartActive = "0"
          MaximumState = "1"
          Formation = "0"
        }
        ai_battle_line:e =
        {
          origin = "0 0 0"
          ;desc = "Battle line"
          Active = "0"
          Strict = "1"
        }
        ai_goal_standoff:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Standoff"
          SearchType = "0"
          StartActive = "0"
          HintGroupChangeReaction = "1"
          Aggressiveness = "2"
          PlayerBattleline = "1"
          StayAtCover = "0"
          AbandonIfEnemyHides = "0"
        }
        ai_goal_police:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Police"
          policeradius = "512"
        }
        ai_goal_assault:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Assault"
          SearchType = "0"
          StartActive = "0"
          AssaultCue = "1"
        }
        ai_goal_actbusy:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Act Busy"
        }
        ai_goal_actbusy_queue:e =
        {
          origin = "0 0 0"
          ;desc = "AI Goal Act Busy Queue"
          mustreachfront = "0"
        }
        ai_changetarget:e =
        {
          origin = "0 0 0"
          ;desc = "Change Target"
        }
        ai_changehintgroup:e =
        {
          origin = "0 0 0"
          ;desc = "Change Hint Group"
          SearchType = "0"
          Radius = "0.0"
          hintlimiting = "0"
        }
        ai_script_conditions:e =
        {
          origin = "0 0 0"
          ;desc = "AI Script Conditions"
          StartDisabled = "1"
          MinimumState = "1"
          MaximumState = "3"
          ScriptStatus = "0"
          RequiredTime = "0"
          MinTimeout = "0"
          MaxTimeout = "0"
          ActorSeePlayer = "2"
          PlayerActorProximity = "0"
          PlayerActorFOV = "360"
          PlayerActorFOVTrueCone = "0"
          PlayerActorLOS = "2"
          ActorSeeTarget = "2"
          ActorTargetProximity = "0"
          PlayerTargetProximity = "0"
          PlayerTargetFOV = "360"
          PlayerTargetFOVTrueCone = "0"
          PlayerTargetLOS = "2"
          PlayerBlockingActor = "2"
        }
        ai_citizen_response_system:e =
        {
          origin = "0 0 0"
          ;desc = "If placed in the level, will manage citizens responses to p"
           "layer's actions."
        }
        ai_sound:e =
        {
          origin = "0 0 0"
          ;desc = "This entity makes sounds or smells that can be sensed by NP"
           "Cs, butnot by the player. This can be used to cause reactions in n"
           "earby NPCs.\n\nSound Types\n  Combat: Will cause most NPCs to beco"
           "me alert\n  World: Will cause most NPCs to become alert\n  Danger:"
           " Will cause most NPCs to move away from the position of the sound\"
           "n  Bullet Impact: \n  Carcass: \n  Meat: \n  Garbage: \n  Thumper:"
           " causes antlions to run away briefly\n  Readiness: (Low, Medium, H"
           "igh) Causes player companions that can hear this sound to change r"
           "eadiness\n"
          soundtype = "0"
        }
      }
      water_* entities.qtxfolder =
      {
        water_lod_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to control the LOD behavior of any water in "
           "the map. If your map has water, this entity is required."
          cheapwaterstartdistance = "1000"
          cheapwaterenddistance = "2000"
        }
      }
      monster_* entities.qtxfolder =
      {
        monster_generic:e =
        {
          origin = "0 0 0"
          ;desc = "Generic Script NPC"
          body = "0"
        }
      }
      generic_* entities.qtxfolder =
      {
        generic_actor:e =
        {
          origin = "0 0 0"
          ;desc = "Generic Actor NPC"
          hull_name = "Human"
        }
      }
      cycler_* entities.qtxfolder =
      {
        cycler_actor:e =
        {
          origin = "0 0 0"
          ;desc = "Actor Cycler"
        }
      }
      scripted_* entities.qtxfolder =
      {
        scripted_sentence:e =
        {
          origin = "0 0 0"
          ;desc = "Scripted Sentence"
          spawnflags = "21"
          delay = "0"
          radius = "512"
          refire = "3"
          volume = "10"
          attenuation = "0"
        }
        scripted_target:e =
        {
          origin = "0 0 0"
          ;desc = "Scripted Target"
          StartDisabled = "1"
          m_flRadius = "0"
          MoveSpeed = "5"
          PauseDuration = "0"
          EffectDuration = "2"
        }
        scripted_sequence:e =
        {
          origin = "0 0 0"
          ;desc = "Grabs an NPC and makes them play a specified set of animati"
           "ons. The NPC can be told to move to the scripted sequence position"
           " or can be told to play the script wherever they currently are. Mu"
           "ltiple scripted sequences of the same name will frame-synchronize "
           "in the action animation once all the actors have moved to position"
           ". This allows tight interaction between actors (one actor grabbing"
           " another, hitting them, etc.) The flow is as follows:\n\n1) Move t"
           "o position using the specified movement animation. If 'Move to Pos"
           "ition' is set to NONE, skip to step 2.\n2) If forced to wait for a"
           "nother actor to move to position, play the pre-action idle animati"
           "on, otherwise skip to step 3. If there is no pre-action idle speci"
           "fied, ACT_IDLE is used.\n3) Fire the OnBeginSequence output.\n4) P"
           "lay the action animation. If no action animation is specified, ski"
           "p to step 5.\n5) Play the post-action idle animation. If none is s"
           "pecified, skip to step 6. If the 'Loop in Post Idle' spawnflag is "
           "set, keep playing the post-action idle until the script is cancell"
           "ed. If no post-action idle animation is specified, ACT_IDLE is use"
           "d.\n6) Fire the OnEndSequence output.\n7) If a next script to play"
           " is specified, hand the NPC to the next script and repeat this pro"
           "cess for that script.\n\nThe MoveToPosition input runs steps 1 and"
           " 2, then waits while playing the pre-action idle animation until t"
           "he BeginSequence input is received."
        }
      }
      assault_* entities.qtxfolder =
      {
        assault_rallypoint:e =
        {
          origin = "0 0 0"
          ;desc = "(Assault) rally point"
          assaultdelay = "0"
          priority = "1"
        }
        assault_assaultpoint:e =
        {
          origin = "0 0 0"
          ;desc = "(Assault) assault point"
          assaulttimeout = "3.0"
          clearoncontact = "0"
          allowdiversion = "0"
          nevertimeout = "0"
        }
      }
      aiscripted_* entities.qtxfolder =
      {
        aiscripted_schedule:e =
        {
          origin = "0 0 0"
          ;desc = "Issues a command to an NPC without taking the NPC out of it"
           "s AI. This does not seize control of the NPC as a scripted_sequenc"
           "e does"
          m_flRadius = "0"
          graball = "0"
          forcestate = "0"
          schedule = "1"
          interruptability = "0"
        }
      }
      item_* entities.qtxfolder =
      {
        item_dynamic_resupply:e =
        {
          origin = "0 0 0"
          ;desc = "Dynamic item"
          spawnflags = "1"
          DesiredHealth = "1"
          DesiredArmor = "0.3"
          DesiredAmmoPistol = "0.5"
          DesiredAmmoSMG1 = "0.5"
          DesiredAmmoSMG1_Grenade = "0.1"
          DesiredAmmoAR2 = "0.4"
          DesiredAmmoBuckshot = "0.5"
          DesiredAmmoRPG_Round = "0"
          DesiredAmmoGrenade = "0.1"
          DesiredAmmo357 = "0"
          DesiredAmmoCrossbow = "0"
        }
        item_ammo_pistol:e =
        {
          origin = "0 0 0"
          ;desc = "Box of Pistol ammo"
        }
        item_ammo_pistol_large:e =
        {
          origin = "0 0 0"
          ;desc = "Large Box of Pistol ammo"
        }
        item_ammo_smg1:e =
        {
          origin = "0 0 0"
          ;desc = "Box of SMG1 ammo"
        }
        item_ammo_smg1_large:e =
        {
          origin = "0 0 0"
          ;desc = "Large Box of SMG1 ammo"
        }
        item_ammo_ar2:e =
        {
          origin = "0 0 0"
          ;desc = "Box of AR2 ammo"
        }
        item_ammo_ar2_large:e =
        {
          origin = "0 0 0"
          ;desc = "Large Box of AR2 ammo"
        }
        item_ammo_357:e =
        {
          origin = "0 0 0"
          ;desc = "Box of 357 ammo"
        }
        item_ammo_357_large:e =
        {
          origin = "0 0 0"
          ;desc = "Large Box of 357 ammo"
        }
        item_ammo_crossbow:e =
        {
          origin = "0 0 0"
          ;desc = "Box of Crossbow ammo"
        }
        item_box_buckshot:e =
        {
          origin = "0 0 0"
          ;desc = "Box Buckshot"
        }
        item_rpg_round:e =
        {
          origin = "0 0 0"
          ;desc = "RPG Round"
        }
        item_ammo_smg1_grenade:e =
        {
          origin = "0 0 0"
          ;desc = "SMG1 Grenade"
        }
        item_battery:e =
        {
          origin = "0 0 0"
          ;desc = "HEV battery"
        }
        item_healthkit:e =
        {
          origin = "0 0 0"
          ;desc = "Small Health Kit"
        }
        item_healthvial:e =
        {
          origin = "0 0 0"
          ;desc = "Personal Health Kit"
        }
        item_ammo_ar2_altfire:e =
        {
          origin = "0 0 0"
          ;desc = "AR2 Alt-fire Round"
        }
        item_suit:e =
        {
          origin = "0 0 0"
          ;desc = "HEV Suit"
        }
        item_ammo_crate:e =
        {
          origin = "0 0 0"
          ;desc = "Ammo Crate"
          AmmoType = "0"
        }
        item_item_crate:e =
        {
          origin = "0 0 0"
          ;desc = "Item Crate"
          CrateType = "0"
          ItemClass = "item_dynamic_resupply"
          ItemCount = "1"
        }
        item_healthcharger:e =
        {
          origin = "0 0 0"
          ;desc = "Health Charger"
        }
        item_suitcharger:e =
        {
          origin = "0 0 0"
          ;desc = "Battery recharger"
        }
      }
      weapon_* entities.qtxfolder =
      {
        weapon_crowbar:e =
        {
          origin = "0 0 0"
          ;desc = "Crowbar"
        }
        weapon_stunstick:e =
        {
          origin = "0 0 0"
          ;desc = "StunStick"
        }
        weapon_pistol:e =
        {
          origin = "0 0 0"
          ;desc = "9mm Pistol"
        }
        weapon_ar2:e =
        {
          origin = "0 0 0"
          ;desc = "Pulse Rifle"
        }
        weapon_rpg:e =
        {
          origin = "0 0 0"
          ;desc = "RPG"
        }
        weapon_smg1:e =
        {
          origin = "0 0 0"
          ;desc = "Submachine Gun"
        }
        weapon_357:e =
        {
          origin = "0 0 0"
          ;desc = "357 Magnum"
        }
        weapon_crossbow:e =
        {
          origin = "0 0 0"
          ;desc = "Crossbow"
        }
        weapon_shotgun:e =
        {
          origin = "0 0 0"
          ;desc = "Shotgun"
        }
        weapon_frag:e =
        {
          origin = "0 0 0"
          ;desc = "Grenade"
        }
        weapon_physgun:e =
        {
          origin = "0 0 0"
          ;desc = "Physics Gun (UNKNOWN)"
        }
        weapon_physcannon:e =
        {
          origin = "0 0 0"
          ;desc = "Gravity Gun"
        }
        weapon_extinguisher:e =
        {
          origin = "0 0 0"
          ;desc = "Fire Extinguisher (UNKNOWN)"
        }
        weapon_bugbait:e =
        {
          origin = "0 0 0"
          ;desc = "Bug bait (UNUSED in DM)"
        }
        weapon_alyxgun:e =
        {
          origin = "0 0 0"
          ;desc = "Alyx Gun (UNUSED in DM)"
        }
        weapon_annabelle:e =
        {
          origin = "0 0 0"
          ;desc = "Annabelle (Grigori ; UNUSED in DM)"
        }
        weapon_brickbat:e =
        {
          origin = "0 0 0"
          ;desc = "Brickbat (UNKNOWN)"
          BrickbatType = "Rock"
        }
        weapon_slam:e =
        {
          origin = "0 0 0"
          ;desc = "S.L.A.M."
        }
      }
      player_* entities.qtxfolder =
      {
        player_loadsaved:e =
        {
          origin = "0 0 0"
          ;desc = "Load Auto-Saved game"
          duration = "2"
          holdtime = "0"
          renderamt = "255"
          rendercolor = "0 0 0"
          loadtime = "0"
        }
        player_weaponstrip:e =
        {
          origin = "0 0 0"
          ;desc = "Strips player's weapons"
        }
        player_speedmod:e =
        {
          origin = "0 0 0"
          ;desc = "Speeds up or slows down player velocity over time (slow mo/"
           "fast forward)"
        }
      }
      combine_* entities.qtxfolder =
      {
        combine_mine:e =
        {
          origin = "0 0 0"
          ;desc = "Combine Land Mine"
          bounce = "1"
          LockSilently = "1"
          StartDisarmed = "0"
        }
      }
      vehicle_* entities.qtxfolder =
      {
        vehicle_viewcontroller:e =
        {
          origin = "0 0 0"
          ;desc = "Vehicle hack to control player view"
        }
      }
      script_* entities.qtxfolder =
      {
        script_tauremoval:e =
        {
          origin = "0 0 0"
          ;desc = "Script: Custom entity used to handle the tau removal sequen"
           "ce in seafloor."
        }
        script_intro:e =
        {
          origin = "0 0 0"
          ;desc = "Script: Custom entity used to handle the intro sequence."
        }
      }
    }
  }
  Entity Forms.fctx =
  {
    t_Angles:incl =
    {
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
    }
    t_Origin:incl =
    {
      origin: =
      {
        txt = "&"
        hint = "Origin (X Y Z)"
      }
    }
    t_Studiomodel:incl =
    {
      t_modelselect = !
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Disable Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      lightingoriginhack: =
      {
        txt = "&"
        hint = "Lighting Origin Hack"
      }
      input#Skin: =
      {
        txt = "&"
        hint = "Changes the model skin to the specified number."
      }
      input#SetLightingOriginHack: =
      {
        txt = "&"
        hint = "Sets the info_lighting_relative for the studiomodel. Use a nul"
         "l string to deactivate the use of specific lighting origins."
      }
      input#DisableShadow: =
      {
        txt = "&"
        hint = "Turn shadow off."
      }
      input#EnableShadow: =
      {
        txt = "&"
        hint = "Turn shadow on."
      }
      output#OnIgnite: =
      {
        txt = "&"
        hint = "Fired when this object catches fire."
      }
    }
    t_BasePlat:incl =
    {
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the platform's state."
      }
      input#GoUp: =
      {
        txt = "&"
        hint = "Tells the platform to go up."
      }
      input#GoDown: =
      {
        txt = "&"
        hint = "Tells the platform to go down."
      }
    }
    t_Targetname:incl =
    {
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world."
      }
      input#KillHierarchy: =
      {
        txt = "&"
        hint = "Removes this entity and all its children from the world."
      }
      input#AddOutput: =
      {
        txt = "&"
        hint = "Adds an entity I/O connection to this entity. Format: <output "
         "name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fir"
         "e (-1 == infinite)>. Very dangerous, use with care."
      }
      input#FireUser1: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser1 output to be fired."
      }
      input#FireUser2: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser2 output to be fired."
      }
      input#FireUser3: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser3 output to be fired."
      }
      input#FireUser4: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser4 output to be fired."
      }
      output#OnUser1: =
      {
        txt = "&"
        hint = "Fired in response to FireUser1 input."
      }
      output#OnUser2: =
      {
        txt = "&"
        hint = "Fired in response to FireUser2 input."
      }
      output#OnUser3: =
      {
        txt = "&"
        hint = "Fired in response to FireUser3 input."
      }
      output#OnUser4: =
      {
        txt = "&"
        hint = "Fired in response to FireUser4 input."
      }
    }
    t_Parentname:incl =
    {
      parentname: =
      {
        txt = "&"
        hint = "Parent"
      }
      input#SetParent: =
      {
        txt = "&"
        hint = "Changes the entity's parent in the movement hierarchy."
      }
      input#SetParentAttachment: =
      {
        txt = "&"
        hint = "Change this entity to attach to a specific attachment point on"
         " it's parent. Entities must be parented before being sent this input"
         ". The parameter passed in should be the name of the attachment."
      }
      input#ClearParent: =
      {
        txt = "&"
        hint = "Removes this entity from the the movement hierarchy, leaving i"
         "t free to move independently."
      }
    }
    t_BaseBrush:incl =
    {
      input#SetTextureIndex: =
      {
        txt = "&"
        hint = "Used by HL1Port. Sets the brush texture index. Use a material_"
         "modify_control entity instead."
      }
      input#IncrementTextureIndex: =
      {
        txt = "&"
        hint = "Used by HL1Port. Increments the brush texture index. Use a mat"
         "erial_modify_control entity instead."
      }
    }
    t_EnableDisable:incl =
    {
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this entity."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this entity."
      }
    }
    t_RenderFxChoices:incl =
    {
      renderfx: =
      {
        txt = "&"
        hint = "Render FX"
        typ = "C"
        items = "Normal"$0D"Slow Pulse"$0D"Fast Pulse"$0D"Slow Wide Pulse"$0D"F"
         "ast Wide Pulse"$0D"Slow Strobe"$0D"Fast Strobe"$0D"Faster Strobe"$0D
         "Slow Flicker"$0D"Fast Flicker"$0D"Slow Fade Away"$0D"Fast Fade Away"$0D
         "Slow Become Solid"$0D"Fast Become Solid"$0D"Constant Glow"$0D"Distor"
         "t"$0D"Hologram (Distort + fade)"$0D"Cull By Distance (TEST)"$0D"Spot"
         "light FX"$0D"Fade Near"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"9"$0D"10"$0D"11"$0D"12"$0D"13"$0D
         "5"$0D"6"$0D"7"$0D"8"$0D"14"$0D"15"$0D"16"$0D"23"$0D"24"$0D"26"
      }
    }
    t_Shadow:incl =
    {
      disableshadows: =
      {
        txt = "&"
        hint = "Disable shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#DisableShadow: =
      {
        txt = "&"
        hint = "Turn shadow off."
      }
      input#EnableShadow: =
      {
        txt = "&"
        hint = "Turn shadow on."
      }
    }
    t_RenderFields:incl =
    {
      t_RenderFxChoices = !
      rendermode: =
      {
        txt = "&"
        hint = "Render Mode"
        typ = "C"
        items = "Normal"$0D"Color"$0D"Texture"$0D"Glow"$0D"Solid"$0D"Additive"$0D
         "Additive Fractional Frame"$0D"World Space Glow"$0D"Dont Render"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"7"$0D"9"$0D"10"
      }
      renderamt: =
      {
        txt = "&"
        hint = "FX Amount (0 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "FX Color (R G B)"
      }
      disablereceiveshadows: =
      {
        txt = "&"
        hint = "Disable Receiving Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    t_DXLevelChoice:incl =
    {
      mindxlevel: =
      {
        txt = "&"
        hint = "Minimum DX Level"
        typ = "C"
        items = "default (lowest)"$0D"dx7"
        values = "0"$0D"70"
      }
      maxdxlevel: =
      {
        txt = "&"
        hint = "Maximum DX Level"
        typ = "C"
        items = "default (highest)"$0D"dx6"
        values = "0"$0D"60"
      }
    }
    t_Inputfilter:incl =
    {
      InputFilter: =
      {
        txt = "&"
        hint = "Input Filter"
        typ = "C"
        items = "Allow all inputs"$0D"Ignore Touch/Untouch"$0D"Ignore Use"$0D"I"
         "gnore All"
        values = "0"$0D"8"$0D"16"$0D"32"
      }
    }
    t_Global:incl =
    {
      globalname: =
      {
        txt = "&"
        hint = "Global Entity Name"
      }
    }
    t_DamageFilter:incl =
    {
      damagefilter: =
      {
        txt = "&"
        hint = "Damage Filter"
      }
      input#SetDamageFilter: =
      {
        txt = "&"
        hint = "Sets the entity to use as damage filter. Pass in an empty stri"
         "ng to clear the damage filter."
      }
    }
    t_ResponseContext:incl =
    {
      input#AddContext: =
      {
        txt = "&"
        hint = "Adds a context to this entity's list of response contexts. The"
         " format should be 'key:value'."
      }
      input#RemoveContext: =
      {
        txt = "&"
        hint = "Remove a context from this entity's list of response contexts."
         " The name should match the 'key' of a previously added context."
      }
      input#ClearContext: =
      {
        txt = "&"
        hint = "Removes all contexts in this entity's list of response context"
         "s."
      }
      ResponseContext: =
      {
        txt = "&"
        hint = "Response Contexts"
      }
    }
    t_Breakable:incl =
    {
      t_Targetname = !
      t_DamageFilter = !
      t_Shadow = !
      ExplodeDamage: =
      {
        txt = "&"
        hint = "Explosion Damage"
      }
      ExplodeRadius: =
      {
        txt = "&"
        hint = "Explosion Radius"
      }
      PerformanceMode: =
      {
        txt = "&"
        hint = "Performance Mode"
        typ = "C"
        items = "Normal"$0D"Limit Gibs"$0D"Full Gibs on All Platforms"
        values = "0"$0D"1"$0D"2"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Breaks the breakable."
      }
      input#SetHealth: =
      {
        txt = "&"
        hint = "Sets a new value for the breakable's health. If the breakable'"
         "s health reaches zero it will break."
      }
      input#AddHealth: =
      {
        txt = "&"
        hint = "Adds health to the breakable. If the breakable's health reache"
         "s zero it will break."
      }
      input#RemoveHealth: =
      {
        txt = "&"
        hint = "Removes health from the breakable. If the breakable's health r"
         "eaches zero it will break."
      }
      input#EnablePhyscannonPickup: =
      {
        txt = "&"
        hint = "Makes the breakable able to picked up by the physcannon."
      }
      input#DisablePhyscannonPickup: =
      {
        txt = "&"
        hint = "Makes the breakable not able to picked up by the physcannon."
      }
      output#OnBreak: =
      {
        txt = "&"
        hint = "Fired when this breakable breaks."
      }
      output#OnHealthChanged: =
      {
        txt = "&"
        hint = "Fired when the health of this breakable changes, passing the n"
         "ew value of health as a percentage of max health, from [0..1]."
      }
      output#OnPhysCannonDetach: =
      {
        txt = "&"
        hint = "Fired when the physcannon has ripped this breakable off of the"
         " wall. Only fired if ACT_PHYSCANNON_DETACH is defined in the model t"
         "his breakable is using."
      }
    }
    t_BreakableBrush:incl =
    {
      t_Breakable = !
      t_Parentname = !
      t_Global = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Only Break on Trigger"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Break on Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Break on Pressure"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Break immediately on Physics"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Don't take physics damage"
      }
      propdata: =
      {
        txt = "&"
        hint = "Prop Data"
        typ = "C"
        items = "None"$0D"Wooden.Tiny"$0D"Wooden.Small"$0D"Wooden.Medium"$0D"W"
         "ooden.Large"$0D"Wooden.Huge"$0D"Metal.Small"$0D"Metal.Medium"$0D"Met"
         "al.Large"$0D"Cardboard.Small"$0D"Cardboard.Medium"$0D"Cardboard.Larg"
         "e"$0D"Stone.Small"$0D"Stone.Medium"$0D"Stone.Large"$0D"Stone.Huge"$0D
         "Glass.Small"$0D"Plastic.Small"$0D"Plastic.Medium"$0D"Plastic.Large"$0D
         "Pottery.Small"$0D"Pottery.Medium"$0D"Pottery.Large"$0D"Pottery.Huge"$0D
         "Glass.Window"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"
      }
      health: =
      {
        txt = "&"
        hint = "Strength"
      }
      material: =
      {
        txt = "&"
        hint = "Material Type"
        typ = "C"
        items = "Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"CinderBlock"$0D"Ceilin"
         "g Tile"$0D"Computer"$0D"Unbreakable Glass"$0D"Rocks"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      explosion: =
      {
        txt = "&"
        hint = "Gibs Direction"
        typ = "C"
        items = "Random"$0D"Relative to Attack"$0D"Use Precise Gib Dir"
        values = "0"$0D"1"$0D"2"
      }
      gibdir: =
      {
        txt = "&"
        hint = "Precise Gib Direction"
      }
      nodamageforces: =
      {
        txt = "&"
        hint = "Damaging it Doesn't Push It"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity applies physics forces to it."
      }
      input#DisableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity does *not* apply physics forces to it."
      }
      gibmodel: =
      {
        txt = "&"
        hint = "Gib Model"
      }
      spawnobject: =
      {
        txt = "&"
        hint = "Spawn On Break"
        typ = "C"
        items = "item_battery"$0D"item_healthkit"$0D"item_ammo_pistol"$0D"item"
         "_ammo_pistol_large"$0D"item_ammo_smg1"$0D"item_ammo_smg1_large"$0D"i"
         "tem_ammo_ar2"$0D"item_ammo_ar2_large"$0D"item_box_buckshot"$0D"item_"
         "flare_round"$0D"item_box_flare_rounds"$0D"item_ml_grenade"$0D"item_s"
         "mg1_grenade"$0D"item_box_sniper_rounds"$0D"unused1"$0D"weapon_stunst"
         "ick"$0D"weapon_ar1"$0D"weapon_ar2"$0D"unused2"$0D"weapon_ml"$0D"weap"
         "on_smg1"$0D"weapon_smg2"$0D"weapon_slam"$0D"weapon_shotgun"$0D"weapo"
         "n_molotov"$0D"item_dynamic_resupply"
        values = "1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"10"$0D
         "11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D"20"$0D
         "21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"
      }
      explodemagnitude: =
      {
        txt = "&"
        hint = "Explode Magnitude"
      }
      pressuredelay: =
      {
        txt = "&"
        hint = "Pressure Delay"
      }
    }
    t_BreakableProp:incl =
    {
      t_Breakable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Break on Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Break on Pressure"
      }
      pressuredelay: =
      {
        txt = "&"
        hint = "Pressure Delay"
      }
    }
    t_BaseNPC:incl =
    {
      t_Targetname = !
      t_Angles = !
      t_RenderFields = !
      t_DamageFilter = !
      t_ResponseContext = !
      t_Shadow = !
      target: =
      {
        txt = "&"
        hint = "Target Path Corner"
      }
      squadname: =
      {
        txt = "&"
        hint = "Squad Name"
      }
      hintgroup: =
      {
        txt = "&"
        hint = "Hint Group"
      }
      hintlimiting: =
      {
        txt = "&"
        hint = "Hint Limit Nav"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Wait Till Seen"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Gag (No IDLE sounds until angry)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Fall to ground (unchecked means *teleport* to ground)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Drop Healthkit"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Efficient - Don't acquire enemies or avoid obstacles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Wait For Script"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Long Visibility/Shoot"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Fade Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Think outside PVS"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Template NPC (used by npc_maker, will not spawn)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Do Alternate collision for this NPC (player avoidance)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Don't drop weapons"
      }
      sleepstate: =
      {
        txt = "&"
        hint = "Sleep State"
        typ = "C"
        items = "None"$0D"Waiting for threat"$0D"Waiting for PVS"$0D"Waiting f"
         "or input"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      wakeradius: =
      {
        txt = "&"
        hint = "Wake Radius"
      }
      wakesquad: =
      {
        txt = "&"
        hint = "Wake Squad"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      lightingoriginhack: =
      {
        txt = "&"
        hint = "Lighting Origin Hack"
      }
      input#SetLightingOriginHack: =
      {
        txt = "&"
        hint = "Sets the info_lighting_relative for the studiomodel. Use a nul"
         "l string to deactivate the use of specific lighting origins."
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when this NPC takes damage."
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fired when this NPC is killed."
      }
      output#OnHalfHealth: =
      {
        txt = "&"
        hint = "Fired when this NPC reaches half of its maximum health."
      }
      output#OnHearWorld: =
      {
        txt = "&"
        hint = "Fired when this NPC hears a sound (other than combat or the pl"
         "ayer)."
      }
      output#OnHearPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC hears the player."
      }
      output#OnHearCombat: =
      {
        txt = "&"
        hint = "Fired when this NPC hears combat sounds."
      }
      output#OnFoundEnemy: =
      {
        txt = "&"
        hint = "Fired when this NPC establishes line of sight to it's enemy (o"
         "utputs entity)."
      }
      output#OnLostEnemyLOS: =
      {
        txt = "&"
        hint = "Fired when this NPC loses line of sight to it's enemy."
      }
      output#OnLostEnemy: =
      {
        txt = "&"
        hint = "Fired when this NPC loses it's enemy. Usually due to the enemy"
         " being killed/removed, or because this NPC has selected a newer, mor"
         "e dangerous enemy."
      }
      output#OnFoundPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC establishes line of sight to it's enemy, a"
         "nd that enemy is a player (outputs player entity)."
      }
      output#OnLostPlayerLOS: =
      {
        txt = "&"
        hint = "Fired when this NPC loses line of sight to it's enemy, and tha"
         "t enemy is a player."
      }
      output#OnLostPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC loses it's enemy, and that enemy was a pla"
         "yer. Usually due to the enemy being killed/removed, or because this "
         "NPC has selected a newer, more dangerous enemy."
      }
      output#OnDamagedByPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC is hurt by a player."
      }
      output#OnDamagedByPlayerSquad: =
      {
        txt = "&"
        hint = "Fired when this NPC is hurt by a player OR by one of the playe"
         "r's squadmates."
      }
      output#OnDenyCommanderUse: =
      {
        txt = "&"
        hint = "Fired when this NPC has refused to join the player's squad."
      }
      output#OnWake: =
      {
        txt = "&"
        hint = "Fired when this NPC comes out of a sleep state."
      }
      input#SetRelationship: =
      {
        txt = "&"
        hint = "Changes this entity's relationship with another entity or clas"
         "s. Format: <entityname/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
      }
      input#SetHealth: =
      {
        txt = "&"
        hint = "Set this NPC's health."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "HACK: Sets this NPC's body group (from 0 - n). You'd better kn"
         "ow what you are doing!"
      }
      input#physdamagescale: =
      {
        txt = "&"
        hint = "Sets the value that scales damage energy when this character i"
         "s hit by a physics object. NOTE: 0 means this feature is disabled fo"
         "r backwards compatibility."
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Break, smash into pieces"
      }
      input#StartScripting: =
      {
        txt = "&"
        hint = "Enter scripting state. In this state, NPCs ignore a variety of"
         " stimulus that would make them break out of their scripts: They igno"
         "re danger sounds, ignore +USE, don't idle speak or respond to other "
         "NPC's idle speech, and so on."
      }
      input#StopScripting: =
      {
        txt = "&"
        hint = "Exit scripting state."
      }
      input#Assault: =
      {
        txt = "&"
        hint = "Start an assault. Parameter passed in should be the name of th"
         "e rally point."
      }
      input#SetSquad: =
      {
        txt = "&"
        hint = "Set the name of this NPC's squad. It will be removed from any "
         "existing squad automatically. Leaving the parameter blank will remov"
         "e the NPC from any existing squad."
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wakes up the NPC if it is sleeping."
      }
      input#ForgetEntity: =
      {
        txt = "&"
        hint = "Clears out the NPC's knowledge of a named entity."
      }
      input#GagEnable: =
      {
        txt = "&"
        hint = "Turn on the NPC Gag flag."
      }
      input#GagDisable: =
      {
        txt = "&"
        hint = "Turn off the NPC Gag flag."
      }
      input#IgnoreDangerSounds: =
      {
        txt = "&"
        hint = "Ignore danger sounds for the specified number of seconds."
      }
    }
    info_npc_spawn_destination:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      ReuseDelay: =
      {
        txt = "&"
        hint = "Reuse Delay"
      }
      RenameNPC: =
      {
        txt = "&"
        hint = "New NPC Name"
      }
      output#OnSpawnNPC: =
      {
        txt = "&"
        hint = "Fired when an NPC spawns at this destination."
      }
    }
    t_BaseNPCMaker:incl =
    {
      t_Targetname = !
      t_Angles = !
      t_EnableDisable = !
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Fade Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Infinite Children"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Do Not Drop"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Don't Spawn While Visible"
      }
      MaxNPCCount: =
      {
        txt = "&"
        hint = "Num. of NPCs"
      }
      SpawnFrequency: =
      {
        txt = "&"
        hint = "Frequency"
      }
      MaxLiveChildren: =
      {
        txt = "&"
        hint = "Max Live NPCs"
      }
      output#OnSpawnNPC: =
      {
        txt = "&"
        hint = "Fired when an NPC is spawned. The activator is the NPC, and th"
         "e string is the name of the NPC."
      }
      output#OnAllSpawned: =
      {
        txt = "&"
        hint = "Fired when the spawned is exhausted (all children have been sp"
         "awned)."
      }
      output#OnAllSpawnedDead: =
      {
        txt = "&"
        hint = "Fired when the spawner is exhausted (all children have been sp"
         "awned) and all spawned children have died."
      }
      input#Spawn: =
      {
        txt = "&"
        hint = "Spawns an NPC."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the spawner enabled/disabled state."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enables the spawner."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disables the spawner."
      }
      input#AddMaxChildren: =
      {
        txt = "&"
        hint = "Adds to the number of NPCs that can spawn before the spawner i"
         "s exhausted. If an exhausted spawner is given some children to spawn"
         ", it still wont begin spawning until it is re-enabled with the Enabl"
         "e input."
      }
      input#SetMaxChildren: =
      {
        txt = "&"
        hint = "Sets the number of NPCs that can spawn before the spawner is e"
         "xhausted. If an exhausted spawner is given some children to spawn, i"
         "t still wont begin spawning until it is re-enabled with the Enable i"
         "nput."
      }
      input#SetMaxLiveChildren: =
      {
        txt = "&"
        hint = "Sets the maximum number of NPCs that can be alive at any one t"
         "ime from this spawner."
      }
      input#SetSpawnFrequency: =
      {
        txt = "&"
        hint = "Sets how often (in seconds) a new NPC will be spawned."
      }
    }
    npc_template_maker:form =
    {
      t_BaseNPCMaker = !
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Always use radius spawn"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Don't preload template models"
      }
      TemplateName: =
      {
        txt = "&"
        hint = "Name of template NPC"
      }
      Radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      DestinationGroup: =
      {
        txt = "&"
        hint = "Name of Destination Group"
      }
      CriterionVisibility: =
      {
        txt = "&"
        hint = "Dest. Criterion: Visible to player?"
        typ = "C"
        items = "Yes"$0D"No"$0D"Don't Care"
        values = "0"$0D"1"$0D"2"
      }
      CriterionDistance: =
      {
        txt = "&"
        hint = "Dest. Criterion: Distance to player?"
        typ = "C"
        items = "Nearest"$0D"Farthest"$0D"Don't Care"
        values = "0"$0D"1"$0D"2"
      }
      input#SpawnNPCInRadius: =
      {
        txt = "&"
        hint = "Spawn an NPC somewhere within the maker's radius."
      }
      input#SpawnNPCInLine: =
      {
        txt = "&"
        hint = "Spawn an NPC somewhere within a line behind the maker."
      }
      input#ChangeDestinationGroup: =
      {
        txt = "&"
        hint = "Switch to a different set of Destination entities."
      }
    }
    t_BaseHelicopter:incl =
    {
      t_BaseNPC = !
      InitialSpeed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      target: =
      {
        txt = "&"
        hint = "Target path_track"
      }
      input#MoveTopSpeed: =
      {
        txt = "&"
        hint = "The helicopter will immediately move at top speed toward its c"
         "urrent goal, or in its current orientation if it's on top of its goa"
         "l."
      }
      input#ChangePathCorner: =
      {
        txt = "&"
        hint = "Tell the helicopter to move to a path corner on a new path."
      }
      input#SelfDestruct: =
      {
        txt = "&"
        hint = "Self Destruct."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activate. Use to wake up a helicopter that spawned with the 'A"
         "wait Input' spawnflag on."
      }
      input#SetTrack: =
      {
        txt = "&"
        hint = "Set a track for the helicopter to adhere to. The helicopter wi"
         "ll do nothing if he's on the same path, and will move to the closest"
         " point on the specified track if he's on a different path."
      }
      input#FlyToSpecificTrackViaPath: =
      {
        txt = "&"
        hint = "The helicopter will first fly to the closest point on the path"
         " if he's on a different path. Then he'll fly along the path to the s"
         "pecified track point."
      }
      input#StartPatrol: =
      {
        txt = "&"
        hint = "Start patrolling back and forth along the current track."
      }
      input#StopPatrol: =
      {
        txt = "&"
        hint = "Stop patrolling back and forth along the track. This will caus"
         "e the helicopter to come to rest at the track which he's currently f"
         "lying toward."
      }
      input#ChooseFarthestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path furthest "
         "from the enemy, but still in firing range."
      }
      input#ChooseNearestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path nearest f"
         "rom the enemy."
      }
      input#StartBreakableMovement: =
      {
        txt = "&"
        hint = "The helicopter is now allowed to disobey direct commands to go"
         " to particular points if he senses an enemy. He will move to the clo"
         "sest point (or farthest point, if ChooseFarthestPathPoint is used), "
         "on the path if he senses an enemy."
      }
      input#StopBreakableMovement: =
      {
        txt = "&"
        hint = "The helicopter can not disobey direct commands. He will contin"
         "ue to fly along his patrol path or to his specified target even if h"
         "e senses an enemy."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No Rotorwash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Await Input"
      }
    }
    t_PlayerClass:incl =
    {
      t_player_size = !
    }
    t_Light:incl =
    {
      _light: =
      {
        txt = "&"
        hint = "Brightness"
      }
      style: =
      {
        txt = "&"
        hint = "Appearance"
        typ = "C"
        items = "Normal"$0D"Fluorescent flicker"$0D"Slow, strong pulse"$0D"Slo"
         "w pulse, noblack"$0D"Gentle pulse"$0D"Flicker A"$0D"Flicker B"$0D"Ca"
         "ndle A"$0D"Candle B"$0D"Candle C"$0D"Fast strobe"$0D"Slow strobe"
        values = "0"$0D"10"$0D"2"$0D"11"$0D"5"$0D"1"$0D"6"$0D"3"$0D"7"$0D"8"$0D
         "4"$0D"9"
      }
      pattern: =
      {
        txt = "&"
        hint = "Custom Appearance"
      }
      _constant_attn: =
      {
        txt = "&"
        hint = "Constant"
      }
      _linear_attn: =
      {
        txt = "&"
        hint = "Linear"
      }
      _quadratic_attn: =
      {
        txt = "&"
        hint = "Quadratic"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the light on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "The the light off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the light's current state."
      }
      input#SetPattern: =
      {
        txt = "&"
        hint = "Set a custom pattern of light brightness for this light. Patte"
         "rn format is a string of characters, where 'a' is total darkness, 'z"
         "' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dar"
         "k to light."
      }
      input#FadeToPattern: =
      {
        txt = "&"
        hint = "Fades from first value in old pattern, to first value in the n"
         "ew given pattern. Pattern format is a string of characters, where 'a"
         "' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a "
         "steppy fade in from dark to light."
      }
    }
    t_Node:incl =
    {
      nodeid: =
      {
        txt = "&"
        hint = "Node ID"
      }
    }
    t_HintNode:incl =
    {
      t_Node = !
      hinttype: =
      {
        txt = "&"
        hint = "Hint"
        typ = "C"
        items = "None"$0D"World: Window"$0D"World: Act Busy Hint"$0D"World: Vi"
         "sually Interesting"$0D"World: Visually Interesting (Don't aim at)"$0D
         "World: Inhibit Combine Mines within 15 feet"$0D"Crouch Cover Medium"$0D
         "Crouch Cover Low"$0D"Waste Scanner Spawn"$0D"Entrance / Exit Pinch"$0D
         "Enemy Disadvantage Point"$0D"Health Kit"$0D"Urban: Shelter"$0D"Antli"
         "on: Burrow Point"$0D"Antlion: Thumper Flee Point"$0D"Headcrab: Burro"
         "w Point"$0D"Roller: Patrol Point"$0D"Roller: Cleanup Spot"$0D"Crow: "
         "Fly to point"$0D"Crow: Perch point"$0D"TF2 Bug: Patrol point"$0D"Fol"
         "lower: Wait point"$0D"Override jump permission"$0D"Player squad tran"
         "sition point"$0D"NPC exit point"$0D"Strider node"$0D"HL1 World: Mach"
         "inery"$0D"HL1 World: Blinking Light"$0D"HL1 World: Human Blood"$0D"H"
         "L1 World: Alien Blood"$0D"CS Hostage: Escape Point"
        values = "0"$0D"2"$0D"12"$0D"13"$0D"14"$0D"15"$0D"100"$0D"101"$0D"102"$0D
         "103"$0D"105"$0D"106"$0D"204"$0D"400"$0D"401"$0D"450"$0D"500"$0D"501"$0D
         "700"$0D"701"$0D"800"$0D"900"$0D"901"$0D"902"$0D"903"$0D"904"$0D"1000"
         $0D"1001"$0D"1002"$0D"1003"$0D"1100"
      }
      hintactivity: =
      {
        txt = "&"
        hint = "Hint Activity"
      }
      nodeFOV: =
      {
        txt = "&"
        hint = "Node FOV"
        typ = "C"
        items = "180 Degrees"$0D"360 Degrees"
        values = "180"$0D"360"
      }
      StartHintDisabled: =
      {
        txt = "&"
        hint = "Start Hint Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Group: =
      {
        txt = "&"
        hint = "Hint Group"
      }
      TargetNode: =
      {
        txt = "&"
        hint = "Target node"
      }
      IgnoreFacing: =
      {
        txt = "&"
        hint = "Ignore Facing"
        typ = "C"
        items = "No"$0D"Yes"$0D"Default"
        values = "0"$0D"1"$0D"2"
      }
      MinimumState: =
      {
        txt = "&"
        hint = "Minimum State"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      MaximumState: =
      {
        txt = "&"
        hint = "Maximum State"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      input#EnableHint: =
      {
        txt = "&"
        hint = "Enable hint."
      }
      input#DisableHint: =
      {
        txt = "&"
        hint = "Disable hint."
      }
    }
    t_TriggerOnce:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_EnableDisable = !
      t_Global = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Clients"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "NPCs"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Pushables"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Physics Objects"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Only player ally NPCs"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Only clients in vehicles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Everything"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Only clients *not* in vehicles"
      }
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles this trigger between enabled and disabled states."
      }
      output#OnStartTouch: =
      {
        txt = "&"
        hint = "Fired when an entity starts touching this trigger. The touchin"
         "g entity must pass this trigger's filters to cause this output to fi"
         "re."
      }
    }
    t_Trigger:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_EnableDisable = !
      t_TriggerOnce = !
      output#OnEndTouch: =
      {
        txt = "&"
        hint = "Fired when an entity stops touching this trigger. Only entitie"
         "s that passed this trigger's filters will cause this output to fire."
      }
      output#OnEndTouchAll: =
      {
        txt = "&"
        hint = "Fires when an entity stops touching this trigger, and no other"
         " entities are touching it. Only entities that passed this trigger's "
         "filters are considered."
      }
    }
    t_worldbase:incl =
    {
      message: =
      {
        txt = "&"
        hint = "Map Description / Title"
      }
      skyname: =
      {
        txt = "&"
        hint = "SkyBox Texture Name"
      }
      chaptertitle: =
      {
        txt = "&"
        hint = "Chapter Title Message"
      }
      startdark: =
      {
        txt = "&"
        hint = "Level Fade In"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      gametitle: =
      {
        txt = "&"
        hint = "Display Game Title"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      newunit: =
      {
        txt = "&"
        hint = "New Level Unit"
        typ = "C"
        items = "No, keep current"$0D"Yes, clear previous levels"
        values = "0"$0D"1"
      }
      maxoccludeearea: =
      {
        txt = "&"
        hint = "Max occludee area"
      }
      minoccluderarea: =
      {
        txt = "&"
        hint = "Min occluder area"
      }
      maxpropscreenwidth: =
      {
        txt = "&"
        hint = "Start Fade Pixels"
      }
      minpropscreenwidth: =
      {
        txt = "&"
        hint = "End Fade Pixels"
      }
    }
    worldspawn:form =
    {
      t_Targetname = !
      t_worldbase = !
      t_ResponseContext = !
    }
    ambient_generic:form =
    {
      t_Targetname = !
      message: =
      {
        txt = "&"
        hint = "Sound Name"
      }
      health: =
      {
        txt = "&"
        hint = "Volume"
      }
      preset: =
      {
        txt = "&"
        hint = "Dynamic Presets"
        typ = "C"
        items = "None"$0D"Huge Machine"$0D"Big Machine"$0D"Machine"$0D"Slow Fa"
         "de in"$0D"Fade in"$0D"Quick Fade in"$0D"Slow Pulse"$0D"Pulse"$0D"Qui"
         "ck pulse"$0D"Slow Oscillator"$0D"Oscillator"$0D"Quick Oscillator"$0D
         "Grunge pitch"$0D"Very low pitch"$0D"Low pitch"$0D"High pitch"$0D"Ver"
         "y high pitch"$0D"Screaming pitch"$0D"Oscillate spinup/down"$0D"Pulse"
         " spinup/down"$0D"Random pitch"$0D"Random pitch fast"$0D"Incremental "
         "Spinup"$0D"Alien"$0D"Bizzare"$0D"Planet X"$0D"Haunted"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"$0D"27"
      }
      volstart: =
      {
        txt = "&"
        hint = "Start Volume"
      }
      fadein: =
      {
        txt = "&"
        hint = "Fade in time (0-100)"
      }
      fadeout: =
      {
        txt = "&"
        hint = "Fade out time (0-100)"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      pitchstart: =
      {
        txt = "&"
        hint = "Start Pitch"
      }
      spinup: =
      {
        txt = "&"
        hint = "Spin up time (0-100)"
      }
      spindown: =
      {
        txt = "&"
        hint = "Spin down time (0-100)"
      }
      lfotype: =
      {
        txt = "&"
        hint = "LFO type 0)off 1)sqr 2)tri 3)rnd"
      }
      lforate: =
      {
        txt = "&"
        hint = "LFO rate (0-1000)"
      }
      lfomodpitch: =
      {
        txt = "&"
        hint = "LFO mod pitch (0-100)"
      }
      lfomodvol: =
      {
        txt = "&"
        hint = "LFO mod vol (0-100)"
      }
      cspinup: =
      {
        txt = "&"
        hint = "Incremental Spinup Count"
      }
      radius: =
      {
        txt = "&"
        hint = "Max Audible Distance"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Play everywhere"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Start Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Is NOT Looped"
      }
      SourceEntityName: =
      {
        txt = "&"
        hint = "SourceEntityName"
      }
      input#Pitch: =
      {
        txt = "&"
        hint = "Sets the sound pitch, expressed as a range from 1 to 255, wher"
         "e 100 is the sound's default pitch."
      }
      input#PlaySound: =
      {
        txt = "&"
        hint = "Starts the sound."
      }
      input#StopSound: =
      {
        txt = "&"
        hint = "Stops the sound if it is playing."
      }
      input#ToggleSound: =
      {
        txt = "&"
        hint = "Toggles the sound between playing and stopping."
      }
      input#Volume: =
      {
        txt = "&"
        hint = "Sets the sound volume, expressed as a range from 0 to 10, wher"
         "e 10 is the loudest."
      }
    }
    func_lod:form =
    {
      t_Targetname = !
      DisappearDist: =
      {
        txt = "&"
        hint = "Disappear Distance"
      }
      Solid: =
      {
        txt = "&"
        hint = "Solid"
        typ = "C"
        items = "Solid"$0D"Nonsolid"
        values = "0"$0D"1"
      }
    }
    env_zoom:form =
    {
      t_Targetname = !
      Rate: =
      {
        txt = "&"
        hint = "Seconds to reach target"
      }
      FOV: =
      {
        txt = "&"
        hint = "Target FOV"
      }
      input#Zoom: =
      {
        txt = "&"
        hint = "Start controlling the player's FOV."
      }
      input#UnZoom: =
      {
        txt = "&"
        hint = "Stop controlling the player's FOV."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Allow Suit Zoom"
      }
    }
    env_screenoverlay:form =
    {
      t_Targetname = !
      OverlayName1: =
      {
        txt = "&"
        hint = "Overlay Name 1"
      }
      OverlayTime1: =
      {
        txt = "&"
        hint = "Overlay Duration 1"
      }
      OverlayName2: =
      {
        txt = "&"
        hint = "Overlay Name 2"
      }
      OverlayTime2: =
      {
        txt = "&"
        hint = "Overlay Duration 2"
      }
      OverlayName3: =
      {
        txt = "&"
        hint = "Overlay Name 3"
      }
      OverlayTime3: =
      {
        txt = "&"
        hint = "Overlay Duration 3"
      }
      OverlayName4: =
      {
        txt = "&"
        hint = "Overlay Name 4"
      }
      OverlayTime4: =
      {
        txt = "&"
        hint = "Overlay Duration 4"
      }
      OverlayName5: =
      {
        txt = "&"
        hint = "Overlay Name 5"
      }
      OverlayTime5: =
      {
        txt = "&"
        hint = "Overlay Duration 5"
      }
      OverlayName6: =
      {
        txt = "&"
        hint = "Overlay Name 6"
      }
      OverlayTime6: =
      {
        txt = "&"
        hint = "Overlay Duration 6"
      }
      OverlayName7: =
      {
        txt = "&"
        hint = "Overlay Name 7"
      }
      OverlayTime7: =
      {
        txt = "&"
        hint = "Overlay Duration 7"
      }
      OverlayName8: =
      {
        txt = "&"
        hint = "Overlay Name 8"
      }
      OverlayTime8: =
      {
        txt = "&"
        hint = "Overlay Duration 8"
      }
      OverlayName9: =
      {
        txt = "&"
        hint = "Overlay Name 9"
      }
      OverlayTime9: =
      {
        txt = "&"
        hint = "Overlay Duration 9"
      }
      OverlayName10: =
      {
        txt = "&"
        hint = "Overlay Name 10"
      }
      OverlayTime10: =
      {
        txt = "&"
        hint = "Overlay Duration 10"
      }
      input#StartOverlays: =
      {
        txt = "&"
        hint = "Start displaying the first overlay."
      }
      input#StopOverlays: =
      {
        txt = "&"
        hint = "Stop displaying any overlays."
      }
      input#SwitchOverlay: =
      {
        txt = "&"
        hint = "Switch to displaying a specific overlay. Pass in the desired o"
         "verlay number in the parameter."
      }
    }
    env_texturetoggle:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Target Brush(es)."
      }
      input#IncrementTextureIndex: =
      {
        txt = "&"
        hint = "Increments target brush's current texture frame by one."
      }
      input#SetTextureIndex: =
      {
        txt = "&"
        hint = "Sets target brush's texture frame to the specified index."
      }
    }
    env_splash:form =
    {
      t_Targetname = !
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "Scale of the splash"
      }
      input#Splash: =
      {
        txt = "&"
        hint = "Create a splash effect."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Automatically find water surface (place entity above water)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Diminish with depth (diminished completely in 10 feet of water)"
      }
    }
    env_particlelight:form =
    {
      t_Parentname = !
      Color: =
      {
        txt = "&"
        hint = "Color"
      }
      Intensity: =
      {
        txt = "&"
        hint = "Intensity"
      }
      directional: =
      {
        txt = "&"
        hint = "Directional"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      PSName: =
      {
        txt = "&"
        hint = "Particle System Entity"
      }
    }
    env_sun:form =
    {
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Viewer entity"
      }
      use_angles: =
      {
        txt = "&"
        hint = "UseAngles"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Sun Color (R G B)"
      }
      size: =
      {
        txt = "&"
        hint = "Size"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable sun rendering."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable sun rendering."
      }
      input#SetColor: =
      {
        txt = "&"
        hint = "Change the sun's color."
      }
    }
    game_ragdoll_manager:form =
    {
      t_Targetname = !
      MaxRagdollCount: =
      {
        txt = "&"
        hint = "Max Ragdoll Count"
      }
      input#SetMaxRagdollCount: =
      {
        txt = "&"
        hint = "Set the Max Ragdoll Count."
      }
    }
    env_lightglow:form =
    {
      t_Targetname = !
      t_Angles = !
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      VerticalGlowSize: =
      {
        txt = "&"
        hint = "Vertical Size"
      }
      HorizontalGlowSize: =
      {
        txt = "&"
        hint = "Horizontal Size"
      }
      MinDist: =
      {
        txt = "&"
        hint = "Minimum Distance"
      }
      MaxDist: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
      OuterMaxDist: =
      {
        txt = "&"
        hint = "Outer Maximum Distance"
      }
      GlowProxySize: =
      {
        txt = "&"
        hint = "Glow Proxy Geometry Size"
      }
      input#Color: =
      {
        txt = "&"
        hint = "Change the render color of the glow."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Visible only from front"
      }
    }
    env_smokestack:form =
    {
      t_Parentname = !
      t_Angles = !
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      InitialState: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      BaseSpread: =
      {
        txt = "&"
        hint = "Spread at the base"
      }
      SpreadSpeed: =
      {
        txt = "&"
        hint = "Spread Speed"
      }
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      StartSize: =
      {
        txt = "&"
        hint = "Particle start size"
      }
      EndSize: =
      {
        txt = "&"
        hint = "Particle end size"
      }
      Rate: =
      {
        txt = "&"
        hint = "Emission rate"
      }
      JetLength: =
      {
        txt = "&"
        hint = "Length of smoke trail"
      }
      WindAngle: =
      {
        txt = "&"
        hint = "Wind X/Y Angle"
      }
      WindSpeed: =
      {
        txt = "&"
        hint = "Wind Speed"
      }
      SmokeMaterial: =
      {
        txt = "&"
        hint = "Particle material"
      }
      twist: =
      {
        txt = "&"
        hint = "Twist"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Base Color (R G B)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on the smokestack."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off the smokestack."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the smokestack between on and off state."
      }
      input#JetLength: =
      {
        txt = "&"
        hint = "Set the length of the smoke trail."
      }
      input#Rate: =
      {
        txt = "&"
        hint = "Set the rate at which to emit smoke particles (particles per s"
         "econd)."
      }
      input#Speed: =
      {
        txt = "&"
        hint = "Set the speed at which the smoke particles move after they're "
         "spawned."
      }
      input#SpreadSpeed: =
      {
        txt = "&"
        hint = "Set the amount of random spread in the velocity of the smoke p"
         "articles after they're spawned."
      }
    }
    env_fade:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Fade From"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Modulate"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Stay Out"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration (seconds)"
      }
      holdtime: =
      {
        txt = "&"
        hint = "Hold Fade (seconds)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Fade Alpha"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Fade Color (R G B)"
      }
      input#Fade: =
      {
        txt = "&"
        hint = "Start the screen fade."
      }
      output#OnBeginFade: =
      {
        txt = "&"
        hint = "Fired when the fade has begun."
      }
    }
    env_player_surface_trigger:form =
    {
      t_Targetname = !
      gamematerial: =
      {
        txt = "&"
        hint = "Game Material to Watch"
        typ = "C"
        items = "None (player's in the air)"$0D"Concrete"$0D"Metal"$0D"Dirt"$0D
         "Vent"$0D"Grate"$0D"Tile"$0D"Slosh"$0D"Wood"$0D"Computer"$0D"Glass"$0D
         "Flesh"$0D"Clip"$0D"Foliage"$0D"Sand"
        values = "0"$0D"67"$0D"77"$0D"68"$0D"86"$0D"71"$0D"84"$0D"83"$0D"87"$0D
         "80"$0D"89"$0D"70"$0D"73"$0D"79"$0D"78"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Start watching the player's surface."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Stop watching the player's surface."
      }
      output#OnSurfaceChangedToTarget: =
      {
        txt = "&"
        hint = "Fired when the player moves onto the specified game material."
      }
      output#OnSurfaceChangedFromTarget: =
      {
        txt = "&"
        hint = "Fired when the player moves off the specified game material."
      }
    }
    env_tonemap_controller:form =
    {
      t_Targetname = !
      input#SetTonemapScale: =
      {
        txt = "&"
        hint = "Set the player's tonemap scale. It should be a value between 0"
         " and 2, where 0 is the eyes fully closed, 1 is use the unchanged aut"
         "oexposure (default), and 2 is the eye fully wide open."
      }
      input#BlendTonemapScale: =
      {
        txt = "&"
        hint = "Blend from the player's current tonemap scale to a new one. Th"
         "e parameter syntax is as follows: <target tonemap scale> <blend dura"
         "tion>. For example: '0.5 10' would blend from the current tonemap sc"
         "ale to 0.5 over a period of 10 seconds. Tonemap scale is a value bet"
         "ween 0 and 2, where 0 is the eyes fully closed, 1 is use the unchang"
         "ed autoexposure (default), and 2 is the eye fully wide open."
      }
    }
    func_ladder:form =
    {
    }
    func_useableladder:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Fake Ladder"
      }
      point0: =
      {
        txt = "&"
        hint = "Start"
      }
      point1: =
      {
        txt = "&"
        hint = "End"
      }
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this ladder."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this ladder."
      }
      output#OnPlayerGotOnLadder: =
      {
        txt = "&"
        hint = "Fired whenever a player gets on this ladder."
      }
      output#OnPlayerGotOffLadder: =
      {
        txt = "&"
        hint = "Fired whenever a player gets off this ladder."
      }
    }
    func_ladderendpoint:form =
    {
      bbox = '-16 -16 0 16 16 72'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Other"
      }
    }
    info_ladder_dismount:form =
    {
      bbox = '-16 -16 0 16 16 4'
      t_Parentname = !
      target: =
      {
        txt = "&"
        hint = "LadderName"
      }
    }
    func_areaportalwindow:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Rendered Window"
      }
      FadeStartDist: =
      {
        txt = "&"
        hint = "Fade Start Distance"
      }
      FadeDist: =
      {
        txt = "&"
        hint = "Fade End Distance"
      }
      TranslucencyLimit: =
      {
        txt = "&"
        hint = "Translucency limit"
      }
      BackgroundBModel: =
      {
        txt = "&"
        hint = "Foreground bmodel"
      }
    }
    func_wall:form =
    {
      t_Targetname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_clip_vphysics:form =
    {
      t_Targetname = !
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
    }
    func_brush:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Inputfilter = !
      t_EnableDisable = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Ignore player +USE"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      Solidity: =
      {
        txt = "&"
        hint = "Solidity"
        typ = "C"
        items = "Toggle"$0D"Never Solid"$0D"Always Solid"
        values = "0"$0D"1"$0D"2"
      }
      excludednpc: =
      {
        txt = "&"
        hint = "NPC class excluded from collisions"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    t_vgui_screen_base:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      panelname: =
      {
        txt = "&"
        hint = "Panel Name"
      }
      overlaymaterial: =
      {
        txt = "&"
        hint = "Overlay Material"
      }
      width: =
      {
        txt = "&"
        hint = "Panel Width in World"
      }
      height: =
      {
        txt = "&"
        hint = "Panel Height in World"
      }
      input#SetActive: =
      {
        txt = "&"
        hint = "Make the vgui screen visible."
      }
      input#SetInactive: =
      {
        txt = "&"
        hint = "Make the vgui screen invisible."
      }
    }
    vgui_screen:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_vgui_screen_base = !
    }
    cycler:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_RenderFxChoices = !
      t_RenderFields = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not Solid"
      }
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      sequence: =
      {
        txt = "&"
        hint = "Sequence"
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the cycler's sequence."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Sets the cycler's alpha value."
      }
    }
    t_gibshooterbase:incl =
    {
      t_Targetname = !
      t_Parentname = !
      angles: =
      {
        txt = "&"
        hint = "Gib Direction (Pitch Yaw Roll)"
      }
      m_iGibs: =
      {
        txt = "&"
        hint = "Number of Gibs"
      }
      delay: =
      {
        txt = "&"
        hint = "Delay between shots"
      }
      gibangles: =
      {
        txt = "&"
        hint = "Gib Angles (Pitch Yaw Roll)"
      }
      m_flVelocity: =
      {
        txt = "&"
        hint = "Gib Velocity"
      }
      m_flVariance: =
      {
        txt = "&"
        hint = "Course Variance"
      }
      m_flGibLife: =
      {
        txt = "&"
        hint = "Gib Life"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Repeatable"
      }
      input#Shoot: =
      {
        txt = "&"
        hint = "Force the gibshooter to create and shoot a gib."
      }
    }
    env_beam:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_RenderFxChoices = !
      renderamt: =
      {
        txt = "&"
        hint = "Brightness (1 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Beam Color (R G B)"
      }
      Radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      life: =
      {
        txt = "&"
        hint = "Life (seconds 0 = infinite)"
      }
      BoltWidth: =
      {
        txt = "&"
        hint = "Width of beam"
      }
      NoiseAmplitude: =
      {
        txt = "&"
        hint = "Amount of noise (0-255)"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      TextureScroll: =
      {
        txt = "&"
        hint = "Texture Scroll Rate (0-100)"
      }
      framerate: =
      {
        txt = "&"
        hint = "Frames per 10 seconds"
      }
      framestart: =
      {
        txt = "&"
        hint = "Starting Frame"
      }
      StrikeTime: =
      {
        txt = "&"
        hint = "Strike again time (secs)"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage / second"
      }
      LightningStart: =
      {
        txt = "&"
        hint = "Start Entity"
      }
      LightningEnd: =
      {
        txt = "&"
        hint = "Ending Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Random Strike"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Ring"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "StartSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "EndSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Decal End"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Shade Start"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Shade End"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Taper Out"
      }
      TouchType: =
      {
        txt = "&"
        hint = "Touch Type (tripwire)"
        typ = "C"
        items = "Not a tripwire"$0D"Player Only"$0D"NPC Only"$0D"Player or NPC"
         $0D"Player or NPC or Physprop"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the beam on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the beam off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the beam between on and off."
      }
      input#StrikeOnce: =
      {
        txt = "&"
        hint = "Causes the beam to strike once. It will stay on for its set Li"
         "fe and then turn off (it will never turn off if Life is set to zero)"
         "."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Sets the beam's alpha (0 - 255)."
      }
      input#Color: =
      {
        txt = "&"
        hint = "Sets the beam's render color (R G B)."
      }
      input#Amplitude: =
      {
        txt = "&"
        hint = "Set the amplitude of beam noise (0 - 255)."
      }
      input#ScrollSpeed: =
      {
        txt = "&"
        hint = "Set the scroll speed in units per second (0 - 100)."
      }
      input#Width: =
      {
        txt = "&"
        hint = "Set the width of the beam, in pixels."
      }
      output#OnTouchedByEntity: =
      {
        txt = "&"
        hint = "Fired when an entity touches the beam. Only fired if the entit"
         "y passes the 'Touch Type' choice."
      }
    }
    env_beverage:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      health: =
      {
        txt = "&"
        hint = "Capacity"
      }
      beveragetype: =
      {
        txt = "&"
        hint = "Beverage Type"
        typ = "C"
        items = "Coca-Cola"$0D"Sprite"$0D"Diet Coke"$0D"Orange"$0D"Surge"$0D"M"
         "oxie"$0D"Random"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Enable this dispenser."
      }
    }
    env_embers:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      particletype: =
      {
        txt = "&"
        hint = "Ember type"
        typ = "C"
        items = "Normal"$0D"Smooth Fade"$0D"Pulled"
        values = "0"$0D"1"$0D"2"
      }
      density: =
      {
        txt = "&"
        hint = "Density (particles per second)"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Particle Lifetime (seconds)"
      }
      speed: =
      {
        txt = "&"
        hint = "Particle Speed (units per second)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Ember Color (R G B)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Toggle"
      }
    }
    env_funnel:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Reverse"
      }
    }
    env_blood:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      t_Parentname = !
      spraydir: =
      {
        txt = "&"
        hint = "Spray Direction (Pitch Yaw Roll)"
      }
      color: =
      {
        txt = "&"
        hint = "Blood Color"
        typ = "C"
        items = "Red (Human)"$0D"Yellow (Alien)"
        values = "0"$0D"1"
      }
      amount: =
      {
        txt = "&"
        hint = "Amount of blood (damage to simulate)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Random Direction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Blood Stream"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "On Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Spray decals"
      }
      input#EmitBlood: =
      {
        txt = "&"
        hint = "Triggers the blood effect."
      }
    }
    env_bubbles:form =
    {
      t_Targetname = !
      t_Parentname = !
      density: =
      {
        txt = "&"
        hint = "Bubble density"
      }
      frequency: =
      {
        txt = "&"
        hint = "Bubble frequency"
      }
      current: =
      {
        txt = "&"
        hint = "Speed of Current"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Off"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activates the bubbles."
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Deactivates the bubbles."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the bubbles on and off."
      }
      input#SetDensity: =
      {
        txt = "&"
        hint = "Sets the bubble density."
      }
      input#SetFrequency: =
      {
        txt = "&"
        hint = "Sets bubble emission rate in bubbles per second."
      }
      input#SetCurrent: =
      {
        txt = "&"
        hint = "Sets current speed in inches per second."
      }
    }
    env_explosion:form =
    {
      t_Targetname = !
      t_Parentname = !
      iMagnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      iRadiusOverride: =
      {
        txt = "&"
        hint = "Radius Override"
      }
      fireballsprite: =
      {
        txt = "&"
        hint = "Fireball Sprite"
      }
      rendermode: =
      {
        txt = "&"
        hint = "Render Mode"
        typ = "C"
        items = "Normal"$0D"Solid"$0D"Additive"
        values = "0"$0D"4"$0D"5"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Damage"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Repeatable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "No Fireball"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "No Smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "No Decal"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No Sparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "No Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Random Orientation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "No Fireball Smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "No particles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "No DLights"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Don't clamp Min"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Don't clamp Max"
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Triggers the explosion."
      }
    }
    env_smoketrail:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      opacity: =
      {
        txt = "&"
        hint = "Sprite Opacity"
      }
      spawnrate: =
      {
        txt = "&"
        hint = "Spawn Rate"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Particle Life Time"
      }
      startcolor: =
      {
        txt = "&"
        hint = "Start Color"
      }
      endcolor: =
      {
        txt = "&"
        hint = "End Color"
      }
      emittime: =
      {
        txt = "&"
        hint = "Emitter Life Time"
      }
      minspeed: =
      {
        txt = "&"
        hint = "Minimum Random Speed"
      }
      maxspeed: =
      {
        txt = "&"
        hint = "Maximum Random Speed"
      }
      mindirectedspeed: =
      {
        txt = "&"
        hint = "Minimum Directed Speed"
      }
      maxdirectedspeed: =
      {
        txt = "&"
        hint = "Maximum Directed Speed"
      }
      startsize: =
      {
        txt = "&"
        hint = "Starting particle size"
      }
      endsize: =
      {
        txt = "&"
        hint = "Ending particle size"
      }
      spawnradius: =
      {
        txt = "&"
        hint = "Spawn radius"
      }
      firesprite: =
      {
        txt = "&"
        hint = "Fire Sprite"
      }
      smokesprite: =
      {
        txt = "&"
        hint = "Smoke Puff"
      }
    }
    env_global:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      globalstate: =
      {
        txt = "&"
        hint = "Global State to Set"
        typ = "C"
        items = "Gordon pre-criminal"$0D"Antlions are player allies"$0D"Player"
         " in APC is disguised as combine"$0D"Suit sprint function not yet ena"
         "bled"$0D"Super phys gun is enabled"$0D"Friendly encounter sequence ("
         "lower weapons, etc.)"$0D"Citizens are *not* player allies (cannot be"
         " commanded)"$0D"Gordon is invulnerable"$0D"Don't spawn seagulls on t"
         "he jeep"
        values = "gordon_precriminal"$0D"antlion_allied"$0D"player_stealth"$0D
         "suit_no_sprint"$0D"super_phys_gun"$0D"friendly_encounter"$0D"citizen"
         "s_passive"$0D"gordon_invulnerable"$0D"no_seagulls_on_jeep"
      }
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"$0D"Dead"
        values = "0"$0D"1"$0D"2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Set Initial State"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Set state of global to ON."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Set state of global to OFF."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles state of global between ON and OFF."
      }
      input#Remove: =
      {
        txt = "&"
        hint = "Set state of global to DEAD."
      }
    }
    env_physexplosion:form =
    {
      t_Targetname = !
      t_Parentname = !
      magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      radius: =
      {
        txt = "&"
        hint = "Clamp Radius (0 = auto)"
      }
      targetentityname: =
      {
        txt = "&"
        hint = "Limit to Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Damage - Only Force"
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Trigger the explosion."
      }
    }
    env_physimpact:form =
    {
      t_Targetname = !
      t_Parentname = !
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
      magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      directionentityname: =
      {
        txt = "&"
        hint = "Point to Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No fall-off"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Infinite Length"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Ignore Mass"
      }
      input#Impact: =
      {
        txt = "&"
        hint = "Trigger the impact"
      }
    }
    env_fire:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      health: =
      {
        txt = "&"
        hint = "Duration"
      }
      firesize: =
      {
        txt = "&"
        hint = "Size"
      }
      fireattack: =
      {
        txt = "&"
        hint = "Attack"
      }
      firetype: =
      {
        txt = "&"
        hint = "Type"
        typ = "C"
        items = "Natural"$0D"Plasma"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Infinite Duration"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Smokeless"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Start Full"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Don't drop"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No glow"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Delete when out"
      }
      ignitionpoint: =
      {
        txt = "&"
        hint = "Ignition Point"
      }
      damagescale: =
      {
        txt = "&"
        hint = "Damage Scale"
      }
      input#StartFire: =
      {
        txt = "&"
        hint = "Start the fire."
      }
      input#Extinguish: =
      {
        txt = "&"
        hint = "Puts out the fire permanently in the number of seconds specifi"
         "ed."
      }
      input#ExtinguishTemporary: =
      {
        txt = "&"
        hint = "Puts out the fire temporarily in the number of seconds specifi"
         "ed."
      }
      output#OnIgnited: =
      {
        txt = "&"
        hint = "Fires when the fire is first ignited."
      }
      output#OnExtinguished: =
      {
        txt = "&"
        hint = "Fires when the fire is fully extinguished."
      }
    }
    env_firesource:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      fireradius: =
      {
        txt = "&"
        hint = "Radius"
      }
      firedamage: =
      {
        txt = "&"
        hint = "Intensity / Damage"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable fire source."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable fire source."
      }
    }
    env_firesensor:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      fireradius: =
      {
        txt = "&"
        hint = "Radius"
      }
      heatlevel: =
      {
        txt = "&"
        hint = "Heat level"
      }
      heattime: =
      {
        txt = "&"
        hint = "Time at level"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable fire sensor."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable fire sensor."
      }
      output#OnHeatLevelStart: =
      {
        txt = "&"
        hint = "Fires when the heat level has been sustained for the specified"
         " length of time."
      }
      output#OnHeatLevelEnd: =
      {
        txt = "&"
        hint = "Fires when the heat level drops below the target level."
      }
    }
    env_entity_igniter:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Entity to ignite"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Lifetime in seconds"
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite the target entity."
      }
    }
    env_fog_controller:form =
    {
      t_Targetname = !
      t_DXLevelChoice = !
      t_Angles = !
      input#SetStartDist: =
      {
        txt = "&"
        hint = "Set the fog start distance."
      }
      input#SetEndDist: =
      {
        txt = "&"
        hint = "Set the fog end distance."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the fog on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the fog off."
      }
      input#SetColor: =
      {
        txt = "&"
        hint = "Set the primary fog color."
      }
      input#SetColorSecondary: =
      {
        txt = "&"
        hint = "Set the secondary fog color."
      }
      input#SetFarZ: =
      {
        txt = "&"
        hint = "Set the far clip plane distance."
      }
      input#SetAngles: =
      {
        txt = "&"
        hint = "Set the angles to use for the secondary fog direction."
      }
      fogenable: =
      {
        txt = "&"
        hint = "Fog Enable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogblend: =
      {
        txt = "&"
        hint = "Fog Blend"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      use_angles: =
      {
        txt = "&"
        hint = "Use Angles for Fog Dir"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogcolor: =
      {
        txt = "&"
        hint = "Primary Fog Color"
      }
      fogcolor2: =
      {
        txt = "&"
        hint = "Secondary Fog Color"
      }
      fogdir: =
      {
        txt = "&"
        hint = "Primary Fog Direction"
      }
      fogstart: =
      {
        txt = "&"
        hint = "Fog Start"
      }
      fogend: =
      {
        txt = "&"
        hint = "Fog End"
      }
      farz: =
      {
        txt = "&"
        hint = "Far Z Clip Plane"
      }
    }
    env_steam:form =
    {
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Emissive"
      }
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      InitialState: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      type: =
      {
        txt = "&"
        hint = "Particle Type"
        typ = "C"
        items = "Normal"$0D"Heat Wave"
        values = "0"$0D"1"
      }
      SpreadSpeed: =
      {
        txt = "&"
        hint = "Spread Speed"
      }
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      StartSize: =
      {
        txt = "&"
        hint = "Particle start size"
      }
      EndSize: =
      {
        txt = "&"
        hint = "Particle end size"
      }
      Rate: =
      {
        txt = "&"
        hint = "Emission rate"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      JetLength: =
      {
        txt = "&"
        hint = "Length of steam jet"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the steam jet on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the steam jet off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the steam jet between on and off."
      }
      input#JetLength: =
      {
        txt = "&"
        hint = "Sets the length of steam jet."
      }
      input#Rate: =
      {
        txt = "&"
        hint = "Sets the particle emission rate in particles per second."
      }
      input#Speed: =
      {
        txt = "&"
        hint = "Sets the default speed of the particles in units per second."
      }
      input#SpreadSpeed: =
      {
        txt = "&"
        hint = "Sets the spread speed in units per second."
      }
    }
    env_laser:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_RenderFxChoices = !
      LaserTarget: =
      {
        txt = "&"
        hint = "Target of Laser"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Brightness (1 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Beam Color (R G B)"
      }
      width: =
      {
        txt = "&"
        hint = "Width of Beam"
      }
      NoiseAmplitude: =
      {
        txt = "&"
        hint = "Amount of noise (0-255)"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      EndSprite: =
      {
        txt = "&"
        hint = "End Sprite"
      }
      TextureScroll: =
      {
        txt = "&"
        hint = "Texture Scroll Rate (0-100)"
      }
      framestart: =
      {
        txt = "&"
        hint = "Starting Frame"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage / second"
      }
      dissolvetype: =
      {
        txt = "&"
        hint = "Dissolve Type"
        typ = "C"
        items = "None"$0D"Energy"$0D"Heavy electrical"$0D"Light electrical"
        values = "-1"$0D"0"$0D"1"$0D"2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "StartSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "EndSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Decal End"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the laser on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the laser off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the laser between on and off."
      }
    }
    env_message:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      message: =
      {
        txt = "&"
        hint = "Message Text"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Play Once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "All Clients"
      }
      messagesound: =
      {
        txt = "&"
        hint = "Sound Effect"
      }
      messagevolume: =
      {
        txt = "&"
        hint = "Volume 0-10"
      }
      messageattenuation: =
      {
        txt = "&"
        hint = "Sound Radius"
        typ = "C"
        items = "Small Radius"$0D"Medium Radius"$0D"Large  Radius"$0D"Play Eve"
         "rywhere"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      input#ShowMessage: =
      {
        txt = "&"
        hint = "Shows the message and plays the sound."
      }
      output#OnShowMessage: =
      {
        txt = "&"
        hint = "Fired when the message is activated."
      }
    }
    env_hudhint:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      message: =
      {
        txt = "&"
        hint = "Hint Text (localized)"
      }
      input#ShowHudHint: =
      {
        txt = "&"
        hint = "Shows the hint message."
      }
    }
    env_shake:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "GlobalShake"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "In Air"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Physics"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Ropes"
      }
      amplitude: =
      {
        txt = "&"
        hint = "Amplitude (0-16)"
      }
      radius: =
      {
        txt = "&"
        hint = "Effect Radius"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration (seconds)"
      }
      frequency: =
      {
        txt = "&"
        hint = "Frequency"
      }
      input#Amplitude: =
      {
        txt = "&"
        hint = "Set the amplitude (0-16)"
      }
      input#Frequency: =
      {
        txt = "&"
        hint = "Set the frequence. Should be a value between 0 and 255, where "
         "0.1 = jerk, and 255.0 = rumble."
      }
      input#StartShake: =
      {
        txt = "&"
        hint = "Start the shake."
      }
      input#StopShake: =
      {
        txt = "&"
        hint = "Stop the shake."
      }
    }
    gibshooter:form =
    {
      t_gibshooterbase = !
    }
    env_shooter:form =
    {
      t_gibshooterbase = !
      t_RenderFields = !
      shootmodel: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      shootsounds: =
      {
        txt = "&"
        hint = "Material Sound"
        typ = "C"
        items = "None"$0D"Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"Concrete"
        values = "-1"$0D"0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      simulation: =
      {
        txt = "&"
        hint = "Simulate"
        typ = "C"
        items = "Point"$0D"Physics"$0D"Ragdoll"
        values = "0"$0D"1"$0D"2"
      }
      skin: =
      {
        txt = "&"
        hint = "Gib Skin"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "On fire"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "strict remove after lifetime"
      }
    }
    env_rotorshooter:form =
    {
      t_gibshooterbase = !
      t_RenderFields = !
      shootmodel: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      shootsounds: =
      {
        txt = "&"
        hint = "Material Sound"
        typ = "C"
        items = "None"$0D"Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"Concrete"
        values = "-1"$0D"0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      simulation: =
      {
        txt = "&"
        hint = "Simulate"
        typ = "C"
        items = "Point"$0D"Physics"$0D"Ragdoll"
        values = "0"$0D"1"$0D"2"
      }
      skin: =
      {
        txt = "&"
        hint = "Gib Skin"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "On fire"
      }
      rotortime: =
      {
        txt = "&"
        hint = "Time Under Rotor"
      }
      rotortimevariance: =
      {
        txt = "&"
        hint = "Time variance"
      }
    }
    env_soundscape_proxy:form =
    {
      t_Targetname = !
      t_Parentname = !
      MainSoundscapeName: =
      {
        txt = "&"
        hint = "Soundscape Entity"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
    }
    env_soundscape:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      soundscape: =
      {
        txt = "&"
        hint = "Soundscape"
        typ = "C"
        items = "Nothing"$0D"Automatic"$0D"Automatic (dialog)"$0D"Indoor"$0D"O"
         "utdoor"
        values = "Nothing"$0D"Automatic"$0D"Automatic_Dialog"$0D"GenericIndoor"
         $0D"GenericOutdoor"
      }
      position0: =
      {
        txt = "&"
        hint = "Sound Position 0"
      }
      position1: =
      {
        txt = "&"
        hint = "Sound Position 1"
      }
      position2: =
      {
        txt = "&"
        hint = "Sound Position 2"
      }
      position3: =
      {
        txt = "&"
        hint = "Sound Position 3"
      }
      position4: =
      {
        txt = "&"
        hint = "Sound Position 4"
      }
      position5: =
      {
        txt = "&"
        hint = "Sound Position 5"
      }
      position6: =
      {
        txt = "&"
        hint = "Sound Position 6"
      }
      position7: =
      {
        txt = "&"
        hint = "Sound Position 7"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the soundscape."
      }
      input#Disabled: =
      {
        txt = "&"
        hint = "Disable the soundscape."
      }
      input#ToggleEnabled: =
      {
        txt = "&"
        hint = "Toggle the soundscape enabled state."
      }
      output#OnPlay: =
      {
        txt = "&"
        hint = "Fired when this soundscape becomes the active one."
      }
    }
    env_soundscape_triggerable:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      soundscape: =
      {
        txt = "&"
        hint = "Soundscape"
        typ = "C"
        items = "Nothing"$0D"Automatic"$0D"Automatic (dialog)"$0D"Indoor"$0D"O"
         "utdoor"
        values = "Nothing"$0D"Automatic"$0D"Automatic_Dialog"$0D"GenericIndoor"
         $0D"GenericOutdoor"
      }
      position0: =
      {
        txt = "&"
        hint = "Sound Position 0"
      }
      position1: =
      {
        txt = "&"
        hint = "Sound Position 1"
      }
      position2: =
      {
        txt = "&"
        hint = "Sound Position 2"
      }
      position3: =
      {
        txt = "&"
        hint = "Sound Position 3"
      }
      position4: =
      {
        txt = "&"
        hint = "Sound Position 4"
      }
      position5: =
      {
        txt = "&"
        hint = "Sound Position 5"
      }
      position6: =
      {
        txt = "&"
        hint = "Sound Position 6"
      }
      position7: =
      {
        txt = "&"
        hint = "Sound Position 7"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the soundscape."
      }
      input#Disabled: =
      {
        txt = "&"
        hint = "Disable the soundscape."
      }
      input#ToggleEnabled: =
      {
        txt = "&"
        hint = "Toggle the soundscape enabled state."
      }
      output#OnPlay: =
      {
        txt = "&"
        hint = "Fired when this soundscape becomes the active one."
      }
    }
    env_spark:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      MaxDelay: =
      {
        txt = "&"
        hint = "Max Delay"
      }
      Magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
        typ = "C"
        items = "Small"$0D"Medium"$0D"Large"$0D"Huge"
        values = "1"$0D"2"$0D"5"$0D"8"
      }
      TrailLength: =
      {
        txt = "&"
        hint = "Spark Trail Length"
        typ = "C"
        items = "Short"$0D"Medium"$0D"Long"
        values = "1"$0D"2"$0D"3"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Start ON"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Glow"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Directional"
      }
      input#StartSpark: =
      {
        txt = "&"
        hint = "Start the spark effect."
      }
      input#StopSpark: =
      {
        txt = "&"
        hint = "Stop the spark effect."
      }
      input#ToggleSpark: =
      {
        txt = "&"
        hint = "Toggle the on/off state of the spark effect."
      }
      input#SparkOnce: =
      {
        txt = "&"
        hint = "Spark once."
      }
    }
    env_sprite:form =
    {
      bbox = '-2 -2 -2 2 2 2'
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_DXLevelChoice = !
      framerate: =
      {
        txt = "&"
        hint = "Framerate"
      }
      model: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start on"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Play Once"
      }
      GlowProxySize: =
      {
        txt = "&"
        hint = "Size of Glow Proxy Geometry."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Set the sprite's alpha (0 - 255)."
      }
      input#Color: =
      {
        txt = "&"
        hint = "Set the sprite's color (R G B)."
      }
      input#SetScale: =
      {
        txt = "&"
        hint = "Set the sprite's scale (0 - 8.0)."
      }
      input#HideSprite: =
      {
        txt = "&"
        hint = "Hide the sprite. Won't be drawn until the 'ShowSprite' input i"
         "s received."
      }
      input#ShowSprite: =
      {
        txt = "&"
        hint = "Show the sprite."
      }
      input#ToggleSprite: =
      {
        txt = "&"
        hint = "Toggle the sprite between hidden and shown."
      }
    }
    env_wind:form =
    {
      t_Targetname = !
      gustsound: =
      {
        txt = "&"
        hint = "Gust Sound Filename"
      }
      minwind: =
      {
        txt = "&"
        hint = "Min normal speed"
      }
      maxwind: =
      {
        txt = "&"
        hint = "Max normal speed"
      }
      mingust: =
      {
        txt = "&"
        hint = "Min gust speed"
      }
      maxgust: =
      {
        txt = "&"
        hint = "Max gust speed"
      }
      mingustdelay: =
      {
        txt = "&"
        hint = "Min gust delay"
      }
      maxgustdelay: =
      {
        txt = "&"
        hint = "Max gust delay"
      }
      gustdirchange: =
      {
        txt = "&"
        hint = "Max gust dir change (degrees)"
      }
    }
    sky_camera:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "3D Skybox scale"
      }
      fogenable: =
      {
        txt = "&"
        hint = "Fog Enable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogblend: =
      {
        txt = "&"
        hint = "Fog Blend"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      use_angles: =
      {
        txt = "&"
        hint = "Use Angles for Fog Dir"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogcolor: =
      {
        txt = "&"
        hint = "Primary Fog Color"
      }
      fogcolor2: =
      {
        txt = "&"
        hint = "Secondary Fog Color"
      }
      fogdir: =
      {
        txt = "&"
        hint = "Primary Fog Dir"
      }
      fogstart: =
      {
        txt = "&"
        hint = "Fog Start"
      }
      fogend: =
      {
        txt = "&"
        hint = "Fog End"
      }
    }
    t_BaseSpeaker:incl =
    {
      t_Targetname = !
      t_ResponseContext = !
      delaymin: =
      {
        txt = "&"
        hint = "Min Delay Between Announcements"
      }
      delaymax: =
      {
        txt = "&"
        hint = "Max Delay Between Announcements"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Play Everywhere"
      }
      rulescript: =
      {
        txt = "&"
        hint = "Context rule script"
      }
      concept: =
      {
        txt = "&"
        hint = "Concept name"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on the random announcements."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off the random announcements."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the random announcements off and on."
      }
    }
    game_weapon_manager:form =
    {
      t_Targetname = !
      weaponname: =
      {
        txt = "&"
        hint = "Weapon Classname"
      }
      maxpieces: =
      {
        txt = "&"
        hint = "Max Allowed in Level"
      }
    }
    game_end:form =
    {
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      input#EndGame: =
      {
        txt = "&"
        hint = "End the multiplayer game."
      }
    }
    game_player_equip:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Use Only"
      }
      master: =
      {
        txt = "&"
        hint = "Team Master (Obsolete)"
      }
    }
    game_player_team:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Remove On fire"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Kill Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Gib Player"
      }
      target: =
      {
        txt = "&"
        hint = "game_team_master to use"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
    }
    game_score:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Allow Negative"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Team Points"
      }
      points: =
      {
        txt = "&"
        hint = "Points to add (+/-)"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
    }
    game_text:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "All Players"
      }
      message: =
      {
        txt = "&"
        hint = "Message Text"
      }
      x: =
      {
        txt = "&"
        hint = "X (0 - 1.0 = left to right) (-1 centers)"
      }
      y: =
      {
        txt = "&"
        hint = "Y (0 - 1.0 = top to bottom) (-1 centers)"
      }
      effect: =
      {
        txt = "&"
        hint = "Text Effect"
        typ = "C"
        items = "Fade In/Out"$0D"Credits"$0D"Scan Out"
        values = "0"$0D"1"$0D"2"
      }
      color: =
      {
        txt = "&"
        hint = "Color1"
      }
      color2: =
      {
        txt = "&"
        hint = "Color2"
      }
      fadein: =
      {
        txt = "&"
        hint = "Fade in Time (or character scan time)"
      }
      fadeout: =
      {
        txt = "&"
        hint = "Fade Out Time"
      }
      holdtime: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      fxtime: =
      {
        txt = "&"
        hint = "Scan time (scan effect only)"
      }
      channel: =
      {
        txt = "&"
        hint = "Text Channel"
        typ = "C"
        items = "Channel 1"$0D"Channel 2"$0D"Channel 3"$0D"Channel 4"
        values = "1"$0D"2"$0D"3"$0D"4"
      }
      master: =
      {
        txt = "&"
        hint = "Master"
      }
      input#Display: =
      {
        txt = "&"
        hint = "Display the message text."
      }
    }
    point_enable_motion_fixup:form =
    {
      bbox = '-2 -2 -2 2 2 2'
      t_Parentname = !
      t_Angles = !
    }
    point_message:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Disabled"
      }
      message: =
      {
        txt = "&"
        hint = "Entity Message"
      }
      radius: =
      {
        txt = "&"
        hint = "Show message radius"
      }
      developeronly: =
      {
        txt = "&"
        hint = "Developer Only?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Start displaying the message text, if the player is within the"
         " message radius."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Stop displaying the message text."
      }
    }
    point_spotlight:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No Dynamic Light"
      }
      spotlightlength: =
      {
        txt = "&"
        hint = "Spotlight Length"
      }
      spotlightwidth: =
      {
        txt = "&"
        hint = "Spotlight Width"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      input#LightOn: =
      {
        txt = "&"
        hint = "Turn the spotlight on."
      }
      input#LightOff: =
      {
        txt = "&"
        hint = "Turn the spotlight off"
      }
    }
    point_tesla:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      m_SourceEntityName: =
      {
        txt = "&"
        hint = "Source Entity"
      }
      m_SoundName: =
      {
        txt = "&"
        hint = "Sound Name"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      m_Color: =
      {
        txt = "&"
        hint = "Color"
      }
      m_flRadius: =
      {
        txt = "&"
        hint = "Radius"
      }
      beamcount_min: =
      {
        txt = "&"
        hint = "Min # of Beams"
      }
      beamcount_max: =
      {
        txt = "&"
        hint = "Max # of Beams"
      }
      thick_min: =
      {
        txt = "&"
        hint = "Min Beam Width"
      }
      thick_max: =
      {
        txt = "&"
        hint = "Max Beam Width"
      }
      lifetime_min: =
      {
        txt = "&"
        hint = "Min Time Visible"
      }
      lifetime_max: =
      {
        txt = "&"
        hint = "Max Time Visible"
      }
      interval_min: =
      {
        txt = "&"
        hint = "Min Time Between Arcs"
      }
      interval_max: =
      {
        txt = "&"
        hint = "Max Time Between Arcs"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn emitter on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn emitter off."
      }
      input#DoSpark: =
      {
        txt = "&"
        hint = "Force a single arc."
      }
    }
    point_clientcommand:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#Command: =
      {
        txt = "&"
        hint = "Command to execute."
      }
    }
    point_servercommand:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#Command: =
      {
        txt = "&"
        hint = "Command to execute."
      }
    }
    game_ui:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Freeze Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Hide Weapon"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "+Use Deactivates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Jump Deactivates"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Return Player Control."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Take Player Control."
      }
      output#PlayerOn: =
      {
        txt = "&"
        hint = "Fired whenever this entity starts controlling the player's inp"
         "ut."
      }
      output#PlayerOff: =
      {
        txt = "&"
        hint = "Fired whenever this entity stops controlling the player's inpu"
         "t."
      }
      output#PressedMoveLeft: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the moveleft key."
      }
      output#PressedMoveRight: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the moveright key."
      }
      output#PressedForward: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the forward key."
      }
      output#PressedBack: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the backward key."
      }
      output#PressedAttack: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the attack key."
      }
      output#PressedAttack2: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the secondary attack key."
      }
      output#XAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the X axis of the player's input"
         " changes. i.e. -1 when the player has moveleft key down, 1 when the "
         "player has moveright key down, and 0 if neither."
      }
      output#YAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the Y axis of the player's input"
         " changes. i.e. -1 when the player has backward key down, 1 when the "
         "player has forward key down, and 0 if neither."
      }
      output#AttackAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the state of the player's attack"
         " key changes. i.e. 1 when the player has the attack key down, 0 othe"
         "rwise."
      }
      output#Attack2Axis: =
      {
        txt = "&"
        hint = "An output that fires whenever the state of the player's second"
         "ary attack key changes. i.e. 1 when the player has the secondary att"
         "ack key down, 0 otherwise."
      }
    }
    game_zone_player:form =
    {
      t_Targetname = !
      t_Parentname = !
      input#CountPlayersInZone: =
      {
        txt = "&"
        hint = "Count the number of players in the zone, and fire the correspo"
         "nding outputs."
      }
      output#OnPlayerInZone: =
      {
        txt = "&"
        hint = "Fired whenever a count finds a player inside the zone, with th"
         "e player as the activator."
      }
      output#OnPlayerOutZone: =
      {
        txt = "&"
        hint = "Fired whenever a count finds a player outside the zone, with t"
         "he player as the activator."
      }
      output#PlayersInCount: =
      {
        txt = "&"
        hint = "Fired after a count, and contains the number of players found "
         "inside the zone."
      }
      output#PlayersOutCount: =
      {
        txt = "&"
        hint = "Fired after a count, and contains the number of players found "
         "outside the zone."
      }
    }
    infodecal:form =
    {
      t_Targetname = !
      texture: =
      {
        txt = "&"
        typ = "ET"
        Cap = "texture..."
      }
      LowPriority: =
      {
        txt = "&"
        hint = "Low Priority (can be replaced)"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Force the decal to apply itself to the world."
      }
    }
    info_projecteddecal:form =
    {
      t_Angles = !
      t_Targetname = !
      texture: =
      {
        txt = "&"
        typ = "ET"
        Cap = "texture..."
      }
      Distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Force the decal to apply itself to the world."
      }
    }
    info_no_dynamic_shadow:form =
    {
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
    }
    info_player_start:form =
    {
      t_PlayerClass = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Master (Has priority if multiple info_player_starts exist)"
      }
    }
    info_overlay:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      material: =
      {
        txt = "&"
        hint = "Material"
        typ = "ET"
        Cap = "texture..."
      }
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
      RenderOrder: =
      {
        txt = "&"
        hint = "Render Order"
      }
      StartU: =
      {
        txt = "&"
        hint = "U Start"
      }
      EndU: =
      {
        txt = "&"
        hint = "U End"
      }
      StartV: =
      {
        txt = "&"
        hint = "V Start"
      }
      EndV: =
      {
        txt = "&"
        hint = "V End"
      }
      BasisOrigin: =
      {
        txt = "&"
        hint = "Overlay Basis Origin(Read-Only)"
      }
      BasisU: =
      {
        txt = "&"
        hint = "Overlay Basis U(Read-Only)"
      }
      BasisV: =
      {
        txt = "&"
        hint = "Overlay Basis V(Read-Only)"
      }
      BasisNormal: =
      {
        txt = "&"
        hint = "Overlay Basis Normal(Read-Only)"
      }
      uv0: =
      {
        txt = "&"
        hint = "Overlay Point 1(Read-Only)"
      }
      uv1: =
      {
        txt = "&"
        hint = "Overlay Point 2(Read-Only)"
      }
      uv2: =
      {
        txt = "&"
        hint = "Overlay Point 3(Read-Only)"
      }
      uv3: =
      {
        txt = "&"
        hint = "Overlay Point 4(Read-Only)"
      }
    }
    info_intermission:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      target: =
      {
        txt = "&"
        hint = "Entity to look at"
      }
    }
    info_landmark:form =
    {
      t_Targetname = !
    }
    info_null:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
    }
    info_target:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      input#DispatchEffect: =
      {
        txt = "&"
        hint = "Dispatch an effect from this point. Unfinished."
      }
    }
    phys_ragdollmagnet:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      t_Parentname = !
      t_Angles = !
      axis: =
      {
        txt = "&"
        hint = "Bar Magnet Axis"
      }
      radius: =
      {
        txt = "&"
        hint = "Effective Radius"
      }
      force: =
      {
        txt = "&"
        hint = "Force"
      }
      target: =
      {
        txt = "&"
        hint = "Entity to affect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Bar Magnet (use axis helper)"
      }
    }
    info_lighting:form =
    {
      t_Targetname = !
    }
    info_teleport_destination:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_PlayerClass = !
    }
    info_node:form =
    {
      t_Targetname = !
      t_Node = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force human permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Force small_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Force wide_human permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Force tiny permissiont"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Force wide_short permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Force medium permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Force tiny_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Force large permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Force large_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Keep editor position"
      }
    }
    info_node_hint:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
      output#OnNPCStartedUsing: =
      {
        txt = "&"
        hint = "Fired when an NPC has reached this node and started using it. "
         "Passes along the NPC."
      }
      output#OnNPCStoppedUsing: =
      {
        txt = "&"
        hint = "Fired when an NPC has stopped using this node. Passes along th"
         "e NPC."
      }
    }
    info_node_air:form =
    {
      t_Targetname = !
      t_Node = !
      nodeheight: =
      {
        txt = "&"
        hint = "NodeHeight"
      }
    }
    info_node_air_hint:form =
    {
      t_Angles = !
      t_Targetname = !
      t_HintNode = !
      nodeheight: =
      {
        txt = "&"
        hint = "NodeHeight"
      }
    }
    info_hint:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
    }
    info_node_link:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      StartNode: =
      {
        txt = "&"
        hint = "Start node ID"
      }
      EndNode: =
      {
        txt = "&"
        hint = "End node ID"
      }
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      AllowUse: =
      {
        txt = "&"
        hint = "Allow Pass When Off"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force human connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Force small_centered connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Force wide_human connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Force tiny connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Force wide_short connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Force medium connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Force tiny_centered connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Force large connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Force large_centered connect"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the link on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the link off."
      }
    }
    info_node_link_controller:form =
    {
      t_Targetname = !
      mins: =
      {
        txt = "&"
        hint = "Mins"
      }
      maxs: =
      {
        txt = "&"
        hint = "Maxs"
      }
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      AllowUse: =
      {
        txt = "&"
        hint = "Allow Pass When Off"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the link on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the link off."
      }
    }
    info_node_climb:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
    }
    light:form =
    {
      t_Targetname = !
      t_Light = !
      target: =
      {
        txt = "&"
        hint = "Entity To Point At"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Initially dark"
      }
      _distance: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
    }
    light_environment:form =
    {
      t_Angles = !
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      _light: =
      {
        txt = "&"
        hint = "Brightness"
      }
      _ambient: =
      {
        txt = "&"
        hint = "Ambient"
      }
    }
    light_spot:form =
    {
      t_Targetname = !
      t_Angles = !
      t_Light = !
      target: =
      {
        txt = "&"
        hint = "Entity to point at"
      }
      _inner_cone: =
      {
        txt = "&"
        hint = "Inner (bright) angle"
      }
      _cone: =
      {
        txt = "&"
        hint = "Outer (fading) angle"
      }
      _exponent: =
      {
        txt = "&"
        hint = "Focus"
      }
      _distance: =
      {
        txt = "&"
        hint = "Maximum distance"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Initially dark"
      }
    }
    light_dynamic:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Entity to point at"
      }
      _light: =
      {
        txt = "&"
        hint = "Light color"
      }
      brightness: =
      {
        txt = "&"
        hint = "Light brightness"
      }
      _inner_cone: =
      {
        txt = "&"
        hint = "Inner (bright) angle"
      }
      _cone: =
      {
        txt = "&"
        hint = "Outer (fading) angle"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      distance: =
      {
        txt = "&"
        hint = "Maximum distance"
      }
      spotlight_radius: =
      {
        txt = "&"
        hint = "Spotlight end radius"
      }
      style: =
      {
        txt = "&"
        hint = "Appearance"
        typ = "C"
        items = "Normal"$0D"Fluorescent flicker"$0D"Slow, strong pulse"$0D"Slo"
         "w pulse, noblack"$0D"Gentle pulse"$0D"Flicker A"$0D"Flicker B"$0D"Ca"
         "ndle A"$0D"Candle B"$0D"Candle C"$0D"Fast strobe"$0D"Slow strobe"
        values = "0"$0D"10"$0D"2"$0D"11"$0D"5"$0D"1"$0D"6"$0D"3"$0D"7"$0D"8"$0D
         "4"$0D"9"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No world light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No model light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Add Displacement Alpha"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Subtract Displacement Alpha"
      }
      input#Color: =
      {
        txt = "&"
        hint = "Set the light's render color (R G B)."
      }
      input#brightness: =
      {
        txt = "&"
        hint = "Set the light brightness."
      }
      input#distance: =
      {
        txt = "&"
        hint = "Set the maximum light distance."
      }
      input#_inner_cone: =
      {
        txt = "&"
        hint = "Set the inner (bright) angle."
      }
      input#_cone: =
      {
        txt = "&"
        hint = "Set the outer (fading) angle."
      }
      input#spotlight_radius: =
      {
        txt = "&"
        hint = "Set the radius of the spotlight at the end point."
      }
      input#style: =
      {
        txt = "&"
        hint = "Change the lightstyle (see Appearance field for possible value"
         "s)."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the light off."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the light on."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the light on/off."
      }
    }
    shadow_control:form =
    {
      t_Targetname = !
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
      color: =
      {
        txt = "&"
        hint = "Shadow Color"
      }
      distance: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
      input#color: =
      {
        txt = "&"
        hint = "Set the shadow color."
      }
      input#direction: =
      {
        txt = "&"
        hint = "Set the shadow direction."
      }
      input#SetDistance: =
      {
        txt = "&"
        hint = "Set the maximum shadow cast distance."
      }
      input#SetAngles: =
      {
        txt = "&"
        hint = "Set the shadow direction."
      }
    }
    t_KeyFrame:incl =
    {
      NextKey: =
      {
        txt = "&"
        hint = "Next KeyFrame"
      }
      MoveSpeed: =
      {
        txt = "&"
        hint = "Speed (units per second)"
      }
    }
    t_Mover:incl =
    {
      PositionInterpolator: =
      {
        txt = "&"
        hint = "Position Interpolator"
        typ = "C"
        items = "Linear"$0D"Catmull-Rom Spline"
        values = "0"$0D"1"
      }
    }
    func_movelinear:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Not Solid"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      blockdamage: =
      {
        txt = "&"
        hint = "Block Damage"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the brush stops moving."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the brush to the end position (starting position + (move "
         "direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the brush to a specific position between 0.0 and 1.0, whe"
         "re 0 is the starting position and 1 is the starting position + (move"
         " direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the end position (starting positi"
         "on + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the starting position."
      }
    }
    func_water_analog:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the water brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the water brush stops moving."
      }
      WaveHeight: =
      {
        txt = "&"
        hint = "Wave Height"
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the water brush to the end position (starting position + "
         "(move direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the water brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the water brush to a specific position between 0.0 and 1."
         "0, where 0 is the starting position and 1 is the starting position +"
         " (move direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the water brush reaches the end position (starting "
         "position + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the water brush reaches the starting position."
      }
    }
    func_rotating:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      t_Shadow = !
      maxspeed: =
      {
        txt = "&"
        hint = "Max Rotation Speed"
      }
      fanfriction: =
      {
        txt = "&"
        hint = "Friction (0 - 100%)"
      }
      message: =
      {
        txt = "&"
        hint = "Rotating sound WAV"
      }
      volume: =
      {
        txt = "&"
        hint = "Volume (10 = loudest)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start ON"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Direction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Acc/Dcc"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Fan Pain"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Not Solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Small Sound Radius"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Medium Sound Radius"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Large Sound Radius"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      dmg: =
      {
        txt = "&"
        hint = "Blocking Damage"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid Type"
        typ = "C"
        items = "VPhysics"$0D"BSP"
        values = "0"$0D"1"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the speed as a ratio of the specified Max Rotation Speed, "
         "where 0 is stopped and 1 is the Max Rotation Speed.."
      }
      input#Start: =
      {
        txt = "&"
        hint = "Start the rotator rotating."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the rotator from rotating."
      }
      input#StopAtStartPos: =
      {
        txt = "&"
        hint = "Stop the rotator from rotating when it gets around to the star"
         "t position again (on it's rotation axis)."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Start the rotator rotating forward."
      }
      input#StartBackward: =
      {
        txt = "&"
        hint = "Start the rotator rotating backward."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the rotator between rotating and not rotating."
      }
      input#Reverse: =
      {
        txt = "&"
        hint = "Reverse the direction of rotation of the rotator."
      }
    }
    func_platrot:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      t_BasePlat = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      noise1: =
      {
        txt = "&"
        hint = "Movement Sound"
      }
      noise2: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of Rotation"
      }
      height: =
      {
        txt = "&"
        hint = "Travel Altitude"
      }
      rotation: =
      {
        txt = "&"
        hint = "Spin amount"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    keyframe_track:form =
    {
      bbox = '-6 -6 -6 6 6 6'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_KeyFrame = !
    }
    move_keyframed:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_KeyFrame = !
      t_Mover = !
    }
    move_track:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Mover = !
      t_KeyFrame = !
      WheelBaseLength: =
      {
        txt = "&"
        hint = "Distance between the wheels"
      }
      Damage: =
      {
        txt = "&"
        hint = "Damage done to blocking entities"
      }
      NoRotate: =
      {
        txt = "&"
        hint = "Turn to face down path"
        typ = "C"
        items = "Yes"$0D"No"
        values = "0"$0D"1"
      }
    }
    t_RopeKeyFrame:incl =
    {
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Auto Resize"
      }
      Slack: =
      {
        txt = "&"
        hint = "Slack"
      }
      Type: =
      {
        txt = "&"
        hint = "Type"
        typ = "C"
        items = "Rope"$0D"Semi-rigid"$0D"Rigid"
        values = "0"$0D"1"$0D"2"
      }
      Subdiv: =
      {
        txt = "&"
        hint = "Subdivision"
      }
      Barbed: =
      {
        txt = "&"
        hint = "Barbed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Width: =
      {
        txt = "&"
        hint = "Width (1-64)"
      }
      TextureScale: =
      {
        txt = "&"
        hint = "Texture Scale"
      }
      Collide: =
      {
        txt = "&"
        hint = "Collide with world"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Dangling: =
      {
        txt = "&"
        hint = "Start Dangling"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Breakable: =
      {
        txt = "&"
        hint = "Breakable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      RopeMaterial: =
      {
        txt = "&"
        hint = "Rope Material"
        typ = "ET"
        Cap = "texture..."
      }
      input#SetScrollSpeed: =
      {
        txt = "&"
        hint = "Set the speed at which the texture scrolls."
      }
      input#SetForce: =
      {
        txt = "&"
        hint = "Apply a force instantaneously to the rope. The parameter shoul"
         "d be a vector containing the force to be applied (X Y Z)."
      }
      input#Break: =
      {
        txt = "&"
        hint = "Break the rope, if it's marked to do so."
      }
    }
    keyframe_rope:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_KeyFrame = !
      t_RopeKeyFrame = !
    }
    move_rope:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_KeyFrame = !
      t_RopeKeyFrame = !
      PositionInterpolator: =
      {
        txt = "&"
        hint = "Position Interpolator"
        typ = "C"
      }
    }
    t_Button:incl =
    {
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the button, preventing it from functioning."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the button, allowing it to function."
      }
      input#Press: =
      {
        txt = "&"
        hint = "Activate the button, as if it was pressed."
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when the button is damaged."
      }
      output#OnPressed: =
      {
        txt = "&"
        hint = "Fired when the button is pressed."
      }
      output#OnUseLocked: =
      {
        txt = "&"
        hint = "Fired when the button is used while locked."
      }
      output#OnIn: =
      {
        txt = "&"
        hint = "Fired when the button reaches the in/pressed position."
      }
      output#OnOut: =
      {
        txt = "&"
        hint = "Fired when the button reaches the out/released position."
      }
    }
    func_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Button = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      health: =
      {
        txt = "&"
        hint = "Health (Obsolete)"
      }
      lip: =
      {
        txt = "&"
        hint = "Lip"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None (Silent)"$0D"Big zap & Warmup"$0D"Access Denied"$0D"Acce"
         "ss Granted"$0D"Quick Combolock"$0D"Power Deadbolt 1"$0D"Power Deadbo"
         "lt 2"$0D"Plunger"$0D"Small zap"$0D"Keycard Sound"$0D"Buzz"$0D"Buzz O"
         "ff"$0D"latch locked"$0D"Latch Unlocked"$0D"Lightswitch"$0D"small ble"
         "ek"$0D"small deny"$0D"small doop"$0D"small tech deny"$0D"click and c"
         "ombine screen fuzz"$0D"roomy beep"$0D"lever or wheel: turn + move sq"
         "eek"$0D"lever or wheel: latch + release gas"$0D"lever or wheel: ratc"
         "het + sqeek"$0D"lever or wheel: large ratchet"$0D"lever or wheel: cl"
         "anky + gas release"$0D"lever or wheel: latch + large metal thud"$0D"l"
         "ever or wheel: smaller ratchet"$0D"lever or wheel: smaller lever mov"
         "e"$0D"shock buzz"$0D"clickbeep"$0D"tech blip"$0D"clickbeepbeep open"$0D
         "small high blip"$0D"small tech fuzz blip"$0D"small click bleep (chan"
         "ge to lightswitch)"$0D"combine door lock - locked"$0D"combine blip g"
         "rowl"$0D"combine squick growl"$0D"combine whine purr"$0D"combine cli"
         "ck talk"$0D"combine click growl fizz"$0D"combine click fizz (deny)"$0D
         "combine click talker"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"$0D"27"$0D"28"$0D"31"$0D
         "32"$0D"33"$0D"34"$0D"35"$0D"36"$0D"37"$0D"40"$0D"41"$0D"42"$0D"43"$0D
         "44"$0D"45"$0D"46"$0D"47"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Don't move"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Touch Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Damage Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Sparks"
      }
      locked_sound: =
      {
        txt = "&"
        hint = "Locked Sound"
        typ = "C"
        items = "None"$0D"Access Denied"$0D"Small zap"$0D"Buzz"$0D"Buzz Off"$0D
         "Latch Locked"
        values = "0"$0D"2"$0D"8"$0D"10"$0D"11"$0D"12"
      }
      unlocked_sound: =
      {
        txt = "&"
        hint = "Unlocked Sound"
        typ = "C"
        items = "None"$0D"Big zap & Warmup"$0D"Access Granted"$0D"Quick Combol"
         "ock"$0D"Power Deadbolt 1"$0D"Power Deadbolt 2"$0D"Plunger"$0D"Small "
         "zap"$0D"Keycard Sound"$0D"Buzz"$0D"Latch Unlocked"$0D"Lightswitch"
        values = "0"$0D"1"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"10"$0D
         "13"$0D"14"
      }
      locked_sentence: =
      {
        txt = "&"
        hint = "Locked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Denied"$0D"Security Lockout"$0D"Blast Do"
         "or"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. Conta"
         "inment"$0D"Maintenance Door"$0D"Broken Shut Door"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      unlocked_sentence: =
      {
        txt = "&"
        hint = "Unlocked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Granted"$0D"Security Disengaged"$0D"Blas"
         "t Door"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. C"
         "ontainment"$0D"Maintenance area"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_rot_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_Global = !
      t_Button = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      health: =
      {
        txt = "&"
        hint = "Health (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None (Silent)"$0D"Squeaky"$0D"Squeaky Pneumatic"$0D"Ratchet G"
         "roan"$0D"Clean Ratchet"$0D"Gas Clunk"
        values = "0"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance (deg)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Dir"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Touch Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Damage Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    momentary_rot_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      speed: =
      {
        txt = "&"
        hint = "Speed (deg/sec)"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None"$0D"Big zap & Warmup"$0D"Access Denied"$0D"Access Grante"
         "d"$0D"Quick Combolock"$0D"Power Deadbolt 1"$0D"Power Deadbolt 2"$0D"P"
         "lunger"$0D"Small zap"$0D"Keycard Sound"$0D"Squeaky"$0D"Squeaky Pneum"
         "atic"$0D"Ratchet Groan"$0D"Clean Ratchet"$0D"Gas Clunk"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"2"
         "1"$0D"22"$0D"23"$0D"24"$0D"25"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      returnspeed: =
      {
        txt = "&"
        hint = "Auto-return speed"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not Solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle (Disable Auto Return)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Jiggle when used while locked"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      startdirection: =
      {
        txt = "&"
        hint = "Start Direction"
        typ = "C"
        items = "Forward"$0D"Backward"
        values = "-1"$0D"1"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the button, preventing it from functioning."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the button, allowing it to function."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move to a position. The parameter must be a value between 0 an"
         "d 1, where 0 is the unrotated position and 1 is the rotated position"
         " + 'Distance'."
      }
      input#SetPositionImmediately: =
      {
        txt = "&"
        hint = "Immediately teleport to a position. The parameter must be a va"
         "lue between 0 and 1, where 0 is the unrotated position and 1 is the "
         "rotated position + 'Distance'."
      }
      output#Position: =
      {
        txt = "&"
        hint = "Fired whenever the button moves. The output is the position of"
         " button from 0 to 1, where 0 is the unrotated position and 1 is the "
         "rotated position + 'Distance'."
      }
      output#OnPressed: =
      {
        txt = "&"
        hint = "Fired when the button is first pressed."
      }
      output#OnUnpressed: =
      {
        txt = "&"
        hint = "Fired when the button is first released from being pressed."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the button has reached position 1, the rotated posi"
         "tion + 'Distance'."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the button has reached position 0, the unrotated st"
         "arting position."
      }
      output#OnReachedPosition: =
      {
        txt = "&"
        hint = "Fired whenever the button reaches a goal position: i.e. when i"
         "t becomes open, becomes closed, or reaches the point specified by a "
         "'SetPosition' input."
      }
    }
    t_Door:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      noise1: =
      {
        txt = "&"
        hint = "Start Sound"
      }
      noise2: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      lip: =
      {
        txt = "&"
        hint = "Lip"
      }
      dmg: =
      {
        txt = "&"
        hint = "Blocking Damage"
      }
      forceclosed: =
      {
        txt = "&"
        hint = "Force Closed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      message: =
      {
        txt = "&"
        hint = "Message If Triggered"
      }
      health: =
      {
        txt = "&"
        hint = "Health (shoot open)"
      }
      locked_sound: =
      {
        txt = "&"
        hint = "Locked Sound"
      }
      unlocked_sound: =
      {
        txt = "&"
        hint = "Unlocked Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Non-solid to Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Passable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use Opens"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "NPCs Can't"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Touch Opens"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Door Silent"
      }
      locked_sentence: =
      {
        txt = "&"
        hint = "Locked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Denied"$0D"Security Lockout"$0D"Blast Do"
         "or"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. Conta"
         "inment"$0D"Maintenance Door"$0D"Broken Shut Door"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      unlocked_sentence: =
      {
        txt = "&"
        hint = "Unlocked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Granted"$0D"Security Disengaged"$0D"Blas"
         "t Door"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. C"
         "ontainment"$0D"Maintenance area"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      loopmovesound: =
      {
        txt = "&"
        hint = "Loop Moving Sound?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      output#OnClose: =
      {
        txt = "&"
        hint = "Fired when the door starts closing."
      }
      output#OnOpen: =
      {
        txt = "&"
        hint = "Fired when the door starts opening."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully open position."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully closed position."
      }
      output#OnBlockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while closing."
      }
      output#OnBlockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while opening."
      }
      output#OnUnblockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while closing."
      }
      output#OnUnblockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while opening."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the door, if it is not fully open."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the door, if it is not fully closed."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the door between open and closed."
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the door."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the door."
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the door speed."
      }
    }
    func_door:form =
    {
      t_Door = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      filtername: =
      {
        txt = "&"
        hint = "Block Filter Name"
      }
    }
    func_door_rotating:form =
    {
      t_Door = !
      t_Origin = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Dir"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "One-way"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid Type"
        typ = "C"
        items = "VPhysics"$0D"BSP"
        values = "0"$0D"1"
      }
    }
    prop_door_rotating:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_Global = !
      t_Studiomodel = !
      hardware: =
      {
        txt = "&"
        hint = "Hardware Type"
        typ = "C"
        items = "<None>"$0D"Lever"$0D"Push bar"
        values = "0"$0D"1"$0D"2"
      }
      ajarangles: =
      {
        txt = "&"
        hint = "Ajar Angles (Pitch Yaw Roll)"
      }
      spawnpos: =
      {
        txt = "&"
        hint = "Spawn Position"
        typ = "C"
        items = "Closed"$0D"Open forward"$0D"Open back"$0D"Ajar (use Ajar Angl"
         "es)"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      axis: =
      {
        txt = "&"
        hint = "Hinge Axis"
      }
      distance: =
      {
        txt = "&"
        hint = "Rotation Distance (deg)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      soundopenoverride: =
      {
        txt = "&"
        hint = "Fully Open Sound"
      }
      soundcloseoverride: =
      {
        txt = "&"
        hint = "Fully Closed Sound"
      }
      soundmoveoverride: =
      {
        txt = "&"
        hint = "Moving Sound"
      }
      returndelay: =
      {
        txt = "&"
        hint = "Delay Before close (-1 stay open)"
      }
      dmg: =
      {
        txt = "&"
        hint = "Damage Inflicted When Blocked"
      }
      health: =
      {
        txt = "&"
        hint = "Health (0 = Unbreakable)"
      }
      soundlockedoverride: =
      {
        txt = "&"
        hint = "Locked Sound"
      }
      soundunlockedoverride: =
      {
        txt = "&"
        hint = "Unlocked Sound"
      }
      forceclosed: =
      {
        txt = "&"
        hint = "Force Closed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Door silent (No sound, and does not alert NPCs)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Use closes"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Door silent to NPCS (Does not alert NPCs)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Ignore player +USE"
      }
      output#OnClose: =
      {
        txt = "&"
        hint = "Fired when the door is told to close."
      }
      output#OnOpen: =
      {
        txt = "&"
        hint = "Fired when the door is told to open."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully open position."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully closed position."
      }
      output#OnBlockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while closing."
      }
      output#OnBlockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while opening."
      }
      output#OnUnblockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while closing."
      }
      output#OnUnblockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while opening."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the door, if it is not fully open."
      }
      input#OpenAwayFrom: =
      {
        txt = "&"
        hint = "Open the door away from the specified entity."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the door, if it is not fully closed."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the door between open and closed."
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the door."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the door."
      }
    }
    env_cubemap:form =
    {
      cubemapsize: =
      {
        txt = "&"
        hint = "Cubemap Size"
        typ = "C"
        items = "Default"$0D"1x1"$0D"2x2"$0D"4x4"$0D"8x8"$0D"16x16"$0D"32x32"$0D
         "64x64"$0D"128x128"$0D"256x256"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
    }
    t_BModelParticleSpawner:incl =
    {
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Color: =
      {
        txt = "&"
        hint = "Particle Color (R G B)"
      }
      SpawnRate: =
      {
        txt = "&"
        hint = "Particle Per Second"
      }
      SpeedMax: =
      {
        txt = "&"
        hint = "Maximum Particle Speed"
      }
      LifetimeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Lifetime"
      }
      LifetimeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Lifetime"
      }
      DistMax: =
      {
        txt = "&"
        hint = "Maximum Visible Distance"
      }
      Frozen: =
      {
        txt = "&"
        hint = "Frozen"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off."
      }
    }
    func_dustmotes:form =
    {
      t_Targetname = !
      t_BModelParticleSpawner = !
      SizeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Size"
      }
      SizeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Size"
      }
      Alpha: =
      {
        txt = "&"
        hint = "Alpha"
      }
    }
    func_smokevolume:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Emissive"
      }
      Color1: =
      {
        txt = "&"
        hint = "Particle Color1 (R G B)"
      }
      Color2: =
      {
        txt = "&"
        hint = "Particle Color2 (R G B)"
      }
      material: =
      {
        txt = "&"
        hint = "Material"
        typ = "ET"
        Cap = "texture..."
      }
      ParticleDrawWidth: =
      {
        txt = "&"
        hint = "Particle Draw Width (inches)"
      }
      ParticleSpacingDistance: =
      {
        txt = "&"
        hint = "Particle Spacing Distance (inches)"
      }
      DensityRampSpeed: =
      {
        txt = "&"
        hint = "Density Ramp Speed (seconds)"
      }
      RotationSpeed: =
      {
        txt = "&"
        hint = "Rotation Speed (degrees/sec)"
      }
      MovementSpeed: =
      {
        txt = "&"
        hint = "Movement Speed (inches/sec)"
      }
      Density: =
      {
        txt = "&"
        hint = "Density [0..1]"
      }
      input#SetRotationSpeed: =
      {
        txt = "&"
        hint = "Set the particle rotation speed (in degrees per second)."
      }
      input#SetMovementSpeed: =
      {
        txt = "&"
        hint = "Set the particle movement speed (in inches per second)."
      }
      input#SetDensity: =
      {
        txt = "&"
        hint = "Set the particle density. It should be a range from 0 to 1."
      }
    }
    func_dustcloud:form =
    {
      t_Targetname = !
      t_BModelParticleSpawner = !
      Alpha: =
      {
        txt = "&"
        hint = "Alpha"
      }
      SizeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Size"
      }
      SizeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Size"
      }
    }
    env_dustpuff:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      color: =
      {
        txt = "&"
        hint = "Dust color"
      }
      input#SpawnDust: =
      {
        txt = "&"
        hint = "Spawn a dust puff."
      }
    }
    env_particlescript:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      model: =
      {
        txt = "&"
        hint = "Script Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the script model's sequence."
      }
    }
    env_effectscript:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      model: =
      {
        txt = "&"
        hint = "Script Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      scriptfile: =
      {
        txt = "&"
        hint = "Name of the script to use for this model."
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the script model's sequence."
      }
    }
    logic_auto:form =
    {
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Remove on fire"
      }
      globalstate: =
      {
        txt = "&"
        hint = "Global State to Read"
        typ = "C"
        items = "--- None ---"$0D"Gordon pre-criminal"$0D"Antlions are player "
         "allies"$0D"Player in APC is disguised as combine"$0D"Suit sprint fun"
         "ction not yet enabled"$0D"Super phys gun is enabled"$0D"Friendly enc"
         "ounter sequence (lower weapons, etc.)"$0D"Citizens are *not* player "
         "allies (cannot be commanded)"$0D"Gordon is invulnerable"$0D"Don't sp"
         "awn seagulls on the jeep"
        values = $0D"gordon_precriminal"$0D"antlion_allied"$0D"player_stealth"$0D
         "suit_no_sprint"$0D"super_phys_gun"$0D"friendly_encounter"$0D"citizen"
         "s_passive"$0D"gordon_invulnerable"$0D"no_seagulls_on_jeep"
      }
      output#OnMapSpawn: =
      {
        txt = "&"
        hint = "Fired when the map is loaded for any reason."
      }
      output#OnNewGame: =
      {
        txt = "&"
        hint = "Fired when the map is loaded to start a new game."
      }
      output#OnLoadGame: =
      {
        txt = "&"
        hint = "Fired when the map is loaded from a saved game."
      }
      output#OnMapTransition: =
      {
        txt = "&"
        hint = "Fired when the map is loaded due to a level transition."
      }
      output#OnBackgroundMap: =
      {
        txt = "&"
        hint = "Fired when the map is loaded as a background to the main menu."
      }
    }
    point_viewcontrol:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Angles = !
      t_Parentname = !
      target: =
      {
        txt = "&"
        hint = "Entity to Look At"
      }
      targetattachment: =
      {
        txt = "&"
        hint = "Target Attachment Name"
      }
      wait: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      moveto: =
      {
        txt = "&"
        hint = "Path Corner"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start At Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Follow Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Freeze Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Infinite Hold Time"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Snap to goal angles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Make Player non-solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Interruptable by Player"
      }
      speed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      acceleration: =
      {
        txt = "&"
        hint = "Acceleration units/sec^2"
      }
      deceleration: =
      {
        txt = "&"
        hint = "Stop Deceleration units/sec^2"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the point_viewcontrol, and start controlling the player"
         "'s view."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the point_viewcontrol, and stop controlling the player"
         "'s view."
      }
      output#OnEndFollow: =
      {
        txt = "&"
        hint = "Fired when the point_viewcontrol deactivates, due to the Disab"
         "le input being received, the Entity to Look At being destroyed, or t"
         "he Hold Time expiring."
      }
    }
    logic_compare:form =
    {
      t_Targetname = !
      InitialValue: =
      {
        txt = "&"
        hint = "Initial value"
      }
      CompareValue: =
      {
        txt = "&"
        hint = "Compare value"
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the value that will be compared against the compare value."
      }
      input#SetValueCompare: =
      {
        txt = "&"
        hint = "Set the value that will be compared against the compare value "
         "and performs the comparison."
      }
      input#SetCompareValue: =
      {
        txt = "&"
        hint = "Set the compare value."
      }
      input#Compare: =
      {
        txt = "&"
        hint = "Force a compare of the input value with the compare value."
      }
      output#OnLessThan: =
      {
        txt = "&"
        hint = "Fired when the input value is less than the compare value. Sen"
         "ds the input value as data."
      }
      output#OnEqualTo: =
      {
        txt = "&"
        hint = "Fired when the input value is equal to the compare value. Send"
         "s the input value as data."
      }
      output#OnNotEqualTo: =
      {
        txt = "&"
        hint = "Fired when the input value is different from the compare value"
         ". Sends the input value as data."
      }
      output#OnGreaterThan: =
      {
        txt = "&"
        hint = "Fired when the input value is greater than the compare value. "
         "Sends the input value as data."
      }
    }
    logic_branch:form =
    {
      t_Targetname = !
      InitialValue: =
      {
        txt = "&"
        hint = "Initial value"
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the boolean value without performing the comparison. Use t"
         "his to hold a value for a future test."
      }
      input#SetValueTest: =
      {
        txt = "&"
        hint = "Set the boolean value and test it, firing OnTrue or OnFalse ba"
         "sed on the new value."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the boolean value between true and false."
      }
      input#ToggleTest: =
      {
        txt = "&"
        hint = "Toggle the boolean value and tests it, firing OnTrue or OnFals"
         "e based on the new value."
      }
      input#Test: =
      {
        txt = "&"
        hint = "Test the input value and fire OnTrue or OnFalse based on the v"
         "alue."
      }
      output#OnTrue: =
      {
        txt = "&"
        hint = "Fired when the input value is true (nonzero)."
      }
      output#OnFalse: =
      {
        txt = "&"
        hint = "Fired when the input value is false (zero)."
      }
    }
    logic_case:form =
    {
      t_Targetname = !
      Case01: =
      {
        txt = "&"
        hint = "Case 01"
      }
      Case02: =
      {
        txt = "&"
        hint = "Case 02"
      }
      Case03: =
      {
        txt = "&"
        hint = "Case 03"
      }
      Case04: =
      {
        txt = "&"
        hint = "Case 04"
      }
      Case05: =
      {
        txt = "&"
        hint = "Case 05"
      }
      Case06: =
      {
        txt = "&"
        hint = "Case 06"
      }
      Case07: =
      {
        txt = "&"
        hint = "Case 07"
      }
      Case08: =
      {
        txt = "&"
        hint = "Case 08"
      }
      Case09: =
      {
        txt = "&"
        hint = "Case 09"
      }
      Case10: =
      {
        txt = "&"
        hint = "Case 10"
      }
      Case11: =
      {
        txt = "&"
        hint = "Case 11"
      }
      Case12: =
      {
        txt = "&"
        hint = "Case 12"
      }
      Case13: =
      {
        txt = "&"
        hint = "Case 13"
      }
      Case14: =
      {
        txt = "&"
        hint = "Case 14"
      }
      Case15: =
      {
        txt = "&"
        hint = "Case 15"
      }
      Case16: =
      {
        txt = "&"
        hint = "Case 16"
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Compare the Input value to the case values, and fire the appro"
         "priate output, if any."
      }
      input#PickRandom: =
      {
        txt = "&"
        hint = "Fire a random OnCase output with at least one connection."
      }
      output#OnCase01: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case01 value."
      }
      output#OnCase02: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case02 value."
      }
      output#OnCase03: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case03 value."
      }
      output#OnCase04: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case04 value."
      }
      output#OnCase05: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case05 value."
      }
      output#OnCase06: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case06 value."
      }
      output#OnCase07: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case07 value."
      }
      output#OnCase08: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case08 value."
      }
      output#OnCase09: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case09 value."
      }
      output#OnCase10: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case10 value."
      }
      output#OnCase11: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case11 value."
      }
      output#OnCase12: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case12 value."
      }
      output#OnCase13: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case13 value."
      }
      output#OnCase14: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case14 value."
      }
      output#OnCase15: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case15 value."
      }
      output#OnCase16: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case16 value."
      }
      output#OnDefault: =
      {
        txt = "&"
        hint = "Fired when the input value does not equal any of the Case valu"
         "es."
      }
    }
    logic_multicompare:form =
    {
      t_Targetname = !
      IntegerValue: =
      {
        txt = "&"
        hint = "Integer Value (optional)"
      }
      ShouldComparetoValue: =
      {
        txt = "&"
        hint = "Should use Integer Value"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#InputValue: =
      {
        txt = "&"
        hint = "Input value"
      }
      input#CompareValues: =
      {
        txt = "&"
        hint = "Compares the values and fires appropriate outputs"
      }
      output#OnEqual: =
      {
        txt = "&"
        hint = "Fires if the values are equal"
      }
      output#OnNotEqual: =
      {
        txt = "&"
        hint = "Fires if the values are not equal"
      }
    }
    logic_relay:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Only trigger once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Allow fast retrigger"
      }
      input#Trigger: =
      {
        txt = "&"
        hint = "Trigger the relay, causing its OnTrigger output to fire if it "
         "is enabled."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the relay between enabled and disabled."
      }
      input#CancelPending: =
      {
        txt = "&"
        hint = "Cancel any events fired by this relay that are currently pendi"
         "ng in the I/O event queue."
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired when the relay is triggered."
      }
    }
    logic_timer:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Oscillator (alternates between OnTimerHigh and OnTimerLow outpu"
         "ts)"
      }
      UseRandomTime: =
      {
        txt = "&"
        hint = "Use Random Time"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      LowerRandomBound: =
      {
        txt = "&"
        hint = "Minimum Random Interval"
      }
      UpperRandomBound: =
      {
        txt = "&"
        hint = "Maximum Random Interval"
      }
      RefireTime: =
      {
        txt = "&"
        hint = "Refire Interval"
      }
      input#RefireTime: =
      {
        txt = "&"
        hint = "Set a new Refire Interval."
      }
      input#FireTimer: =
      {
        txt = "&"
        hint = "Force the timer to fire immediately."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the timer."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the timer."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the timer on/off."
      }
      input#LowerRandomBound: =
      {
        txt = "&"
        hint = "Set a new Minimum Random Interval."
      }
      input#UpperRandomBound: =
      {
        txt = "&"
        hint = "Set a new Maximum Random Interval."
      }
      output#OnTimer: =
      {
        txt = "&"
        hint = "Fired when the timer expires."
      }
      output#OnTimerHigh: =
      {
        txt = "&"
        hint = "Fired every other time for an oscillating timer."
      }
      output#OnTimerLow: =
      {
        txt = "&"
        hint = "Fired every other time for an oscillating timer."
      }
    }
    logic_collision_pair:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      attach1: =
      {
        txt = "&"
        hint = "Attachment 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Attachment 2"
      }
      startdisabled: =
      {
        txt = "&"
        hint = "Start with collisions disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableCollisions: =
      {
        txt = "&"
        hint = "Enable collisions between the first and second entity."
      }
      input#DisableCollisions: =
      {
        txt = "&"
        hint = "Disable collisions between the first and second entity."
      }
    }
    env_microphone:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Measure target"
      }
      SpeakerName: =
      {
        txt = "&"
        hint = "Speaker"
      }
      ListenFilter: =
      {
        txt = "&"
        hint = "Listen Filter"
      }
      speaker_dsp_preset: =
      {
        txt = "&"
        hint = "Speaker DSP Preset"
        typ = "C"
        items = "Use Default"$0D"1 NO EFFECT"$0D"2 (DUPLICATE OF 1)"$0D"3 (DUP"
         "LICATE OF 1)"$0D"4 (DUPLICATE OF 1)"$0D"5 (DUPLICATE OF 1)"$0D"6 SPE"
         "AKER, LOUDER"$0D"7 SPEAKER VERY SMALL"$0D"8 LOUDSPEAKER, ECHO"$0D"9 "
         "SPEAKER SMALL"$0D"10 SPEAKER TINY"
        values = "0"$0D"50"$0D"51"$0D"52"$0D"53"$0D"54"$0D"55"$0D"56"$0D"57"$0D
         "58"$0D"59"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Hears combat sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Hears world sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Hears player sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Hears bullet impacts"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Swallows sounds routed through speakers"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Hears explosions"
      }
      Sensitivity: =
      {
        txt = "&"
        hint = "Sensitivity (0 - 10)"
      }
      SmoothFactor: =
      {
        txt = "&"
        hint = "Smoothing (0 - 1)"
      }
      MaxRange: =
      {
        txt = "&"
        hint = "Maximum hearing range (0=infinite)"
      }
      input#SetSpeakerName: =
      {
        txt = "&"
        hint = "Set the microphone to output through a different speaker entit"
         "y."
      }
      output#SoundLevel: =
      {
        txt = "&"
        hint = "Fired in Measuring mode whenever the sound level changes."
      }
      output#OnRoutedSound: =
      {
        txt = "&"
        hint = "Fired whenever a sound is routed out through the specified spe"
         "aker (if any)."
      }
      output#OnHeardSound: =
      {
        txt = "&"
        hint = "Fired whenever this microphone hears any sound it cares about."
      }
    }
    math_remap:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Ignore out of range input values"
      }
      in1: =
      {
        txt = "&"
        hint = "Minimum Valid Input Value"
      }
      in2: =
      {
        txt = "&"
        hint = "Maximum Valid Input Value"
      }
      out1: =
      {
        txt = "&"
        hint = "Output Value When Input Is Min."
      }
      out2: =
      {
        txt = "&"
        hint = "Output Value When Input Is Max."
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Input value and fire the output with the remapped value."
      }
      output#OutValue: =
      {
        txt = "&"
        hint = "Fired when the InValue input is received, with the remapped in"
         "put value as the parameter."
      }
    }
    math_colorblend:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Ignore out of range input values"
      }
      inmin: =
      {
        txt = "&"
        hint = "Minimum Valid Input Value"
      }
      inmax: =
      {
        txt = "&"
        hint = "Maximum Valid Input Value"
      }
      colormin: =
      {
        txt = "&"
        hint = "Output RGB color when input is min."
      }
      colormax: =
      {
        txt = "&"
        hint = "Output RGB color when input is max."
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Input value and fire the output with the remapped value."
      }
      output#OutColor: =
      {
        txt = "&"
        hint = "Fired when the InValue input is received, with the remapped RG"
         "B color as the parameter."
      }
    }
    math_counter:form =
    {
      t_Targetname = !
      startvalue: =
      {
        txt = "&"
        hint = "Initial Value"
      }
      min: =
      {
        txt = "&"
        hint = "Minimum Legal Value"
      }
      max: =
      {
        txt = "&"
        hint = "Maximum Legal Value"
      }
      input#Add: =
      {
        txt = "&"
        hint = "Add an amount to the counter and fire the OutValue output with"
         " the result."
      }
      input#Divide: =
      {
        txt = "&"
        hint = "Divide the counter by an amount and fire the OutValue output w"
         "ith the result."
      }
      input#Multiply: =
      {
        txt = "&"
        hint = "Multiply the counter by an amount and fire the OutValue output"
         " with the result."
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the counter to a new value and fire the OutValue output wi"
         "th the result."
      }
      input#SetValueNoFire: =
      {
        txt = "&"
        hint = "Set the counter to a new value without firing any outputs."
      }
      input#Subtract: =
      {
        txt = "&"
        hint = "Subtract an amount from the counter and fire the OutValue outp"
         "ut with the result."
      }
      input#SetHitMax: =
      {
        txt = "&"
        hint = "Set the upper bound of the counter and fire the OutValue outpu"
         "t with the current value."
      }
      input#SetHitMin: =
      {
        txt = "&"
        hint = "Set the lower bound of the counter and fire the OutValue outpu"
         "t with the current value."
      }
      output#OutValue: =
      {
        txt = "&"
        hint = "Fired when the counter value changes."
      }
      output#OnHitMin: =
      {
        txt = "&"
        hint = "Fired when the counter value meets or goes below the min value"
         ". The counter must go back above the min value before the output wil"
         "l fire again."
      }
      output#OnHitMax: =
      {
        txt = "&"
        hint = "Fired when the counter value meets or exceeds the max value. T"
         "he counter must go below the max value before the output will fire a"
         "gain."
      }
    }
    logic_lineto:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      source: =
      {
        txt = "&"
        hint = "Start entity"
      }
      target: =
      {
        txt = "&"
        hint = "End entity"
      }
      output#Line: =
      {
        txt = "&"
        hint = "Fired when the vector, from the start entity to the end entity"
         ", changes. Passes along the vector as a parameter."
      }
    }
    logic_navigation:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Navigation Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      navprop: =
      {
        txt = "&"
        hint = "Nav Property"
        typ = "C"
        items = "NPCs Ignore this when navigating (they'll bump into it)"
        values = "Ignore"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on. The Navigation Entity will have it's navigation prope"
         "rties set."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off. The Navigation Entity will have it's navigation prop"
         "erties returned to the default settings."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle on/off."
      }
    }
    logic_autosave:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      NewLevelUnit: =
      {
        txt = "&"
        hint = "Force New Level Unit"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Save: =
      {
        txt = "&"
        hint = "Force an autosave."
      }
    }
    point_template:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Don't remove template entities"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Preserve entity names (Don't do name fixup)"
      }
      Template01: =
      {
        txt = "&"
        hint = "Template 1"
      }
      Template02: =
      {
        txt = "&"
        hint = "Template 2"
      }
      Template03: =
      {
        txt = "&"
        hint = "Template 3"
      }
      Template04: =
      {
        txt = "&"
        hint = "Template 4"
      }
      Template05: =
      {
        txt = "&"
        hint = "Template 5"
      }
      Template06: =
      {
        txt = "&"
        hint = "Template 6"
      }
      Template07: =
      {
        txt = "&"
        hint = "Template 7"
      }
      Template08: =
      {
        txt = "&"
        hint = "Template 8"
      }
      Template09: =
      {
        txt = "&"
        hint = "Template 9"
      }
      Template10: =
      {
        txt = "&"
        hint = "Template 10"
      }
      Template11: =
      {
        txt = "&"
        hint = "Template 11"
      }
      Template12: =
      {
        txt = "&"
        hint = "Template 12"
      }
      Template13: =
      {
        txt = "&"
        hint = "Template 13"
      }
      Template14: =
      {
        txt = "&"
        hint = "Template 14"
      }
      Template15: =
      {
        txt = "&"
        hint = "Template 15"
      }
      Template16: =
      {
        txt = "&"
        hint = "Template 16"
      }
      input#ForceSpawn: =
      {
        txt = "&"
        hint = "Spawn an instance of the template at the original position."
      }
      output#OnEntitySpawned: =
      {
        txt = "&"
        hint = "Fired after spawning an instance of this template."
      }
    }
    env_entity_maker:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Enable AutoSpawn (will spawn whenever there's room)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "AutoSpawn: Wait for entity destruction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "AutoSpawn: Even if the player is looking"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "ForceSpawn: Only if there's room"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "ForceSpawn: Only if the player isn't looking"
      }
      EntityTemplate: =
      {
        txt = "&"
        hint = "Point_template To Spawn"
      }
      input#ForceSpawn: =
      {
        txt = "&"
        hint = "Spawn an instance of the template at this origin and angle."
      }
      output#OnEntitySpawned: =
      {
        txt = "&"
        hint = "Fired when an instance of the entity template has been spawned"
         "."
      }
    }
    t_BaseFilter:incl =
    {
      t_Targetname = !
      Negated: =
      {
        txt = "&"
        hint = "Filter mode"
        typ = "C"
        items = "Allow entities that match criteria"$0D"Disallow entities that"
         " match criteria"
        values = "0"$0D"1"
      }
      input#TestActivator: =
      {
        txt = "&"
        hint = "Test the activator against the filter and fires OnPass or OnFa"
         "il output."
      }
      output#OnPass: =
      {
        txt = "&"
        hint = "Fired in response to TestActivator input if the activator pass"
         "es the filter."
      }
      output#OnFail: =
      {
        txt = "&"
        hint = "Fired in response to TestActivator input if the activator fail"
         "s to pass the filter."
      }
    }
    filter_multi:form =
    {
      t_BaseFilter = !
      filtertype: =
      {
        txt = "&"
        hint = "Logic Type"
        typ = "C"
        items = "AND (all filters must pass)"$0D"OR (any filter must pass)"
        values = "0"$0D"1"
      }
      Negated: =
      {
        txt = "&"
        hint = "Negate Outcome"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Filter01: =
      {
        txt = "&"
        hint = "Filter 1"
      }
      Filter02: =
      {
        txt = "&"
        hint = "Filter 2"
      }
      Filter03: =
      {
        txt = "&"
        hint = "Filter 3"
      }
      Filter04: =
      {
        txt = "&"
        hint = "Filter 4"
      }
      Filter05: =
      {
        txt = "&"
        hint = "Filter 5"
      }
    }
    filter_activator_name:form =
    {
      t_BaseFilter = !
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
    }
    filter_activator_class:form =
    {
      t_BaseFilter = !
      filterclass: =
      {
        txt = "&"
        hint = "Filter Classname"
      }
    }
    filter_activator_team:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_BaseFilter = !
      filterteam: =
      {
        txt = "&"
        hint = "Filter Team Number"
        typ = "C"
        items = "Team 1 (blue)"$0D"Team 2 (red)"
        values = "1"$0D"2"
      }
    }
    filter_damage_type:form =
    {
      t_BaseFilter = !
      damagetype: =
      {
        txt = "&"
        hint = "Damage type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
    }
    point_anglesensor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Target Entity Name"
      }
      lookatname: =
      {
        txt = "&"
        hint = "Look At Entity"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration"
      }
      tolerance: =
      {
        txt = "&"
        hint = "Tolerance"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the sensor between enabled and disabled."
      }
      input#Test: =
      {
        txt = "&"
        hint = "Check to see if the Target Entity is facing the Look At Entity"
         " within the specified tolerance, firing either the OnFacingLookat or"
         " OnNotFacingLookat output based on the result."
      }
      output#TargetDir: =
      {
        txt = "&"
        hint = "Fired when the forward direction of the Target Entity changes."
         " Passes the new forward direction as a parameter."
      }
      output#OnFacingLookat: =
      {
        txt = "&"
        hint = "Fired when the Target Entity points at the Look At Entity for "
         "more than the specified Duration, or in response to a Test input."
      }
      output#OnNotFacingLookat: =
      {
        txt = "&"
        hint = "Fires in response to a Test input when the Target Entity is no"
         "t pointing at the Look At Entity."
      }
    }
    point_angularvelocitysensor:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Target Entity Name"
      }
      threshold: =
      {
        txt = "&"
        hint = "Threshold Velocity"
      }
      input#Test: =
      {
        txt = "&"
        hint = "Checks to see if the Target Entity's angular velocity meets or"
         " exceeds the Threshold Velocity, firing either the OnGreaterThanOrEq"
         "ualTo or OnLessThan output based on the result."
      }
      output#AngularVelocity: =
      {
        txt = "&"
        hint = "Fired when the Target's Angular Velocity changes, passing the "
         "new magnitude of the angular velocity."
      }
      output#OnGreaterThan: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from slower than the thresho"
         "ld angular velocity to faster than the threshold angular velocity."
      }
      output#OnGreaterThanOrEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from slower than the thresho"
         "ld angular velocity to faster than the threshold angular velocity."
      }
      output#OnLessThan: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from faster than the thresho"
         "ld angular velocity to slower than the threshold angular velocity."
      }
      output#OnLessThanOrEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from faster than the thresho"
         "ld angular velocity to slower than the threshold angular velocity."
      }
      output#OnEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity reaches the threshold angular vel"
         "ocity from a different velocity."
      }
    }
    point_teleport:form =
    {
      t_Targetname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Entity To Teleport"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Teleport Home"
      }
      input#Teleport: =
      {
        txt = "&"
        hint = "Teleport the target entity."
      }
    }
    point_hurt:form =
    {
      t_Targetname = !
      DamageTarget: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      DamageRadius: =
      {
        txt = "&"
        hint = "Radius"
      }
      Damage: =
      {
        txt = "&"
        hint = "Damage"
      }
      DamageDelay: =
      {
        txt = "&"
        hint = "Delay"
      }
      DamageType: =
      {
        txt = "&"
        hint = "Damage Type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
      input#Hurt: =
      {
        txt = "&"
        hint = "Force a single fire, damaging either the Target Entity or all "
         "entities within the radius."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable this entity. It will start damaging entities everytime "
         "it fires, and refire based upon the specified Delay."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable this entity. It will stop damaging entities."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle this entity between On/Off state."
      }
    }
    point_playermoveconstraint:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      width: =
      {
        txt = "&"
        hint = "Constraint Width"
      }
      speedfactor: =
      {
        txt = "&"
        hint = "Speed Factor"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Start constraining any players within the radius."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Stop constraining any players previously constrained."
      }
      output#OnConstraintBroken: =
      {
        txt = "&"
        hint = "Fired when a player breaks through the constraint."
      }
    }
    func_physbox:form =
    {
      t_BreakableBrush = !
      t_Targetname = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Ignore +USE for Pickup"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Use Preferred Carry Angles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Enable motion on Physcannon grab"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Not affected by rotor wash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Generate output on +USE "
      }
      Damagetype: =
      {
        txt = "&"
        hint = "Impact Damage Type"
        typ = "C"
        items = "Blunt"$0D"Sharp"
        values = "0"$0D"1"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override Parameters"
      }
      damagetoenablemotion: =
      {
        txt = "&"
        hint = "Health Level to Override Motion"
      }
      forcetoenablemotion: =
      {
        txt = "&"
        hint = "Physics Impact Force to Override Motion"
      }
      health: =
      {
        txt = "&"
        hint = "Strength"
      }
      preferredcarryangles: =
      {
        txt = "&"
        hint = "Preferred Player-carry Angles"
      }
      notsolid: =
      {
        txt = "&"
        hint = "Not solid to world"
        typ = "C"
        items = "Solid to World"$0D"Passes through World"
        values = "0"$0D"1"
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wake up this physics object, if it is sleeping."
      }
      input#Sleep: =
      {
        txt = "&"
        hint = "Put this physics object to sleep. It will wake if given the Wa"
         "ke input, or if force is applied to it. Note that physics objects go"
         " to sleep automatically after coming to rest for a while, so you don"
         "'t really need to use this."
      }
      input#EnableMotion: =
      {
        txt = "&"
        hint = "Enable physics motion/collision response."
      }
      input#DisableMotion: =
      {
        txt = "&"
        hint = "Disable physics motion/collision response."
      }
      input#ForceDrop: =
      {
        txt = "&"
        hint = "If this object is being carried by a player, with the physgun "
         "or +USE, force it to be dropped."
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when this entity is damaged."
      }
      output#OnAwakened: =
      {
        txt = "&"
        hint = "Fired when this entity becomes awake (collision/force is appli"
         "ed)."
      }
      output#OnMotionEnabled: =
      {
        txt = "&"
        hint = "Fired when motion is enabled due to damage/physcannon/force."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Fired when a player picks this object up, either with the phys"
         "gun or +USE."
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Fired when a player drops this object."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player tries to +USE the physbox. This output w"
         "ill fire only if the Generate output on +USE spawnflag is set."
      }
    }
    t_TwoObjectPhysics:incl =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Start inactive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Change mass to keep stable attachment to world"
      }
      attach1: =
      {
        txt = "&"
        hint = "Entity 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Entity 2"
      }
      constraintsystem: =
      {
        txt = "&"
        hint = "Constraint System Manager"
      }
      forcelimit: =
      {
        txt = "&"
        hint = "Force Limit to Break (lbs)"
      }
      torquelimit: =
      {
        txt = "&"
        hint = "Torque Limit to Break (lbs * distance)"
      }
      breaksound: =
      {
        txt = "&"
        hint = "Play Sound on Break"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Force the constraint to break."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable the constraint.  Do this when the objects don't exist w"
         "hen the constraint spawns - or when you have deactivated the constra"
         "int.  Broken constraints can NOT be turned on.  They have been delet"
         "ed."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable this constraint."
      }
      output#OnBreak: =
      {
        txt = "&"
        hint = "Fired when the constraint breaks."
      }
    }
    phys_constraintsystem:form =
    {
      t_Targetname = !
      additionaliterations: =
      {
        txt = "&"
        hint = "Additional System Iterations"
      }
    }
    phys_keepupright:form =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start inactive"
      }
      attach1: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      angularlimit: =
      {
        txt = "&"
        hint = "Angular Limit"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable the controller."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable the controller."
      }
    }
    physics_cannister:form =
    {
      t_Targetname = !
      t_Angles = !
      t_modelselect = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Explodes"
      }
      expdamage: =
      {
        txt = "&"
        hint = "Explosion Damage"
      }
      expradius: =
      {
        txt = "&"
        hint = "Explosion Radius"
      }
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      thrust: =
      {
        txt = "&"
        hint = "Thrust"
      }
      fuel: =
      {
        txt = "&"
        hint = "Fuel Seconds"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Smoke Color (R G B)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Smoke Alpha (0 - 255)"
      }
      gassound: =
      {
        txt = "&"
        hint = "Thruster Sound"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Start gas escaping from the cannister."
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Stop gas escaping from the cannister."
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Force the cannister to explode."
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wakes up the cannister, if it is sleeping."
      }
      output#OnActivate: =
      {
        txt = "&"
        hint = "Fired when gas starts to escape from the cannister."
      }
    }
    info_constraint_anchor:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      massScale: =
      {
        txt = "&"
        hint = "Amount to scale the mass of this body in the constraint solver"
      }
    }
    info_mass_center:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      target: =
      {
        txt = "&"
        hint = "Target object"
      }
    }
    phys_spring:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force only on stretch"
      }
      attach1: =
      {
        txt = "&"
        hint = "Entity 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Entity 2"
      }
      springaxis: =
      {
        txt = "&"
        hint = "Spring Axis"
      }
      length: =
      {
        txt = "&"
        hint = "Spring Length"
      }
      constant: =
      {
        txt = "&"
        hint = "Spring Constant"
      }
      damping: =
      {
        txt = "&"
        hint = "Damping Constant"
      }
      relativedamping: =
      {
        txt = "&"
        hint = "Relative Damping Constant"
      }
      breaklength: =
      {
        txt = "&"
        hint = "Break on Length"
      }
      input#SetSpringConstant: =
      {
        txt = "&"
        hint = "Set the Spring Constant."
      }
      input#SetSpringLength: =
      {
        txt = "&"
        hint = "Set the Spring Length."
      }
      input#SetSpringDamping: =
      {
        txt = "&"
        hint = "Set the Spring Damping."
      }
    }
    phys_hinge:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_TwoObjectPhysics = !
      hingefriction: =
      {
        txt = "&"
        hint = "Friction"
      }
      hingeaxis: =
      {
        txt = "&"
        hint = "Hinge Axis"
      }
      SystemLoadScale: =
      {
        txt = "&"
        hint = "Load Scale"
      }
      input#SetAngularVelocity: =
      {
        txt = "&"
        hint = "Set angular velocity around the hinge (motor)"
      }
    }
    phys_ballsocket:form =
    {
      t_TwoObjectPhysics = !
    }
    phys_constraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
    }
    phys_pulleyconstraint:form =
    {
      t_TwoObjectPhysics = !
      addlength: =
      {
        txt = "&"
        hint = "Additional Length"
      }
      gearratio: =
      {
        txt = "&"
        hint = "Pulley Gear Ratio"
      }
      position2: =
      {
        txt = "&"
        hint = "Pulley Position 2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Keep Rigid"
      }
    }
    phys_slideconstraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Limit Endpoints"
      }
      slideaxis: =
      {
        txt = "&"
        hint = "Sliding Axis"
      }
      slidefriction: =
      {
        txt = "&"
        hint = "Friction"
      }
      SystemLoadScale: =
      {
        txt = "&"
        hint = "Load Scale"
      }
      input#SetVelocity: =
      {
        txt = "&"
        hint = "Set linear velocity along the constraint"
      }
    }
    phys_lengthconstraint:form =
    {
      t_TwoObjectPhysics = !
      addlength: =
      {
        txt = "&"
        hint = "Additional Length"
      }
      minlength: =
      {
        txt = "&"
        hint = "Minimum Length"
      }
      attachpoint: =
      {
        txt = "&"
        hint = "Attached object 2 point"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Keep Rigid"
      }
    }
    phys_ragdollconstraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Only limit rotation (free movement)"
      }
      xmin: =
      {
        txt = "&"
        hint = "X axis min limit"
      }
      xmax: =
      {
        txt = "&"
        hint = "X axis max limit"
      }
      ymin: =
      {
        txt = "&"
        hint = "Y axis min limit"
      }
      ymax: =
      {
        txt = "&"
        hint = "Y axis max limit"
      }
      zmin: =
      {
        txt = "&"
        hint = "Z axis min limit"
      }
      zmax: =
      {
        txt = "&"
        hint = "Z axis max limit"
      }
      xfriction: =
      {
        txt = "&"
        hint = "X axis friction"
      }
      yfriction: =
      {
        txt = "&"
        hint = "Y axis friction"
      }
      zfriction: =
      {
        txt = "&"
        hint = "Z axis friction"
      }
    }
    phys_convert:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Convert Asleep"
      }
      target: =
      {
        txt = "&"
        hint = "Entity to convert"
      }
      swapmodel: =
      {
        txt = "&"
        hint = "Model Swap Entity"
      }
      output#OnConvert: =
      {
        txt = "&"
        hint = "Fires after the conversion has taken place."
      }
      input#ConvertTarget: =
      {
        txt = "&"
        hint = "Converts this entity's target to a physically simulated object"
         "."
      }
    }
    t_ForceController:incl =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Apply Force"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Apply Torque"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Orient Locally"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Ignore Mass"
      }
      attach1: =
      {
        txt = "&"
        hint = "Attached Object"
      }
      forcetime: =
      {
        txt = "&"
        hint = "Time of Force (0=inf)"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Turn the force on"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Turn the force off"
      }
      input#Scale: =
      {
        txt = "&"
        hint = "Set Force Scale"
      }
    }
    phys_thruster:form =
    {
      t_Angles = !
      t_ForceController = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Ignore Pos"
      }
      force: =
      {
        txt = "&"
        hint = "Force"
      }
    }
    phys_torque:form =
    {
      t_ForceController = !
      force: =
      {
        txt = "&"
        hint = "Angular Acceleration"
      }
      axis: =
      {
        txt = "&"
        hint = "Rotation Axis"
      }
    }
    phys_motor:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      speed: =
      {
        txt = "&"
        hint = "Rotation Speed"
      }
      spinup: =
      {
        txt = "&"
        hint = "Spin up time"
      }
      inertiafactor: =
      {
        txt = "&"
        hint = "System Interia Scale"
      }
      axis: =
      {
        txt = "&"
        hint = "Rotation Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No world collision"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Hinge Object"
      }
      attach1: =
      {
        txt = "&"
        hint = "Attached Object"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Sets target speed"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns motor on"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns motor off"
      }
    }
    t_prop_detail_base:incl =
    {
      t_modelselect = !
    }
    t_prop_static_base:incl =
    {
      t_Angles = !
      t_DXLevelChoice = !
      t_modelselect = !
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"$0D"Use Bounding Box"$0D"Use VPhysics"
        values = "0"$0D"2"$0D"6"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Disable Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      screenspacefade: =
      {
        txt = "&"
        hint = "Screen Space Fade"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist/Pixels"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist/Pixels"
      }
      fadescale: =
      {
        txt = "&"
        hint = "Fade Scale"
      }
      lightingorigin: =
      {
        txt = "&"
        hint = "Lighting Origin"
      }
    }
    t_prop_dynamic_base:incl =
    {
      t_Parentname = !
      t_Global = !
      t_Angles = !
      t_Studiomodel = !
      t_BreakableProp = !
      t_DXLevelChoice = !
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"$0D"Use Bounding Box"$0D"Use VPhysics"
        values = "0"$0D"2"$0D"6"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Use Hitboxes for Renderbox"
      }
      DefaultAnim: =
      {
        txt = "&"
        hint = "Default Animation"
      }
      RandomAnimation: =
      {
        txt = "&"
        hint = "Randomly Animate"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      MinAnimTime: =
      {
        txt = "&"
        hint = "Min Random Anim Time"
      }
      MaxAnimTime: =
      {
        txt = "&"
        hint = "Max Random Anim Time"
      }
      SetBodyGroup: =
      {
        txt = "&"
        hint = "Body Group"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "Fade Scale"
      }
      input#SetAnimation: =
      {
        txt = "&"
        hint = "Force the prop to play an animation. The parameter should be t"
         "he name of the animation."
      }
      input#SetDefaultAnimation: =
      {
        txt = "&"
        hint = "Set the Default Animation to the one specified in the paramete"
         "r."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "Set the visible bodygroup, by index."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Make the prop visible."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Make the prop invisible."
      }
      output#OnAnimationBegun: =
      {
        txt = "&"
        hint = "Fired whenever a new animation has begun playing."
      }
      output#OnAnimationDone: =
      {
        txt = "&"
        hint = "Fired whenever an animation is complete."
      }
    }
    prop_detail:form =
    {
      t_prop_detail_base = !
      t_modelselect = !
    }
    prop_static:form =
    {
      t_prop_static_base = !
    }
    prop_dynamic:form =
    {
      t_prop_dynamic_base = !
      t_EnableDisable = !
    }
    prop_dynamic_override:form =
    {
      t_prop_dynamic_base = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
    }
    t_BasePropPhysics:incl =
    {
      t_Targetname = !
      t_Global = !
      t_Angles = !
      t_Studiomodel = !
      t_BreakableProp = !
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Don't take physics damage"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Enable motion on Physcannon grab"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Not affected by rotor wash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Generate output on +USE "
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Prevent pickup"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Prevent motion enable on player bump"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Debris with trigger interaction"
      }
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min Damage to Hurt"
      }
      shadowcastdist: =
      {
        txt = "&"
        hint = "Shadow Cast Distance"
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
      Damagetype: =
      {
        txt = "&"
        hint = "Impact damage type"
        typ = "C"
        items = "Blunt"$0D"Sharp"
        values = "0"$0D"1"
      }
      nodamageforces: =
      {
        txt = "&"
        hint = "Damaging it Doesn't Push It"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      inertiaScale: =
      {
        txt = "&"
        hint = "Scale Factor For Inertia"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override Parameters"
      }
      damagetoenablemotion: =
      {
        txt = "&"
        hint = "Health Level to Override Motion"
      }
      forcetoenablemotion: =
      {
        txt = "&"
        hint = "Physics Impact Force to Override Motion"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "fade scale"
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wake up this physics object, if it is sleeping."
      }
      input#Sleep: =
      {
        txt = "&"
        hint = "Put this physics object to sleep. It will wake if given the Wa"
         "ke input, or if force is applied to it. Note that physics objects go"
         " to sleep automatically after coming to rest for a while, so you don"
         "'t really need to use this."
      }
      input#EnableMotion: =
      {
        txt = "&"
        hint = "Enable physics motion/collision response."
      }
      input#DisableMotion: =
      {
        txt = "&"
        hint = "Disable physics motion/collision response."
      }
      input#DisableFloating: =
      {
        txt = "&"
        hint = "Disable fluid/floating simulation to reduce cost."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "Set this prop's body group (from 0 - n)."
      }
      input#physdamagescale: =
      {
        txt = "&"
        hint = "Set the Physics Impact Damage Scale for this character. NOTE: "
         "0 means this feature is disabled for backwards compatibility."
      }
      input#EnableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity applies physics forces to it."
      }
      input#DisableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity does *not* apply physics forces to it."
      }
      output#OnMotionEnabled: =
      {
        txt = "&"
        hint = "Fired when motion is enabled on this prop, either via 'Health "
         "Level to Override Motion' or from the EnableMotion input."
      }
      output#OnAwakened: =
      {
        txt = "&"
        hint = "Fired when this entity becomes awake (collision/force is appli"
         "ed to it while it's asleep)."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Fired when the player picks up the prop with the physcannon or"
         " +USE."
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Fired when the player drops the prop with the physcannon or US"
         "E."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player tries to +USE the physbox. This output w"
         "ill fire only if the Generate output on +USE spawnflag is set."
      }
    }
    prop_physics_override:form =
    {
      t_BasePropPhysics = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }
    prop_physics:form =
    {
      t_BasePropPhysics = !
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }
    prop_ragdoll:form =
    {
      t_Angles = !
      t_Targetname = !
      t_Studiomodel = !
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Allow Dissolve"
      }
      angleOverride: =
      {
        txt = "&"
        hint = "Override Animation"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "fade scale"
      }
    }
    prop_dynamic_ornament:form =
    {
      t_prop_dynamic_base = !
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"
        values = "0"
      }
      InitialOwner: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      input#SetAttached: =
      {
        txt = "&"
        hint = "Attach the ornament to a different entity. Parameter should be"
         " the name of entity to attach to."
      }
      input#Detach: =
      {
        txt = "&"
        hint = "Detach from the Target Entity and become invisible. The orname"
         "nt can be re-attached with the SetAttached input."
      }
    }
    func_areaportal:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Name of Linked Door"
      }
      StartOpen: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Closed"$0D"Open"
        values = "0"$0D"1"
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the portal. When the portal is open is can be seen throug"
         "h."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the portal. When the portal is closed it cannot be seen "
         "through."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the open/closed state of the portal."
      }
    }
    func_occluder:form =
    {
      t_Targetname = !
      StartActive: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Inactive"$0D"Active"
        values = "0"$0D"1"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Deactivate the occluder, When inactive, it can be seen through"
         "."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activate the occluder. When active, it cannot be seen through."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the active/inactive state of the occluder."
      }
    }
    func_breakable:form =
    {
      t_BreakableBrush = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min Damage to Hurt"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
    }
    func_breakable_surf:form =
    {
      t_BreakableBrush = !
      t_RenderFields = !
      t_Shadow = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      fragility: =
      {
        txt = "&"
        hint = "Fragility"
      }
      upperleft: = {txt = "&" hint = "corner for positioning of broken glass"}
      upperright: = {txt = "&" hint = "corner for positioning of broken glass"}
      lowerright: = {txt = "&" hint = "corner for positioning of broken glass"}
      lowerleft: = {txt = "&" hint = "corner for positioning of broken glass"}
      surfacetype: = 
      {
        txt = "&"
        hint = "Surface Type"
        typ = "C"
        items = "Glass"$0D"Tile"
        values = "0"$0D"1"
      }
      input#Shatter: =
      {
        txt = "&"
        hint = "Shatter the window. Input a vector. First two coordinates are "
         "the X,Y center of the shattering (as values from from 0-1). The thir"
         "d coordinate is the radius of the shatter, in inches."
      }
    }
    func_conveyor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Shadow = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Push"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Not Solid"
      }
      speed: =
      {
        txt = "&"
        hint = "Conveyor Speed"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#ToggleDirection: =
      {
        txt = "&"
        hint = "ToggleDirection"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "SetSpeed"
      }
    }
    func_detail:form =
    {
      t_DXLevelChoice = !
    }
    func_illusionary:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_precipitation:form =
    {
      t_Targetname = !
      t_Parentname = !
      renderamt: =
      {
        txt = "&"
        hint = "Density (0-100%)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      preciptype: =
      {
        txt = "&"
        hint = "Precipitation Type"
        typ = "C"
        items = "Rain"$0D"Snow"
        values = "0"$0D"1"
      }
    }
    func_wall_toggle:form =
    {
      t_Targetname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Invisible"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the brush on/off. When off, the brush will be non-solid"
         " and invisible."
      }
    }
    func_water:form =
    {
      t_Door = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use Only"
      }
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      WaveHeight: =
      {
        txt = "&"
        hint = "Wave Height"
      }
    }
    func_guntarget:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      speed: =
      {
        txt = "&"
        hint = "Speed (units per second)"
      }
      target: =
      {
        txt = "&"
        hint = "First stop target"
      }
      health: =
      {
        txt = "&"
        hint = "Damage to Take"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#Start: =
      {
        txt = "&"
        hint = "Start the target moving."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the target from moving."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the target between moving and stopped."
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fires when the target is killed."
      }
    }
    t_PlatSounds:incl =
    {
      movesnd: =
      {
        txt = "&"
        hint = "Move Sound"
        typ = "C"
        items = "No Sound"$0D"big elev 1"$0D"big elev 2"$0D"tech elev 1"$0D"te"
         "ch elev 2"$0D"tech elev 3"$0D"freight elev 1"$0D"freight elev 2"$0D"h"
         "eavy elev"$0D"rack elev"$0D"rail elev"$0D"squeek elev"$0D"odd elev 1"
         $0D"odd elev 2"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"
      }
      stopsnd: =
      {
        txt = "&"
        hint = "Stop Sound"
        typ = "C"
        items = "No Sound"$0D"big elev stop1"$0D"big elev stop2"$0D"freight el"
         "ev stop"$0D"heavy elev stop"$0D"rack stop"$0D"rail stop"$0D"squeek s"
         "top"$0D"quick stop"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      volume: =
      {
        txt = "&"
        hint = "Sound Volume 0.0 - 1.0"
      }
    }
    t_Trackchange:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      t_PlatSounds = !
      height: =
      {
        txt = "&"
        hint = "Travel Altitude"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Auto Activate train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Relink track"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Start at Bottom"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Rotate Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      rotation: =
      {
        txt = "&"
        hint = "Spin amount"
      }
      train: =
      {
        txt = "&"
        hint = "Train to Switch"
      }
      toptrack: =
      {
        txt = "&"
        hint = "Top Track"
      }
      bottomtrack: =
      {
        txt = "&"
        hint = "Bottom Track"
      }
      speed: =
      {
        txt = "&"
        hint = "Move/Rotate Speed"
      }
    }
    t_BaseTrain:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Pitch (X-rot)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No User Control"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Passable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Fixed Orientation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "HL1 Train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use max peed for pitch shifting move sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Is unblockable by player"
      }
      target: =
      {
        txt = "&"
        hint = "First Stop Target"
      }
      startspeed: =
      {
        txt = "&"
        hint = "Max Speed (units / second)"
      }
      speed: =
      {
        txt = "&"
        hint = "Initial Speed (units / second)"
      }
      velocitytype: =
      {
        txt = "&"
        hint = "Change Velocity"
        typ = "C"
        items = "Instantaneously"$0D"Linear blend"$0D"Ease in/ease out"
        values = "0"$0D"1"$0D"2"
      }
      orientationtype: =
      {
        txt = "&"
        hint = "Change angles"
        typ = "C"
        items = "Never (fixed orientation)"$0D"Near path_tracks"$0D"Linear ble"
         "nd"$0D"Ease in/ease out"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      wheels: =
      {
        txt = "&"
        hint = "Distance Between the Wheels"
      }
      height: =
      {
        txt = "&"
        hint = "Height above track"
      }
      bank: =
      {
        txt = "&"
        hint = "Bank Angle on Turns"
      }
      dmg: =
      {
        txt = "&"
        hint = "Damage on Crush"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      MoveSound: =
      {
        txt = "&"
        hint = "Move Sound"
      }
      MovePingSound: =
      {
        txt = "&"
        hint = "Move Ping Sound"
      }
      StartSound: =
      {
        txt = "&"
        hint = "Start Sound"
      }
      StopSound: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      volume: =
      {
        txt = "&"
        hint = "Volume (10 = loudest)"
      }
      MoveSoundMinPitch: =
      {
        txt = "&"
        hint = "Min pitch (1-255, > 100 = higher)"
      }
      MoveSoundMaxPitch: =
      {
        txt = "&"
        hint = "Max pitch (1-255, > 100 = higher)"
      }
      MoveSoundMinTime: =
      {
        txt = "&"
        hint = "Min move sound interval"
      }
      MoveSoundMaxTime: =
      {
        txt = "&"
        hint = "Max move sound interval"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the speed of the train, as a ratio of max speed [0, 1]"
      }
      input#SetSpeedDir: =
      {
        txt = "&"
        hint = "Set the speed of the train, as a ratio of max speed. Negative "
         "values reverse the direction [-1, 1]"
      }
      input#SetSpeedReal: =
      {
        txt = "&"
        hint = "Set the speed of the train. Must be a positive value from 0 to"
         " max speed."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the train."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Start the train moving forward."
      }
      input#StartBackward: =
      {
        txt = "&"
        hint = "Start the train moving backward."
      }
      input#Resume: =
      {
        txt = "&"
        hint = "Resume the train moving in the current direction after it was "
         "stopped via the 'Stop' or 'Toggle' input."
      }
      input#Reverse: =
      {
        txt = "&"
        hint = "Reverse the direction of the train."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the train between start and stop."
      }
    }
    func_trackautochange:form =
    {
      t_Trackchange = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#Trigger: =
      {
        txt = "&"
        hint = "Trigger the track change."
      }
    }
    func_trackchange:form =
    {
      t_Trackchange = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_tracktrain:form =
    {
      t_BaseTrain = !
    }
    func_tanktrain:form =
    {
      t_BaseTrain = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fired when the tank is killed."
      }
    }
    func_traincontrols:form =
    {
      t_Parentname = !
      t_Global = !
      target: =
      {
        txt = "&"
        hint = "Train Name"
      }
    }
    tanktrain_aitarget:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Tank AI Entity"
      }
      newtarget: =
      {
        txt = "&"
        hint = "New Target Entity"
      }
    }
    tanktrain_ai:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Train Name"
      }
      startsound: =
      {
        txt = "&"
        hint = "Start Moving Sound"
      }
      enginesound: =
      {
        txt = "&"
        hint = "Engine Loop Sound"
      }
      movementsound: =
      {
        txt = "&"
        hint = "Vehicle Movement Sound"
      }
    }
    path_track:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Fire once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Branch Reverse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Disable train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Teleport to THIS path track"
      }
      target: =
      {
        txt = "&"
        hint = "Next Stop Target"
      }
      altpath: =
      {
        txt = "&"
        hint = "Branch Path"
      }
      speed: =
      {
        txt = "&"
        hint = "New Train Speed"
      }
      radius: =
      {
        txt = "&"
        hint = "Path radius"
      }
      orientationtype: =
      {
        txt = "&"
        hint = "Orientation Type"
        typ = "C"
        items = "No change"$0D"Face direction of motion"$0D"Face this path_tra"
         "ck's angles"
        values = "0"$0D"1"$0D"2"
      }
      input#ToggleAlternatePath: =
      {
        txt = "&"
        hint = "Cause the track to toggle to/from it's alternate path."
      }
      input#EnableAlternatePath: =
      {
        txt = "&"
        hint = "Enable the alternate path of the track."
      }
      input#DisableAlternatePath: =
      {
        txt = "&"
        hint = "Disable the alternate path of the track."
      }
      input#TogglePath: =
      {
        txt = "&"
        hint = "Cause the track to toggle on/off/"
      }
      input#EnablePath: =
      {
        txt = "&"
        hint = "Enable the track."
      }
      input#DisablePath: =
      {
        txt = "&"
        hint = "Disable the track."
      }
      output#OnPass: =
      {
        txt = "&"
        hint = "Fired when any entity following this path passes this path_tra"
         "ck node."
      }
    }
    test_traceline:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Angles = !
    }
    trigger_autosave:form =
    {
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master"
      }
      NewLevelUnit: =
      {
        txt = "&"
        hint = "Force New Level Unit"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    trigger_changelevel:form =
    {
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      map: =
      {
        txt = "&"
        hint = "New Map Name"
      }
      landmark: =
      {
        txt = "&"
        hint = "Landmark Name"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Disable Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "To Previous Chapter"
      }
      input#ChangeLevel: =
      {
        txt = "&"
        hint = "Cause the level change. Use this when triggering the level cha"
         "nge with a button, etc."
      }
      output#OnChangeLevel: =
      {
        txt = "&"
        hint = "Fired when the level changes."
      }
    }
    trigger_gravity:form =
    {
      t_Trigger = !
      gravity: =
      {
        txt = "&"
        hint = "Gravity (0-1)"
      }
    }
    trigger_playermovement:form =
    {
      t_Trigger = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "(OBSOLETE, Uncheck me)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Disable auto player movement"
      }
    }
    trigger_soundscape:form =
    {
      t_Trigger = !
      soundscape: =
      {
        txt = "&"
        hint = "Soundscape"
      }
    }
    trigger_hurt:form =
    {
      t_Trigger = !
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage"
      }
      damagecap: =
      {
        txt = "&"
        hint = "Damage Cap"
      }
      damagetype: =
      {
        txt = "&"
        hint = "Damage Type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
      damagemodel: =
      {
        txt = "&"
        hint = "Damage Model"
        typ = "C"
        items = "Normal"$0D"Doubling w/forgiveness"
        values = "0"$0D"1"
      }
      input#SetDamage: =
      {
        txt = "&"
        hint = "Set a new amount of damage for this trigger."
      }
      output#OnHurt: =
      {
        txt = "&"
        hint = "Fired whenever this trigger hurts something other than a playe"
         "r."
      }
      output#OnHurtPlayer: =
      {
        txt = "&"
        hint = "Fired whenever this trigger hurts a player."
      }
    }
    trigger_remove:form =
    {
      t_Trigger = !
      t_Targetname = !
      output#OnRemove: =
      {
        txt = "&"
        hint = "Fired whenever an entity is removed."
      }
    }
    trigger_multiple:form =
    {
      t_Trigger = !
      message: =
      {
        txt = "&"
        hint = "Message Text"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset"
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired whenever the trigger is activated."
      }
    }
    trigger_once:form =
    {
      t_TriggerOnce = !
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired whenever the trigger is activated."
      }
    }
    trigger_look:form =
    {
      t_Trigger = !
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Fire Once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use Velocity instead of facing"
      }
      target: =
      {
        txt = "&"
        hint = "Look Target"
      }
      LookTime: =
      {
        txt = "&"
        hint = "LookTime"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      Timeout: =
      {
        txt = "&"
        hint = "Timeout"
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired when the trigger is activated."
      }
      output#OnTimeout: =
      {
        txt = "&"
        hint = "Fired after the timeout interval expires if the player never l"
         "ooked at the target."
      }
    }
    trigger_push:form =
    {
      t_Trigger = !
      pushdir: =
      {
        txt = "&"
        hint = "Push Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Once Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Affects Ladders(hl2)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of Push"
      }
    }
    trigger_wind:form =
    {
      t_Trigger = !
      t_Angles = !
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      SpeedNoise: =
      {
        txt = "&"
        hint = "Speed Noise"
      }
      DirectionNoise: =
      {
        txt = "&"
        hint = "Direction Noise"
      }
      HoldTime: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      HoldNoise: =
      {
        txt = "&"
        hint = "Hold Noise"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the base line for how hard the wind blows."
      }
    }
    trigger_impact:form =
    {
      t_Targetname = !
      t_Angles = !
      Magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      noise: =
      {
        txt = "&"
        hint = "Noise"
      }
      viewkick: =
      {
        txt = "&"
        hint = "Viewkick"
      }
      input#Impact: =
      {
        txt = "&"
        hint = "Fire the impact, pushing all entities within the volume."
      }
      input#SetMagnitude: =
      {
        txt = "&"
        hint = "Set the magnitude of the impact."
      }
      output#ImpactForce: =
      {
        txt = "&"
        hint = "Fired after an impact. The parameter passed along is the force"
         " of the impact that was generated."
      }
    }
    trigger_proximity:form =
    {
      t_Trigger = !
      measuretarget: =
      {
        txt = "&"
        hint = "Point to Measure From"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius to measure within"
      }
      output#NearestEntityDistance: =
      {
        txt = "&"
        hint = "Fired continuously when entities are touching the trigger volu"
         "me. The output parameter is the distance from the Point to Measure F"
         "rom to the nearest entity that passed the trigger filters. The dista"
         "nce is mapped to the radius distance, so it will be 0 when the entit"
         "y is on the point, and 1 when the entity is at the edge of the radiu"
         "s."
      }
    }
    trigger_teleport:form =
    {
      t_Trigger = !
      target: =
      {
        txt = "&"
        hint = "Remote Destination"
      }
      landmark: =
      {
        txt = "&"
        hint = "Local Destination Landmark"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Preserve angles even when a local landmark is not specified"
      }
    }
    trigger_transition:form =
    {
      t_Targetname = !
    }
    trigger_waterydeath:form =
    {
      t_Trigger = !
    }
    phys_magnet:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_Studiomodel = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Suck On Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Allow Attached Rotation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Coast jeep pickup hack"
      }
      forcelimit: =
      {
        txt = "&"
        hint = "Force Limit to Break (lbs)"
      }
      torquelimit: =
      {
        txt = "&"
        hint = "Torque Limit to Break (lbs * distance)"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override parameters"
      }
      maxobjects: =
      {
        txt = "&"
        hint = "Maximum Attached Objects"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the magnet on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "The the magnet off. This will detach anything current stuck to"
         " the magnet."
      }
      output#OnAttach: =
      {
        txt = "&"
        hint = "Fired when an entity is grabbed by the magnet."
      }
      output#OnDetach: =
      {
        txt = "&"
        hint = "Fired when an entity is released by the magnet."
      }
    }
    material_modify_control:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Parentname = !
      t_Targetname = !
      materialName: =
      {
        txt = "&"
        hint = "Material to modify."
      }
      materialVar: =
      {
        txt = "&"
        hint = "Material variable to modify."
      }
      input#SetMaterialVar: =
      {
        txt = "&"
        hint = "Fire to modify a material variable. The argument is the value "
         "to set the variable to."
      }
      input#SetMaterialVarToCurrentTime: =
      {
        txt = "&"
        hint = "This sets the material variable to the current time on the ser"
         "ver."
      }
    }
    ai_speechfilter:form =
    {
      t_Targetname = !
      t_ResponseContext = !
      subject: =
      {
        txt = "&"
        hint = "Subject(s)"
      }
      IdleModifier: =
      {
        txt = "&"
        hint = "Idle modifier."
      }
      NeverSayHello: =
      {
        txt = "&"
        hint = "Greet Player?"
        typ = "C"
        items = "Yes"$0D"No"
        values = "0"$0D"1"
      }
    }
    water_lod_control:form =
    {
      t_Targetname = !
      cheapwaterstartdistance: =
      {
        txt = "&"
        hint = "Start Transition to Cheap Water"
      }
      cheapwaterenddistance: =
      {
        txt = "&"
        hint = "End Transition to Cheap Water"
      }
      input#SetCheapWaterStartDistance: =
      {
        txt = "&"
        hint = "Set the distance that water starts transitioning to cheap wate"
         "r."
      }
      input#SetCheapWaterEndDistance: =
      {
        txt = "&"
        hint = "Set the distance that water finishes transitioning to cheap wa"
         "ter."
      }
    }
    info_camera_link:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Entity Whose Material Uses _rt_camera"
      }
      PointCamera: =
      {
        txt = "&"
        hint = "Camera Name"
      }
      input#SetCamera: =
      {
        txt = "&"
        hint = "Set the camera to use. The parameter should be the name of a p"
         "oint_camera entity in the map."
      }
    }
    logic_measure_movement:form =
    {
      t_Targetname = !
      MeasureTarget: =
      {
        txt = "&"
        hint = "Entity to Measure"
      }
      MeasureReference: =
      {
        txt = "&"
        hint = "Measure Reference"
      }
      Target: =
      {
        txt = "&"
        hint = "Entity to Move"
      }
      TargetReference: =
      {
        txt = "&"
        hint = "Movement Reference"
      }
      TargetScale: =
      {
        txt = "&"
        hint = "Movement scale"
      }
      MeasureType: =
      {
        txt = "&"
        hint = "Measurement Type"
        typ = "C"
        items = "Position"$0D"Eye position"
        values = "0"$0D"1"
      }
      input#SetMeasureTarget: =
      {
        txt = "&"
        hint = "Set the Entity to Measure, whose movement should be measured."
      }
      input#SetMeasureReference: =
      {
        txt = "&"
        hint = "Set the Measure Reference entity."
      }
      input#Target: =
      {
        txt = "&"
        hint = "Set the Entity to Move, which will be moved to mimic the measu"
         "red entity."
      }
      input#SetTargetReference: =
      {
        txt = "&"
        hint = "Set the Movement Reference entity."
      }
      input#SetTargetScale: =
      {
        txt = "&"
        hint = "Set the scale to divide the measured movements by."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the logic_measure_movement."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the logic_measure_movement."
      }
    }
    prop_physics_multiplayer:form =
    {
      t_BasePropPhysics = !
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }
    npc_furniture:form =
    {
      t_BaseNPC = !
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
    }
    env_credits:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#RollCredits: =
      {
        txt = "&"
        hint = "Start the intro credits rolling."
      }
      input#RollOutroCredits: =
      {
        txt = "&"
        hint = "Start the outro credits rolling."
      }
      input#ShowLogo: =
      {
        txt = "&"
        hint = "Show the HL2 logo."
      }
      output#OnCreditsDone: =
      {
        txt = "&"
        hint = "Fired when the credits having finished rolling."
      }
    }
    t_TalkNPC:incl =
    {
      t_BaseNPC = !
      UseSentence: =
      {
        txt = "&"
        hint = "Use Sentence"
      }
      UnUseSentence: =
      {
        txt = "&"
        hint = "Un-Use Sentence"
      }
    }
    t_RappelNPC:incl =
    {
      t_BaseNPC = !
      waitingtorappel: =
      {
        txt = "&"
        hint = "Waiting to Rappel?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#BeginRappel: =
      {
        txt = "&"
        hint = "BeginRappel"
      }
      output#OnRappelTouchdown: =
      {
        txt = "&"
        hint = "Fires when done rappeling"
      }
    }
    prop_combine_ball:form =
    {
      t_BasePropPhysics = !
      input#Explode: =
      {
        txt = "&"
        hint = "Explode"
      }
    }
    trigger_physics_trap:form =
    {
      t_Trigger = !
      t_Angles = !
      dissolvetype: =
      {
        txt = "&"
        hint = "Dissolve Type"
        typ = "C"
        items = "Energy"$0D"Heavy electrical"$0D"Light electrical"
        values = "0"$0D"1"$0D"2"
      }
    }
    trigger_weapon_dissolve:form =
    {
      t_Trigger = !
      emittername: =
      {
        txt = "&"
        hint = "Emitter Name"
      }
      output#OnDissolveWeapon: =
      {
        txt = "&"
        hint = "Fires when one weapon is starting to dissolve in the trigger v"
         "olume."
      }
      output#OnChargingPhyscannon: =
      {
        txt = "&"
        hint = "Fires when the trigger begins to charge the physcannon."
      }
      input#StopSound: =
      {
        txt = "&"
        hint = "Stops all sounds."
      }
    }
    trigger_weapon_strip:form =
    {
      t_Trigger = !
      KillWeapons: =
      {
        txt = "&"
        hint = "Kill Weapons"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    trigger_super_armor:form =
    {
      t_Trigger = !
    }
    func_combine_ball_spawner:form =
    {
      t_Targetname = !
      t_Origin = !
      t_Angles = !
      t_Global = !
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Start inactive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Combine power supply"
      }
      ballcount: =
      {
        txt = "&"
        hint = "Ball count"
      }
      minspeed: =
      {
        txt = "&"
        hint = "Min ball speed"
      }
      maxspeed: =
      {
        txt = "&"
        hint = "Max ball speed"
      }
      ballradius: =
      {
        txt = "&"
        hint = "Ball radius"
      }
      balltype: =
      {
        txt = "&"
        hint = "Ball Type"
        typ = "C"
        items = "Combine Energy Ball 1"$0D"Combine Energy Ball 2"$0D"Combine E"
         "nergy Ball 3"
        values = "0"$0D"1"$0D"2"
      }
      ballrespawntime: =
      {
        txt = "&"
        hint = "Ball Respawn Time"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable spawning of combine balls"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable spawning of combine balls"
      }
      output#OnBallGrabbed: =
      {
        txt = "&"
        hint = "Fired when a combine ball is grabbed from the field by a mega "
         "physcannon"
      }
      output#OnBallReinserted: =
      {
        txt = "&"
        hint = "Fired when a combine ball is reinserted into the field (only g"
         "ets triggered when Combine Power supply is checked)"
      }
      output#OnBallHitTopSide: =
      {
        txt = "&"
        hint = "Fired when a combine ball in hits the top side of the field (o"
         "nly gets triggered when Combine Power supply is checked)"
      }
      output#OnBallHitBottomSide: =
      {
        txt = "&"
        hint = "Fired when a combine ball in hits the bottom side of the field"
         " (only gets triggered when Combine Power supply is checked)"
      }
      output#OnLastBallGrabbed: =
      {
        txt = "&"
        hint = "Fired when the last combine ball is grabbed from the field by "
         "a mega physcannon"
      }
      output#OnFirstBallReinserted: =
      {
        txt = "&"
        hint = "Fired when the first combine ball is reinserted into the field"
         " (only gets triggered when Combine Power supply is checked)"
      }
    }
    npc_combine_camera:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Always Become Angry On New Enemy"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Ignore Enemies (Scripted Targets Only)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Start Inactive"
      }
      innerradius: =
      {
        txt = "&"
        hint = "Inner radius"
      }
      outerradius: =
      {
        txt = "&"
        hint = "Outer radius"
      }
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min req'd damage for hurting camera"
      }
      defaulttarget: =
      {
        txt = "&"
        hint = "Default target"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disables the camera. If open, the camera closes."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enables the camera. If closed, the camera opens."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle - If open, close. If closed, open."
      }
      input#SetDefaultTargetEntity: =
      {
        txt = "&"
        hint = "Sets the entity for the camera to track when it has nothing be"
         "tter to track, by name."
      }
      input#SetTargetEntity: =
      {
        txt = "&"
        hint = "Sets the entity for the camera to track now, by name."
      }
      input#SetAngry: =
      {
        txt = "&"
        hint = "Causes the camera to become angry as if it has seen something "
         "upsetting."
      }
      input#SetIdle: =
      {
        txt = "&"
        hint = "Causes the camera to calm down if it is angry."
      }
      output#OnFoundPlayer: =
      {
        txt = "&"
        hint = "Fired when the player is spotted within the inner radius"
      }
      output#OnFoundEnemy: =
      {
        txt = "&"
        hint = "Fired when a non-player enemy is spotted within the inner radi"
         "us."
      }
    }
    npc_turret_ground:form =
    {
      t_BaseNPC = !
      t_Parentname = !
      input#Enable: =
      {
        txt = "&"
        hint = "Turn turret on."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Turn turret off."
      }
      output#OnAreaClear: =
      {
        txt = "&"
        hint = "Fires when the turret can't find any more enemies (7 second de"
         "lay)"
      }
    }
    npc_turret_ceiling:form =
    {
      t_Targetname = !
      t_Angles = !
      t_Studiomodel = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Autostart"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Start Inactive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Never Retire"
      }
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min req'd damage for hurting turret"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "If closed, open."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "If open, close."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle - If open, close. If closed, open."
      }
      output#OnDeploy: =
      {
        txt = "&"
        hint = "Turret is becoming active and dangerous."
      }
      output#OnRetire: =
      {
        txt = "&"
        hint = "Turret is becoming inactive and harmless."
      }
      output#OnTipped: =
      {
        txt = "&"
        hint = "Turret has been tipped over and is inactive."
      }
    }
    npc_turret_floor:form =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Autostart"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Start Inactive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Fast Retire"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle - If open, close. If closed, open."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the turret."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the turret."
      }
      output#OnDeploy: =
      {
        txt = "&"
        hint = "Turret is becoming active and dangerous."
      }
      output#OnRetire: =
      {
        txt = "&"
        hint = "Turret is becoming inactive and harmless."
      }
      output#OnTipped: =
      {
        txt = "&"
        hint = "Turret has been tipped over and is inactive."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Picked up with physgun"
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Released by physgun"
      }
    }
    t_VehicleDriverNPC:incl =
    {
      t_BaseNPC = !
      vehicle: =
      {
        txt = "&"
        hint = "Vehicle to drive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Start Inactive"
      }
      input#StartFiring: =
      {
        txt = "&"
        hint = "Tell the driver to attack nearby enemies with the vehicle's we"
         "aponry (if any)"
      }
      input#StopFiring: =
      {
        txt = "&"
        hint = "Tell the driver to stop attacking nearby enemies with the vehi"
         "cle's weaponry."
      }
      input#GotoPathCorner: =
      {
        txt = "&"
        hint = "Tell the driver to go to a specific path corner and continue f"
         "rom there."
      }
    }
    npc_vehicledriver:form =
    {
      t_VehicleDriverNPC = !
      drivermaxspeed: =
      {
        txt = "&"
        hint = "Maxspeed (percentage of vehicle's maxspeed)."
      }
      driverminspeed: =
      {
        txt = "&"
        hint = "MinSpeed (percentage of vehicle's maxspeed)."
      }
      input#SetDriversMaxSpeed: =
      {
        txt = "&"
        hint = "Set the Maxspeed (percentage of vehicle's maxspeed)."
      }
      input#SetDriversMinSpeed: =
      {
        txt = "&"
        hint = "Set the Minspeed (percentage of vehicle's maxspeed)."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Tell the driver to start driving."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Tell the driver to stop driving."
      }
    }
    npc_cranedriver:form =
    {
      t_VehicleDriverNPC = !
      releasepause: =
      {
        txt = "&"
        hint = "Pause time before dropping a ForceDrop specified object."
      }
      input#ForcePickup: =
      {
        txt = "&"
        hint = "Force the driver to pickup the specified entity (by targetname"
         ")"
      }
      input#ForceDrop: =
      {
        txt = "&"
        hint = "Force the driver to drop the currently held object at the spec"
         "ified entity's location."
      }
      output#OnPickedUpObject: =
      {
        txt = "&"
        hint = "Fired when the ForcePickup specified object has been picked up"
         "."
      }
      output#OnDroppedObject: =
      {
        txt = "&"
        hint = "Fired when the ForceDrop specified object has been dropped."
      }
      output#OnPausingBeforeDrop: =
      {
        txt = "&"
        hint = "Fired at the start of the pause before dropping the ForceDrop "
         "specified object."
      }
    }
    npc_apcdriver:form =
    {
      t_VehicleDriverNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "No Rocket Attacks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "No Gun Attacks"
      }
      drivermaxspeed: =
      {
        txt = "&"
        hint = "Maxspeed (percentage of vehicle's maxspeed)."
      }
      driverminspeed: =
      {
        txt = "&"
        hint = "MinSpeed (percentage of vehicle's maxspeed)."
      }
      input#SetDriversMaxSpeed: =
      {
        txt = "&"
        hint = "Set the Maxspeed (percentage of vehicle's maxspeed)."
      }
      input#SetDriversMinSpeed: =
      {
        txt = "&"
        hint = "Set the Minspeed (percentage of vehicle's maxspeed)."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Tell the driver to start driving."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Tell the driver to stop driving."
      }
      input#DisableFiring: =
      {
        txt = "&"
        hint = "Disables firing from happening"
      }
      input#EnableFiring: =
      {
        txt = "&"
        hint = "Enables firing to start. Firing is enabled by default"
      }
    }
    npc_apc:form =
    {
      t_BaseNPC = !
    }
    npc_roller:form =
    {
      t_BaseNPC = !
    }
    npc_rollerturret:form =
    {
      t_BaseNPC = !
    }
    npc_rollerdozer:form =
    {
      t_BaseNPC = !
    }
    npc_rollerbuddy:form =
    {
      t_BaseNPC = !
    }
    npc_rollerbull:form =
    {
      t_BaseNPC = !
    }
    npc_rollermine:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Friendly"
      }
      startburied: =
      {
        txt = "&"
        hint = "Start Buried"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Picked up with physgun"
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Released by physgun"
      }
    }
    npc_missiledefense:form =
    {
      t_BaseNPC = !
    }
    npc_sniper:form =
    {
      t_BaseNPC = !
      radius: =
      {
        txt = "&"
        hint = "Patience Radius"
      }
      misses: =
      {
        txt = "&"
        hint = "Initial Misses"
      }
      beambrightness: =
      {
        txt = "&"
        hint = "Beam Brightness (0 to 255)"
      }
      shielddistance: =
      {
        txt = "&"
        hint = "Bullet shield distance"
      }
      shieldradius: =
      {
        txt = "&"
        hint = "Bullet shield radius"
      }
      input#EnableSniper: =
      {
        txt = "&"
        hint = "Enable Shooting"
      }
      input#DisableSniper: =
      {
        txt = "&"
        hint = "Disable Shooting"
      }
      input#SetDecoyRadius: =
      {
        txt = "&"
        hint = "Set Decoy Radius"
      }
      input#SweepTarget: =
      {
        txt = "&"
        hint = "Sweep a Target"
      }
      input#SweepTargetHighestPriority: =
      {
        txt = "&"
        hint = "Drop everything and sweep this target!"
      }
      input#SweepGroupRandomly: =
      {
        txt = "&"
        hint = "Randomly Sweep a Group"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Hidden"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Laser Viewcone"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "No Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Start Disabled"
      }
    }
    info_snipertarget:form =
    {
      t_Targetname = !
      t_Parentname = !
      speed: =
      {
        txt = "&"
        hint = "Sweep to speed"
      }
      groupname: =
      {
        txt = "&"
        hint = "Group Name"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Shoot Me"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No Interruptions"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Snap Shot"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Resume if Interrupted"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Snap to me"
      }
    }
    prop_thumper:form =
    {
      t_Targetname = !
      t_Angles = !
      t_modelselect = !
      dustscale: =
      {
        txt = "&"
        hint = "Dust Scale"
        typ = "C"
        items = "Small Thumper"$0D"Large Thumper"
        values = "128"$0D"256"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable Thumper"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable Thumper"
      }
    }
    npc_antlion:form =
    {
      t_BaseNPC = !
      startburrowed: =
      {
        txt = "&"
        hint = "Start Burrowed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Burrow when eluded"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Use Ground Checks"
      }
      radius: =
      {
        txt = "&"
        hint = "Alert Radius"
      }
      eludedist: =
      {
        txt = "&"
        hint = "Distance until eluded"
      }
      ignorebugbait: =
      {
        txt = "&"
        hint = "Ignore Bugbait"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Unburrow: =
      {
        txt = "&"
        hint = "Unburrow from the ground"
      }
      input#Burrow: =
      {
        txt = "&"
        hint = "Burrow into the ground"
      }
      input#FightToPosition: =
      {
        txt = "&"
        hint = "Fight to position"
      }
      input#EnableJump: =
      {
        txt = "&"
        hint = "Allow non-navigational jumping"
      }
      input#DisableJump: =
      {
        txt = "&"
        hint = "Disallow non-navigational jumping"
      }
      input#IgnoreBugbait: =
      {
        txt = "&"
        hint = "Ignore bugbait"
      }
      input#HearBugbait: =
      {
        txt = "&"
        hint = "Hear bugbait"
      }
      output#OnReachedFightGoal: =
      {
        txt = "&"
        hint = "Fires when the antlion reaches his specified fight-to location"
      }
    }
    npc_antlionguard:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Create server-side ragdoll on death"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Use inside footsteps"
      }
      startburrowed: =
      {
        txt = "&"
        hint = "Start Burrowed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      allowbark: =
      {
        txt = "&"
        hint = "Allow Bark"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Unburrow: =
      {
        txt = "&"
        hint = "Unburrow from the ground"
      }
      input#SetShoveTarget: =
      {
        txt = "&"
        hint = "Sets a shove target to attack"
      }
      input#SetChargeTarget: =
      {
        txt = "&"
        hint = "Sets a charge target to attack"
      }
      input#ClearChargeTarget: =
      {
        txt = "&"
        hint = "Clear the charge target"
      }
      input#SetCoverFromAttack: =
      {
        txt = "&"
        hint = "Sets whether or not the creature will protect itself from atta"
         "cks"
      }
      input#Ragdoll: =
      {
        txt = "&"
        hint = "Causes the antlion guard to die, regardless of health"
      }
      input#EnableBark: =
      {
        txt = "&"
        hint = "Allow the antlion guard to try and summon antlions"
      }
      input#DisableBark: =
      {
        txt = "&"
        hint = "Stop the antlion guard from trying to summon antlions"
      }
      input#InvestigateHint: =
      {
        txt = "&"
        hint = "Sniff around at a hint group until told otherwise"
      }
      input#StopInvestigating: =
      {
        txt = "&"
        hint = "Stop trying to sniff out the player"
      }
      output#OnSeeHiddenPlayer: =
      {
        txt = "&"
        hint = "Fires when the current enemy is seen while trying to hide"
      }
      output#OnSmellHiddenPlayer: =
      {
        txt = "&"
        hint = "Fires when the current enemy is smelled while trying to hide"
      }
      output#OnSummon: =
      {
        txt = "&"
        hint = "Antlion guard is attempting to summon antlions"
      }
    }
    npc_crow:form =
    {
      t_BaseNPC = !
      input#FlyAway: =
      {
        txt = "&"
        hint = "Forces the crow to fly to the nearest crow flyto hint node."
      }
    }
    npc_seagull:form =
    {
      t_BaseNPC = !
      input#FlyAway: =
      {
        txt = "&"
        hint = "Forces the seagull to fly to the nearest crow flyto hint node."
      }
    }
    npc_pigeon:form =
    {
      t_BaseNPC = !
      input#FlyAway: =
      {
        txt = "&"
        hint = "Forces the pigeon to fly to the nearest crow flyto hint node."
      }
    }
    npc_ichthyosaur:form =
    {
      t_BaseNPC = !
    }
    npc_assassin:form =
    {
      t_BaseNPC = !
    }
    t_BaseHeadcrab:incl =
    {
      t_BaseNPC = !
      startburrowed: =
      {
        txt = "&"
        hint = "Start burrowed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Start hidden"
      }
    }
    npc_headcrab:form =
    {
      t_BaseHeadcrab = !
      t_Parentname = !
    }
    npc_headcrab_fast:form =
    {
      t_BaseHeadcrab = !
    }
    npc_headcrab_black:form =
    {
      t_BaseHeadcrab = !
    }
    npc_stalker:form =
    {
      t_BaseNPC = !
      BeamPower: =
      {
        txt = "&"
        hint = "Beam Power"
        typ = "C"
        items = "Low"$0D"Medium"$0D"High"
        values = "0"$0D"1"$0D"2"
      }
    }
    npc_bullseye:form =
    {
      t_Parentname = !
      t_BaseNPC = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Not Solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Take No Damage"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Enemy Damage Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Bleed"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1048576"
        cap = "Perfect Accuracy"
      }
      output#OnTargeted: =
      {
        txt = "&"
        hint = "Fires when targeted"
      }
      output#OnReleased: =
      {
        txt = "&"
        hint = "Fires when no longer targeted"
      }
    }
    npc_enemyfinder:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Parentname = !
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Check Visibility"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "APC Visibility checks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Short memory"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Can be an enemy"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      MinSearchDist: =
      {
        txt = "&"
        hint = "Min Search Dist"
      }
      MaxSearchDist: =
      {
        txt = "&"
        hint = "Max Search Dist"
      }
      freepass_timetotrigger: =
      {
        txt = "&"
        hint = "Player pass issue time"
      }
      freepass_duration: =
      {
        txt = "&"
        hint = "Player pass duration"
      }
      freepass_movetolerance: =
      {
        txt = "&"
        hint = "Player pass move tolerance"
      }
      freepass_refillrate: =
      {
        txt = "&"
        hint = "Player pass refill rate"
      }
      freepass_peektime: =
      {
        txt = "&"
        hint = "Player pass peek time"
      }
      StartOn: =
      {
        txt = "&"
        hint = "Start On"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on: Look for enemies"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off: Stop looking for enemies"
      }
    }
    npc_citizen:form =
    {
      t_BaseNPC = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Follow player on spawn"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Medic"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Random Head"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Ammo Resupplier"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1048576"
        cap = "Not Commandable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2097152"
        cap = "Don't use Speech Semaphore"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4194304"
        cap = "Random male head"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8388608"
        cap = "Random female head"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16777216"
        cap = "Use RenderBox in ActBusies"
      }
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "SMG1"$0D"AR2"$0D"Stun Stick"$0D"Crow Bar"$0D"Shotgun"$0D"Beer"
         " Bottle"$0D"Beer Bottle2"$0D"RPG"$0D"Nothing"
        values = "weapon_smg1"$0D"weapon_ar2"$0D"weapon_stunstick"$0D"weapon_c"
         "rowbar"$0D"weapon_shotgun"$0D"weapon_beerbottle"$0D"weapon_beerbottl"
         "e2"$0D"weapon_rpg"$0D"0"
      }
      ammosupply: =
      {
        txt = "&"
        hint = "Ammo to Resupply (if spawnflag set)"
        typ = "C"
        items = "Pistol"$0D"SMG1"$0D"SMG1 Grenade"$0D"AR2"$0D"Shotgun"$0D"RPG"$0D
         "Grenade"$0D"Crossbow Bolt"
        values = "Pistol"$0D"SMG1"$0D"SMG1_Grenade"$0D"AR2"$0D"Buckshot"$0D"RP"
         "G_Round"$0D"Grenade"$0D"XBowBolt"
      }
      ammoamount: =
      {
        txt = "&"
        hint = "Amount of ammo to give"
      }
      citizentype: =
      {
        txt = "&"
        hint = "Type"
        typ = "C"
        items = "Default"$0D"Downtrodden"$0D"Refugee"$0D"Rebel"$0D"Unique"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      expressiontype: =
      {
        txt = "&"
        hint = "Expression Type"
        typ = "C"
        items = "Random"$0D"Scared"$0D"Normal"$0D"Angry"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "C"
        items = "Male 1"$0D"Male 2"$0D"Male 3"$0D"Male 4"$0D"Male 5"$0D"Male 6"
         $0D"Female 1"$0D"Female 2"$0D"Female 3"$0D"Female 4"$0D"Female 5"$0D"F"
         "emale 6"$0D"Cheaple Male 1"$0D"Odessa. DO NOT USE."
        values = "models/humans/group01/male_01.mdl"$0D"models/humans/group01/"
         "male_02.mdl"$0D"models/humans/group01/male_03.mdl"$0D"models/humans/"
         "group01/male_07.mdl"$0D"models/humans/group01/male_08.mdl"$0D"models"
         "/humans/group01/male_09.mdl"$0D"models/humans/group01/female_01.mdl"$0D
         "models/humans/group01/female_02.mdl"$0D"models/humans/group01/female"
         "_03.mdl"$0D"models/humans/group01/female_04.mdl"$0D"models/humans/gr"
         "oup01/female_06.mdl"$0D"models/humans/group01/female_07.mdl"$0D"mode"
         "ls/humans/male_cheaple.mdl"$0D"models/odessa.mdl"
      }
      ExpressionOverride: =
      {
        txt = "&"
        hint = "Facial expression override"
      }
      notifynavfailblocked: =
      {
        txt = "&"
        hint = "Fire output when Nav is blocked?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#SetExpressionOverride: =
      {
        txt = "&"
        hint = "Set facial expression override"
      }
      input#StartPatrolling: =
      {
        txt = "&"
        hint = "Patrol whenever I'm idle or alert."
      }
      input#StopPatrolling: =
      {
        txt = "&"
        hint = "Stop patrolling when I'm idle or alert."
      }
      input#SetCommandable: =
      {
        txt = "&"
        hint = "Make a previously uncommandable citizen commandable"
      }
      input#SetMedicOn: =
      {
        txt = "&"
        hint = "Set the medic flag on. Will not change the model or skin of th"
         "e citizen."
      }
      input#SetMedicOff: =
      {
        txt = "&"
        hint = "Set the medic flag off. Will not change the model or skin of t"
         "he citizen."
      }
      input#SetAmmoResupplierOn: =
      {
        txt = "&"
        hint = "Set the ammo-resupplier flag on. Will not change the model or "
         "skin of the citizen."
      }
      input#SetAmmoResupplierOff: =
      {
        txt = "&"
        hint = "Set the ammo-resupplier flag off. Will not change the model or"
         " skin of the citizen."
      }
      input#SetReadinessLow: =
      {
        txt = "&"
        hint = "Set readiness to calmest state (Bored)"
      }
      input#SetReadinessMedium: =
      {
        txt = "&"
        hint = "Set readiness to moderate (Alert)"
      }
      input#SetReadinessHigh: =
      {
        txt = "&"
        hint = "Set readiness to highest. (Combat imminent)"
      }
      input#LockReadiness: =
      {
        txt = "&"
        hint = "Lock readiness at current setting for x seconds -1 = forever, "
         "0 = unlock now"
      }
      output#OnJoinedPlayerSquad: =
      {
        txt = "&"
        hint = "Fires when joins player squad"
      }
      output#OnLeftPlayerSquad: =
      {
        txt = "&"
        hint = "Fires when leaves player squad"
      }
      output#OnFollowOrder: =
      {
        txt = "&"
        hint = "Fires when ordered to follow player"
      }
      output#OnStationOrder: =
      {
        txt = "&"
        hint = "Fires when ordered to a location by player"
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fires when a player +USEs the citizen"
      }
      output#OnNavFailBlocked: =
      {
        txt = "&"
        hint = "Fires when this Citizen's movement fails because he/she is blo"
         "cked."
      }
    }
    npc_fisherman:form =
    {
      t_BaseNPC = !
      ExpressionOverride: =
      {
        txt = "&"
        hint = "Facial expression override"
      }
      input#SetExpressionOverride: =
      {
        txt = "&"
        hint = "Set facial expression override"
      }
    }
    npc_barney:form =
    {
      t_BaseNPC = !
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "Pistol"$0D"SMG1"$0D"Stun Stick"$0D"Shotgun"$0D"AR2"$0D"Nothin"
         "g"
        values = "weapon_pistol"$0D"weapon_smg1"$0D"weapon_stunstick"$0D"weapo"
         "n_shotgun"$0D"weapon_ar2"$0D"0"
      }
      input#SetReadinessLow: =
      {
        txt = "&"
        hint = "Set readiness to calmest state (Bored)"
      }
      input#SetReadinessMedium: =
      {
        txt = "&"
        hint = "Set readiness to moderate (Alert)"
      }
      input#SetReadinessHigh: =
      {
        txt = "&"
        hint = "Set readiness to highest. (Combat imminent)"
      }
      input#LockReadiness: =
      {
        txt = "&"
        hint = "Lock readiness at current setting for x seconds -1 = forever, "
         "0 = unlock now"
      }
      ExpressionOverride: =
      {
        txt = "&"
        hint = "Facial expression override"
      }
      input#SetExpressionOverride: =
      {
        txt = "&"
        hint = "Set facial expression override"
      }
    }
    t_BaseCombine:incl =
    {
      t_BaseNPC = !
      t_RappelNPC = !
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "AR2"$0D"Shotgun"$0D"SMG1"$0D"Stun Stick"$0D"Nothing"
        values = "weapon_ar2"$0D"weapon_shotgun"$0D"weapon_smg1"$0D"weapon_stu"
         "nstick"$0D"0"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Start LookOff"
      }
      NumGrenades: =
      {
        txt = "&"
        hint = "Number of Grenades"
        typ = "C"
        items = "None"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"Unlimited"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"999999"
      }
      input#LookOn: =
      {
        txt = "&"
        hint = "Look normally"
      }
      input#LookOff: =
      {
        txt = "&"
        hint = "Don't look for myself, use other squad member's eyes"
      }
      input#StartPatrolling: =
      {
        txt = "&"
        hint = "Patrol whenever I'm idle or alert."
      }
      input#StopPatrolling: =
      {
        txt = "&"
        hint = "Stop patrolling when I'm idle or alert."
      }
      input#ThrowGrenadeAtTarget: =
      {
        txt = "&"
        hint = "Throw a grenade at the specified target."
      }
    }
    npc_combine_s:form =
    {
      t_BaseCombine = !
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "C"
        items = "Regular Soldier"$0D"Nova Prospekt Soldier"$0D"Elite Soldier"
        values = "models/combine_soldier.mdl"$0D"models/combine_soldier_prison"
         "guard.mdl"$0D"models/combine_super_soldier.mdl"
      }
    }
    npc_launcher:form =
    {
      t_Parentname = !
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Check LOS"
      }
      StartOn: =
      {
        txt = "&"
        hint = "Start On"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      MissileModel: =
      {
        txt = "&"
        hint = "Missile Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      LaunchSound: =
      {
        txt = "&"
        hint = "Launch Sound"
      }
      FlySound: =
      {
        txt = "&"
        hint = "Fly Sound"
      }
      SmokeTrail: =
      {
        txt = "&"
        hint = "Smoke Trail"
        typ = "C"
        items = "Off"$0D"On"$0D"On Homing"
        values = "0"$0D"1"$0D"2"
      }
      LaunchSmoke: =
      {
        txt = "&"
        hint = "Launch Smoke"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      LaunchDelay: =
      {
        txt = "&"
        hint = "Launch Delay"
      }
      LaunchSpeed: =
      {
        txt = "&"
        hint = "Launch Speed"
      }
      PathCornerName: =
      {
        txt = "&"
        hint = "Path Corner Name"
      }
      HomingSpeed: =
      {
        txt = "&"
        hint = "Homing Speed"
      }
      HomingStrength: =
      {
        txt = "&"
        hint = "Homing Strength"
      }
      HomingDelay: =
      {
        txt = "&"
        hint = "Homing Delay"
      }
      HomingRampUp: =
      {
        txt = "&"
        hint = "Homing Ramp Up"
      }
      HomingDuration: =
      {
        txt = "&"
        hint = "Homing Duration"
      }
      HomingRampDown: =
      {
        txt = "&"
        hint = "Homing Ramp Down"
      }
      Gravity: =
      {
        txt = "&"
        hint = "Gravity"
      }
      MinRange: =
      {
        txt = "&"
        hint = "Min Range"
      }
      MaxRange: =
      {
        txt = "&"
        hint = "Max Range"
      }
      SpinMagnitude: =
      {
        txt = "&"
        hint = "Spin Magnitude"
      }
      SpinSpeed: =
      {
        txt = "&"
        hint = "Spin Speed"
      }
      Damage: =
      {
        txt = "&"
        hint = "Damage"
      }
      DamageRadius: =
      {
        txt = "&"
        hint = "DamageRadius"
      }
      output#OnLaunch: =
      {
        txt = "&"
        hint = "Fires when missile is launched"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on Launcher"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off Launcher"
      }
      input#LOSCheckOn: =
      {
        txt = "&"
        hint = "Start checking line of sight before firing"
      }
      input#LOSCheckOff: =
      {
        txt = "&"
        hint = "Stop checking line of sight before firing"
      }
      input#SetEnemyEntity: =
      {
        txt = "&"
        hint = "Set entity I should attack. Ignores visibility. (output from o"
         "ther entity only)"
      }
      input#ClearEnemyEntity: =
      {
        txt = "&"
        hint = "Clear set enemy enemy"
      }
      input#FireOnce: =
      {
        txt = "&"
        hint = "Fire Once (if have enemy)"
      }
    }
    env_gunfire:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Targetname = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Target"
      }
      minburstsize: =
      {
        txt = "&"
        hint = "Min Burst Size"
      }
      maxburstsize: =
      {
        txt = "&"
        hint = "Max Burst Size"
      }
      minburstdelay: =
      {
        txt = "&"
        hint = "Min Delay Between Bursts"
      }
      maxburstdelay: =
      {
        txt = "&"
        hint = "Max Delay Between Bursts"
      }
      rateoffire: =
      {
        txt = "&"
        hint = "Rate of fire"
      }
      spread: =
      {
        txt = "&"
        hint = "Bullet spread"
        typ = "C"
        items = "1 Degree"$0D"5 Degrees"$0D"10 Degrees"$0D"15 Degrees"
        values = "1"$0D"5"$0D"10"$0D"15"
      }
      bias: =
      {
        txt = "&"
        hint = "Bullet distribution should be..."
        typ = "C"
        items = "Evenly distributed"$0D"Biased towards the outside"
        values = "1"$0D"-1"
      }
      collisions: =
      {
        txt = "&"
        hint = "Collision detection"
        typ = "C"
        items = "None. Cheap for performance."$0D"Normal collision detection."
        values = "0"$0D"1"
      }
      shootsound: =
      {
        txt = "&"
        hint = "Shoot Sound"
        typ = "C"
        items = "AR2"$0D"SMG1"
        values = "Weapon_AR2.NPC_Single"$0D"Weapon_SMG1.NPC_Single"
      }
      tracertype: =
      {
        txt = "&"
        hint = "Tracer"
        typ = "C"
        items = "Default"$0D"AR2"
        values = $0D"AR2TRACER"
      }
    }
    env_headcrabcanister:form =
    {
      t_Parentname = !
      t_Angles = !
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Impact Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No Launch Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Start Impacted"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Land at initial position"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Wait for input to open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Wait for input to spawn headcrabs"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "No smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "No shake"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Remove on impact"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "No impact effects"
      }
      HeadcrabType: =
      {
        txt = "&"
        hint = "Which headcrab to spawn?"
        typ = "C"
        items = "Normal headcrabs"$0D"Fast Headcrabs"$0D"Poison Headcrabs"
        values = "0"$0D"1"$0D"2"
      }
      HeadcrabCount: =
      {
        txt = "&"
        hint = "Headcrab count"
      }
      FlightSpeed: =
      {
        txt = "&"
        hint = "Flight Speed"
      }
      FlightTime: =
      {
        txt = "&"
        hint = "Flight Time"
      }
      StartingHeight: =
      {
        txt = "&"
        hint = "Starting Height"
      }
      MinSkyboxRefireTime: =
      {
        txt = "&"
        hint = "Min Refire Time"
      }
      MaxSkyboxRefireTime: =
      {
        txt = "&"
        hint = "Max Refire Time"
      }
      SkyboxCannisterCount: =
      {
        txt = "&"
        hint = "Cannister count"
      }
      Damage: =
      {
        txt = "&"
        hint = "Impact damage"
      }
      DamageRadius: =
      {
        txt = "&"
        hint = "Impact damage radius"
      }
      SmokeLifetime: =
      {
        txt = "&"
        hint = "Smoke Duration"
      }
      input#FireCanister: =
      {
        txt = "&"
        hint = "Fire the canister"
      }
      input#OpenCanister: =
      {
        txt = "&"
        hint = "Opens the canister (must be called after the OnImpacted output"
         " is fired)"
      }
      input#SpawnHeadcrabs: =
      {
        txt = "&"
        hint = "Spawns headcrabs (must be called after the OnImpacted output i"
         "s fired and after OpenCanister is triggered, if the Wait for Input t"
         "o open spawnflag is checked.)"
      }
      input#StopSmoke: =
      {
        txt = "&"
        hint = "Stops the smoke if it's on"
      }
      output#OnLaunched: =
      {
        txt = "&"
        hint = "Fired when the canister is launched"
      }
      output#OnImpacted: =
      {
        txt = "&"
        hint = "Fires when canister hits the ground"
      }
      output#OnOpened: =
      {
        txt = "&"
        hint = "Fires when canister has finished opening"
      }
    }
    npc_vortigaunt:form =
    {
      t_BaseNPC = !
      t_modelselect = !
      ArmorRechargeEnabled: =
      {
        txt = "&"
        hint = "Allow Armor Recharging"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableArmorRecharge: =
      {
        txt = "&"
        hint = "Allow armor recharging on players"
      }
      input#DisableArmorRecharge: =
      {
        txt = "&"
        hint = "Do not allow armor recharging on players"
      }
      input#ExtractBugbait: =
      {
        txt = "&"
        hint = "Causes the vortigaunt to extract bugbait from the named target"
         " passed in."
      }
      input#ChargeTarget: =
      {
        txt = "&"
        hint = "Force the vortigaunt to charge the named target."
      }
      output#OnFinishedExtractingBugbait: =
      {
        txt = "&"
        hint = "Fires when the vortigaunt's finished extracting bugbait from a"
         " target."
      }
      output#OnFinishedExtractingTauCannon: =
      {
        txt = "&"
        hint = "Fires when the vortigaunt's finished extracting the tau cannon"
         " from the jeep."
      }
      output#OnFinishedChargingTarget: =
      {
        txt = "&"
        hint = "Fires when the vortigaunt has finished charging a target."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fires when a player +USEs the vortigaunt."
      }
    }
    npc_particlestorm:form =
    {
      t_BaseNPC = !
    }
    npc_wscanner:form =
    {
      t_BaseNPC = !
    }
    npc_sscanner:form =
    {
      t_BaseNPC = !
    }
    npc_spotlight:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Start Track On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Start Light On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "No Dynamic Light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Never Move"
      }
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      YawRange: =
      {
        txt = "&"
        hint = "YawRange"
      }
      PitchMin: =
      {
        txt = "&"
        hint = "PitchMin"
      }
      PitchMax: =
      {
        txt = "&"
        hint = "PitchMax"
      }
      IdleSpeed: =
      {
        txt = "&"
        hint = "IdleSpeed"
      }
      AlertSpeed: =
      {
        txt = "&"
        hint = "AlertSpeed"
      }
      spotlightlength: =
      {
        txt = "&"
        hint = "SpotlightLength"
      }
      spotlightwidth: =
      {
        txt = "&"
        hint = "SpotlightWidth"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      input#LightOn: =
      {
        txt = "&"
        hint = "LightOn"
      }
      input#LightOff: =
      {
        txt = "&"
        hint = "LightOff"
      }
      input#TrackOn: =
      {
        txt = "&"
        hint = "TrackOn"
      }
      input#TrackOff: =
      {
        txt = "&"
        hint = "TrackOff"
      }
      output#OnAlert: =
      {
        txt = "&"
        hint = "Fires when the spotlight alerted by sound"
      }
      output#DetectedEnemy: =
      {
        txt = "&"
        hint = "Outputs enemy entity when spotlight finds and starts tracking "
         "enemy"
      }
      output#LostEnemy: =
      {
        txt = "&"
        hint = "Outputs enemy entity when spotlight loses enemy that it's trac"
         "king, if enemy still exists"
      }
      output#SquadDetectedEnemy: =
      {
        txt = "&"
        hint = "Outputs enemy entity when squad finds and starts tracking enem"
         "y"
      }
      output#SquadLostEnemy: =
      {
        txt = "&"
        hint = "Outputs enemy entity when squad loses enemy that it's tracking"
         ", if entity still exists"
      }
      output#LightPosition: =
      {
        txt = "&"
        hint = "Position of the end of the spotlight beam"
      }
    }
    npc_strider:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Can Stomp Player"
      }
      input#SetMinigunTime: =
      {
        txt = "&"
        hint = "Time to shoot at any set minigun target"
      }
      input#SetMinigunTarget: =
      {
        txt = "&"
        hint = "Strider will shoot minigun at this"
      }
      input#SetCannonTarget: =
      {
        txt = "&"
        hint = "Strider will shoot cannon at this"
      }
      input#FlickRagdoll: =
      {
        txt = "&"
        hint = "Strider will flick anyone he's skewered"
      }
      input#StartPatrol: =
      {
        txt = "&"
        hint = "Start patrolling back and forth along the current track."
      }
      input#StopPatrol: =
      {
        txt = "&"
        hint = "Stop patrolling back and forth along the track. This will caus"
         "e the helicopter to come to rest at the track which he's currently f"
         "lying toward."
      }
      input#ChooseFarthestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path furthest "
         "from the enemy, but still in firing range"
      }
      input#ChooseNearestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path nearest f"
         "rom the enemy"
      }
      input#Crouch: =
      {
        txt = "&"
        hint = "Crouch down"
      }
      input#Stand: =
      {
        txt = "&"
        hint = "Stand up from crouch"
      }
      input#DisableCrouchWalk: =
      {
        txt = "&"
      }
      input#DisableCrouchWalk: =
      {
        txt = "&"
      }
      EnableCrouchWalk: =
      {
        txt = "&"
      }
      EnableCrouchWalk: =
      {
        txt = "&"
      }
      SetTargetPath: =
      {
        txt = "&"
        hint = "Set a path for the strider to patrol. The strider will first m"
         "ove to the closest point on the path"
      }
      input#ClearTargetPath: =
      {
        txt = "&"
        hint = "Clear the strider patrol path"
      }
      disablephysics: =
      {
        txt = "&"
        hint = "Disable physics (reduce CPU)"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    npc_barnacle:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Cheap death"
      }
      RestDist: =
      {
        txt = "&"
        hint = "Rest Distance"
      }
    }
    npc_combinegunship:form =
    {
      t_BaseHelicopter = !
      output#OnFireCannon: =
      {
        txt = "&"
        hint = "Fires when the gunship fires a cannon round"
      }
      input#OmniscientOn: =
      {
        txt = "&"
        hint = "Gunship knows target's location even when target is out of sig"
         "ht or behind cover"
      }
      input#OmniscientOff: =
      {
        txt = "&"
        hint = "Gunship relies on normal sight functions to locate target"
      }
      input#BlindfireOn: =
      {
        txt = "&"
        hint = "Gunship will fire at an unseen target, attempting to punch thr"
         "ough to them"
      }
      input#BlindfireOff: =
      {
        txt = "&"
        hint = "Gunship only fires at viusible target"
      }
      input#SetPenetrationDepth: =
      {
        txt = "&"
        hint = "Set penetration depth of bullets"
      }
      input#SetDockingBBox: =
      {
        txt = "&"
        hint = "Shrink Bounding Box"
      }
      input#SetNormalBBox: =
      {
        txt = "&"
        hint = "Set Bounding Box to normal size"
      }
      input#EnableGroundAttack: =
      {
        txt = "&"
        hint = "Allow the gunship to use its ground attack"
      }
      input#DisableGroundAttack: =
      {
        txt = "&"
        hint = "Don't allow the gunship to use its ground attack"
      }
      input#DoGroundAttack: =
      {
        txt = "&"
        hint = "Causes the gunship to execute its ground attack"
      }
      input#BecomeInvulnerable: =
      {
        txt = "&"
        hint = "Stops the gunship from taking damage, but still makes sounds e"
         "ffects"
      }
      input#BecomeVulnerable: =
      {
        txt = "&"
        hint = "Makes the gunship act normally to damage"
      }
      input#EnableRotorSound: =
      {
        txt = "&"
        hint = "Turns on rotor sounds"
      }
      input#DisableRotorSound: =
      {
        txt = "&"
        hint = "Turns off rotor sounds"
      }
      output#OnFirstDamage: =
      {
        txt = "&"
        hint = "Fired when the first damage is done to the gunship."
      }
      output#OnSecondDamage: =
      {
        txt = "&"
        hint = "Fired when the second damage is done to the gunship."
      }
      output#OnThirdDamage: =
      {
        txt = "&"
        hint = "Fired when the third damage is done to the gunship."
      }
      output#OnFourthDamage: =
      {
        txt = "&"
        hint = "Fired when the fourth damage is done to the gunship."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "No ground attack"
      }
    }
    info_target_gunshipcrash:form =
    {
      t_Targetname = !
      t_Parentname = !
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the crash target."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the crash target."
      }
    }
    npc_combinedropship:form =
    {
      t_BaseHelicopter = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Wait for input before dropoff"
      }
      LandTarget: =
      {
        txt = "&"
        hint = "Land target name"
      }
      GunRange: =
      {
        txt = "&"
        hint = "Crate Gun Range"
      }
      NPCTemplate: =
      {
        txt = "&"
        hint = "Name of Template NPC 1"
      }
      NPCTemplate2: =
      {
        txt = "&"
        hint = "Name of Template NPC 2"
      }
      NPCTemplate3: =
      {
        txt = "&"
        hint = "Name of Template NPC 3"
      }
      NPCTemplate4: =
      {
        txt = "&"
        hint = "Name of Template NPC 4"
      }
      NPCTemplate5: =
      {
        txt = "&"
        hint = "Name of Template NPC 5"
      }
      NPCTemplate6: =
      {
        txt = "&"
        hint = "Name of Template NPC 6"
      }
      Dustoff1: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 1"
      }
      Dustoff2: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 2"
      }
      Dustoff3: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 3"
      }
      Dustoff4: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 4"
      }
      Dustoff5: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 5"
      }
      Dustoff6: =
      {
        txt = "&"
        hint = "Name of dustoff point for NPC 6"
      }
      APCVehicleName: =
      {
        txt = "&"
        hint = "Name of the APC to drop"
      }
      Invulnerable: =
      {
        txt = "&"
        hint = "Invulnerable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      CrateType: =
      {
        txt = "&"
        hint = "Crate Type"
        typ = "C"
        items = "Jeep (No crate)"$0D"APC (No crate)"$0D"Strider (No crate)"$0D
         "Roller Hopper"$0D"Soldier Crate"$0D"None"
        values = "-3"$0D"-2"$0D"-1"$0D"0"$0D"1"$0D"2"
      }
      input#LandLeaveCrate: =
      {
        txt = "&"
        hint = "Land, drop soldiers, and leave the crate behind. Specify the n"
         "umber of troops to drop off in the parameter."
      }
      input#LandTakeCrate: =
      {
        txt = "&"
        hint = "Land, drop soldiers, but don't leave the crate behind. Specify"
         " the number of troops to drop off in the parameter."
      }
      input#DropMines: =
      {
        txt = "&"
        hint = "Drop Rollermines. Specify the number of mines to drop in the p"
         "arameter."
      }
      input#DropStrider: =
      {
        txt = "&"
        hint = "Drop the Strider you're carrying. Now."
      }
      input#DropAPC: =
      {
        txt = "&"
        hint = "Drop the APC you're carrying. Now."
      }
      input#Pickup: =
      {
        txt = "&"
        hint = "Pickup an entity."
      }
      input#SetLandTarget: =
      {
        txt = "&"
        hint = "Set my land target name."
      }
      input#SetGunRange: =
      {
        txt = "&"
        hint = "Set my crate gun's range."
      }
      input#EnableRotorSound: =
      {
        txt = "&"
        hint = "Turns on rotor sounds"
      }
      input#DisableRotorSound: =
      {
        txt = "&"
        hint = "Turns off rotor sounds"
      }
      input#StopWaitingForDropoff: =
      {
        txt = "&"
        hint = "Stop waiting for the dropoff. Dropoff as soon as possible."
      }
      output#OnFinishedDropoff: =
      {
        txt = "&"
        hint = "Fires when the dropship has finished a dropoff."
      }
      output#OnFinishedPickup: =
      {
        txt = "&"
        hint = "Fires when the dropship has finished a pickup."
      }
      output#OnCrateShotDownBeforeDropoff: =
      {
        txt = "&"
        hint = "Fires when the container was shot down before it dropped off s"
         "oldiers. The parameter contains the number of soldiers that weren't "
         "successfully dropped off."
      }
      output#OnCrateShotDownAfterDropoff: =
      {
        txt = "&"
        hint = "Fires when the container was shot down after it dropped off so"
         "ldiers."
      }
    }
    npc_helicopter:form =
    {
      t_BaseHelicopter = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Loud rotor wash sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Electrical drone"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Helicopter lights"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Ignore avoid spheres+boxes"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1048576"
        cap = "More aggressive attacks"
      }
      InitialSpeed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      GracePeriod: =
      {
        txt = "&"
        hint = "Grace Period"
      }
      PatrolSpeed: =
      {
        txt = "&"
        hint = "Patrol Speed"
      }
      input#GunOn: =
      {
        txt = "&"
        hint = "GunOn"
      }
      input#GunOff: =
      {
        txt = "&"
        hint = "GunOff"
      }
      input#MissileOn: =
      {
        txt = "&"
        hint = "MissileOn"
      }
      input#MissileOff: =
      {
        txt = "&"
        hint = "MissileOff"
      }
      input#EnableRotorWash: =
      {
        txt = "&"
        hint = "Turns on rotor wash effects"
      }
      input#DisableRotorWash: =
      {
        txt = "&"
        hint = "Turns off rotor wash effects"
      }
      input#EnableRotorSound: =
      {
        txt = "&"
        hint = "Turns on rotor sounds"
      }
      input#DisableRotorSound: =
      {
        txt = "&"
        hint = "Turns off rotor sounds"
      }
      input#StartBombingVehicle: =
      {
        txt = "&"
        hint = "Starts the chopper leading enemy vehicles and dropping bombs o"
         "n them."
      }
      input#StartTrailingVehicle: =
      {
        txt = "&"
        hint = "Starts the chopper trailing enemy vehicles and shooting at the"
         "m."
      }
      input#StartDefaultBehavior: =
      {
        txt = "&"
        hint = "Starts the chopper in the mode where he always stops at nav po"
         "ints instead of stopping anywhere in between nav points."
      }
      input#StartAlwaysLeadingVehicle: =
      {
        txt = "&"
        hint = "Starts the chopper *always* leading enemy vehicles (regardless"
         " of how they are moving w/respect to the path) and dropping bombs on"
         " them. This mode is different from StartBombingVehicle in that it ne"
         "ver uses the machine gun."
      }
      input#StartSprinkleBehavior: =
      {
        txt = "&"
        hint = "Starts the chopper dropping bombs randomly + shooting at the p"
         "layer."
      }
      input#StartBullrushBehavior: =
      {
        txt = "&"
        hint = "Starts the chopper bullrushing the player."
      }
      input#SetHealthFraction: =
      {
        txt = "&"
        hint = "Sets the chopper health as a percentage of max health"
      }
      input#EnableDeadlyShooting: =
      {
        txt = "&"
        hint = "Starts the chopper being deadly to on-foot players"
      }
      input#DisableDeadlyShooting: =
      {
        txt = "&"
        hint = "Stops the chopper being deadly to on-foot players"
      }
      input#StartNormalShooting: =
      {
        txt = "&"
        hint = "The chopper will fire in short bursts. Good for on-foot experi"
         "ences"
      }
      input#StartLongCycleShooting: =
      {
        txt = "&"
        hint = "The chopper fires in long bursts"
      }
      input#StartContinuousShooting: =
      {
        txt = "&"
        hint = "The chopper fires continuously."
      }
      input#ResetIdleTime: =
      {
        txt = "&"
        hint = "Allows the helicopter to fire immediately if he's not in the m"
         "iddle of charging or firing"
      }
      input#SetAngles: =
      {
        txt = "&"
        hint = "Instantly snaps the orientation of the helicopter (Pitch Yaw R"
         "oll)"
      }
      input#DropBomb: =
      {
        txt = "&"
        hint = "Immediately drops a bomb based on normal bomb dropping rules"
      }
      input#DropBombStraightDown: =
      {
        txt = "&"
        hint = "Immediately drops a bomb directly downwards"
      }
      input#DropBombAtTarget: =
      {
        txt = "&"
        hint = "Immediately drops a bomb directly at the target destination, b"
         "ut only if the player isn't right there"
      }
      input#DropBombAtTargetAlways: =
      {
        txt = "&"
        hint = "Immediately drops a bomb directly at the target destination, n"
         "o matter whether it's fair or not."
      }
      input#DropBombDelay: =
      {
        txt = "&"
        hint = "Add a delay before the next bomb is dropped"
      }
      input#BecomeIndestructible: =
      {
        txt = "&"
        hint = "Makes the helicopter take no more damage"
      }
      input#DisablePathVisibilityTests: =
      {
        txt = "&"
        hint = "When the helicopter moves, he will not check for visibility fr"
         "om the path_track to the enemy to cull out path_tracks"
      }
      input#EnablePathVisibilityTests: =
      {
        txt = "&"
        hint = "When the helicopter moves, he will only move to path_tracks th"
         "at have line-of-sight to the enemy"
      }
      output#OnHealthChanged: =
      {
        txt = "&"
        hint = "Fires when the helicopter health changes. The integer is the p"
         "ercentage of health the chopper has from 0-100."
      }
    }
    npc_heli_avoidsphere:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Avoid the sphere above and below"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
    }
    npc_heli_avoidbox:form =
    {
      t_Origin = !
      t_Angles = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Avoid the box above and below"
      }
    }
    npc_heli_nobomb:form =
    {
      t_Origin = !
      t_Angles = !
      t_Parentname = !
    }
    npc_fastzombie:form =
    {
      t_BaseNPC = !
    }
    npc_zombie:form =
    {
      t_BaseNPC = !
    }
    npc_zombie_torso:form =
    {
      t_BaseNPC = !
    }
    npc_poisonzombie:form =
    {
      t_BaseNPC = !
      crabcount: =
      {
        txt = "&"
        hint = "Crabs in nest"
        typ = "C"
        items = "1 Crab"$0D"2 Crabs"$0D"3 Crabs"
        values = "1"$0D"2"$0D"3"
      }
    }
    npc_cscanner:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "No Dynamic Light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Strider Scout Scanner"
      }
      spotlightlength: =
      {
        txt = "&"
        hint = "SpotlightLength"
      }
      spotlightwidth: =
      {
        txt = "&"
        hint = "SpotlightWidth"
      }
      spotlightdisabled: =
      {
        txt = "&"
        hint = "SpotlightDisabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      ShouldInspect: =
      {
        txt = "&"
        hint = "Should inspect"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      OnlyInspectPlayers: =
      {
        txt = "&"
        hint = "Only Inspect Players"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      NeverInspectPlayers: =
      {
        txt = "&"
        hint = "Never Inspect Players"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#DisableSpotlight: =
      {
        txt = "&"
        hint = "DisableSpotlight"
      }
      input#InspectTargetPhoto: =
      {
        txt = "&"
        hint = "Tells the scanner to photograph the given entity, named by cla"
         "ssname or by target name. !activator or !player works here also."
      }
      input#InspectTargetSpotlight: =
      {
        txt = "&"
        hint = "Tells the scanner to spotlight the given entity, named by clas"
         "sname or by target name. !activator or !player works here also."
      }
      input#InputSetFlightSpeed: =
      {
        txt = "&"
        hint = "Sets the flight speed of the scanner"
      }
      input#InputShouldInspect: =
      {
        txt = "&"
        hint = "Set whether should inspect or not"
      }
      input#SetFollowTarget: =
      {
        txt = "&"
        hint = "Set target to follow until told otherwise"
      }
      input#ClearFollowTarget: =
      {
        txt = "&"
        hint = "Stop following our target"
      }
      input#SetDistanceOverride: =
      {
        txt = "&"
        hint = "Override the distance the scanner will attempt to keep between"
         " inspection targets and itself"
      }
      input#DeployMine: =
      {
        txt = "&"
        hint = "Drop landmine (if carrying one)"
      }
      input#EquipMine: =
      {
        txt = "&"
        hint = "Equip with landmine"
      }
      output#OnPhotographPlayer: =
      {
        txt = "&"
        hint = "Fired any time the scanner takes a picture of the player."
      }
      output#OnPhotographNPC: =
      {
        txt = "&"
        hint = "Fired any time the scanner takes a picture of an NPC."
      }
    }
    npc_manhack:form =
    {
      t_BaseNPC = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Start packed up (folded and engine off)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Don't use any damage effects"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Use Air Nodes"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1048576"
        cap = "No Danger Sounds"
      }
      input#DisableSwarm: =
      {
        txt = "&"
        hint = "Disable the manhack swarm behavior."
      }
      input#Unpack: =
      {
        txt = "&"
        hint = "Causes the manhack to stop being packed up."
      }
    }
    npc_mortarsynth:form =
    {
      t_BaseNPC = !
    }
    npc_metropolice:form =
    {
      t_BaseNPC = !
      t_RappelNPC = !
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "Pistol"$0D"SMG1"$0D"Stun Stick"$0D"Shotgun"$0D"Nothing"
        values = "weapon_pistol"$0D"weapon_smg1"$0D"weapon_stunstick"$0D"weapo"
         "n_shotgun"$0D"0"
      }
      manhacks: =
      {
        txt = "&"
        hint = "Number of Manhacks"
        typ = "C"
        items = "None"$0D"1"$0D"2"
        values = "0"$0D"1"$0D"2"
      }
      weapondrawn: =
      {
        txt = "&"
        hint = "Pistol starts drawn"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Simple cops"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Rappel (UNCHECK THIS IF IT IS CHECKED!)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Always stitch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1048576"
        cap = "No chatter"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2097152"
        cap = "Arrest enemies"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4194304"
        cap = "No far stitching"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8388608"
        cap = "Prevent manhack toss"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16777216"
        cap = "Allowed to respond to thrown objects"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X33554432"
        cap = "Mid-range attacks (halfway between normal + long-range)"
      }
      input#EnableManhackToss: =
      {
        txt = "&"
        hint = "Enables manhack toss (which had been disabled by the spawnflag"
         ")"
      }
      input#SetPoliceGoal: =
      {
        txt = "&"
        hint = "Causes the NPC to police the area defined by an ai_goal_police"
      }
      input#ActivateBaton: =
      {
        txt = "&"
        hint = "Set the baton to active"
      }
      output#OnStunnedPlayer: =
      {
        txt = "&"
        hint = "Fires when the player is hit by a stunstick by this NPC."
      }
    }
    npc_crabsynth:form =
    {
      t_BaseNPC = !
    }
    npc_odell:form =
    {
      t_TalkNPC = !
    }
    npc_monk:form =
    {
      t_TalkNPC = !
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "Annabelle"$0D"SMG1"$0D"AR2"$0D"Stun Stick"$0D"Crow Bar"$0D"Sh"
         "otgun"$0D"Beer Bottle"$0D"Beer Bottle2"$0D"RPG"$0D"Nothing"
        values = "weapon_annabelle"$0D"weapon_smg1"$0D"weapon_ar2"$0D"weapon_s"
         "tunstick"$0D"weapon_crowbar"$0D"weapon_shotgun"$0D"weapon_beerbottle"
         $0D"weapon_beerbottle2"$0D"weapon_rpg"$0D"0"
      }
      HasGun: =
      {
        txt = "&"
        hint = "Has Gun"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#PerfectAccuracyOn: =
      {
        txt = "&"
        hint = "Make every shot at a zombie a headshot"
      }
      input#PerfectAccuracyOff: =
      {
        txt = "&"
        hint = "Return to normal accuracy"
      }
    }
    npc_alyx:form =
    {
      t_TalkNPC = !
      t_Parentname = !
      t_modelselect = !
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "Alyx Gun"$0D"Nothing"
        values = "weapon_alyxgun"$0D"0"
      }
    }
    npc_kleiner:form =
    {
      t_TalkNPC = !
    }
    npc_eli:form =
    {
      t_TalkNPC = !
      t_Parentname = !
      t_modelselect = !
    }
    npc_breen:form =
    {
      t_TalkNPC = !
      t_modelselect = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Ignore speech semaphore"
      }
    }
    npc_mossman:form =
    {
      t_TalkNPC = !
    }
    npc_gman:form =
    {
      t_TalkNPC = !
    }
    npc_dog:form =
    {
      t_BaseNPC = !
      input#SetPickupTarget: =
      {
        txt = "&"
        hint = "Sets the target entity for dog to pickup."
      }
      input#StartCatchThrowBehavior: =
      {
        txt = "&"
        hint = "Tells d0g to start playing with the player. You can pass in th"
         "e name of the object you want him to play with otherwise he'll find "
         "the closes phys_object."
      }
      input#StopCatchThrowBehavior: =
      {
        txt = "&"
        hint = "Stop the catch and throw behavior."
      }
      input#PlayerPickupObject: =
      {
        txt = "&"
        hint = "Tells d0g the physgun just picked up an object."
      }
      input#StartWaitAndCatch: =
      {
        txt = "&"
        hint = "Tells d0g to wait for the player to throw an object at him."
      }
      input#StopWaitAndCatch: =
      {
        txt = "&"
        hint = "Tells d0g to stop waiting for the player."
      }
      input#SetThrowArcModifier: =
      {
        txt = "&"
        hint = "Used to pass in a modifier for d0g's object flight arc."
      }
      input#SetThrowTarget: =
      {
        txt = "&"
        hint = "Set d0g's throw target (pass in !player if you want the player"
         ")"
      }
      output#OnDogThrow: =
      {
        txt = "&"
        hint = "Fires when dog throws an object."
      }
      output#OnDogPickup: =
      {
        txt = "&"
        hint = "Fires when dog picks up an object."
      }
      output#OnDogCatch: =
      {
        txt = "&"
        hint = "Fires when dog catches an object."
      }
    }
    monster_generic:form =
    {
      t_BaseNPC = !
      t_RenderFields = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Not solid"
      }
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      body: =
      {
        txt = "&"
        hint = "Body"
      }
    }
    generic_actor:form =
    {
      t_BaseNPC = !
      t_Parentname = !
      t_RenderFields = !
      t_Shadow = !
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      hull_name: =
      {
        txt = "&"
        hint = "Hull type"
        typ = "C"
        items = "Human"$0D"Wide"$0D"Tiny"$0D"Medium"$0D"Large"
        values = "HUMAN_HULL"$0D"WIDE_HUMAN_HULL"$0D"TINY_HULL"$0D"MEDIUM_HULL"
         $0D"LARGE_HULL"
      }
    }
    cycler_actor:form =
    {
      t_BaseNPC = !
      t_RenderFields = !
      t_Shadow = !
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      Sentence: =
      {
        txt = "&"
        hint = "Sentence Group"
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Set Alpha Value"
      }
    }
    npc_maker:form =
    {
      t_Angles = !
      t_BaseNPCMaker = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Fade Corpse"
      }
      NPCType: =
      {
        txt = "&"
        hint = "Class name of spawned NPC"
      }
      NPCTargetname: =
      {
        txt = "&"
        hint = "Childrens' Name"
      }
      NPCSquadname: =
      {
        txt = "&"
        hint = "Childrens' Squad Name"
      }
      NPCHintGroup: =
      {
        txt = "&"
        hint = "Childrens' Hint Group"
      }
      additionalequipment: =
      {
        txt = "&"
        hint = "Weapons"
        typ = "C"
        items = "Pistol"$0D"AR2"$0D"Shotgun"$0D"SMG1"$0D"Stun Stick"$0D"Grigor"
         "i's Shotgun"$0D"Nothing"
        values = "weapon_pistol"$0D"weapon_ar2"$0D"weapon_shotgun"$0D"weapon_s"
         "mg1"$0D"weapon_stunstick"$0D"weapon_annabelle"$0D"0"
      }
    }
    npc_antlion_template_maker:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Angles = !
      t_BaseNPCMaker = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Random spawn node"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Try to spawn close to the current target"
      }
      TemplateName: =
      {
        txt = "&"
        hint = "Name of template NPC"
      }
      spawngroup: =
      {
        txt = "&"
        hint = "Spawn on Hint Group"
      }
      spawnradius: =
      {
        txt = "&"
        hint = "Spawn radius"
      }
      spawntarget: =
      {
        txt = "&"
        hint = "Spawn target"
      }
      fighttarget: =
      {
        txt = "&"
        hint = "Fight target"
      }
      followtarget: =
      {
        txt = "&"
        hint = "Follow target"
      }
      vehicledistance: =
      {
        txt = "&"
        hint = "Vehicle Spawn Distance"
      }
      ignorebugbait: =
      {
        txt = "&"
        hint = "Ignore Bugbait"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      pool_start: =
      {
        txt = "&"
        hint = "Initial antlions in the pool."
      }
      pool_max: =
      {
        txt = "&"
        hint = "Max antlions in the pool."
      }
      pool_regen_amount: =
      {
        txt = "&"
        hint = "Pool regen amount."
      }
      pool_regen_time: =
      {
        txt = "&"
        hint = "Pool regen time."
      }
      input#SetFightTarget: =
      {
        txt = "&"
        hint = "Sets the target entity for children to fight to."
      }
      input#ClearFightTarget: =
      {
        txt = "&"
        hint = "Clears the fight target goal for this spawner."
      }
      input#SetFollowTarget: =
      {
        txt = "&"
        hint = "Sets the target entity for children to follow."
      }
      input#ClearFollowTarget: =
      {
        txt = "&"
        hint = "Clears the follow target goal for this spawner."
      }
      input#SetSpawnRadius: =
      {
        txt = "&"
        hint = "Sets the Spawn Radius."
      }
      input#AddToPool: =
      {
        txt = "&"
        hint = "Add the number of antlions specified in the parameter to the p"
         "ool."
      }
      input#SetMaxPool: =
      {
        txt = "&"
        hint = "Set the maximum number of antlions allowed in the pool at any "
         "time. Setting it to 0 turns off the pool behavior."
      }
      input#SetPoolRegenAmount: =
      {
        txt = "&"
        hint = "Set the number of antlions added to the pool every time it reg"
         "enerates."
      }
      input#SetPoolRegenTime: =
      {
        txt = "&"
        hint = "Set the time interval between pool regeneration ticks."
      }
    }
    point_antlion_repellant:form =
    {
      t_Targetname = !
      repelradius: =
      {
        txt = "&"
        hint = "Repell radius"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable"
      }
    }
    t_player_control:incl =
    {
      bbox = '-10 -10 -10 10 10 10'
      t_Targetname = !
      input#Activate: =
      {
        txt = "&"
        hint = "Turns on"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Turns off"
      }
      input#SetThrust: =
      {
        txt = "&"
        hint = "Set Thrust"
      }
      input#SetSideThrust: =
      {
        txt = "&"
        hint = "Set Side Thrust"
      }
    }
    t_BaseScripted:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      m_iszEntity: =
      {
        txt = "&"
        hint = "Target NPC"
      }
      m_iszIdle: =
      {
        txt = "&"
        hint = "Pre Action Idle Animation"
      }
      m_iszPlay: =
      {
        txt = "&"
        hint = "Action Animation"
      }
      m_iszPostIdle: =
      {
        txt = "&"
        hint = "Post Action Idle Animation"
      }
      m_iszCustomMove: =
      {
        txt = "&"
        hint = "Custom Move Animation"
      }
      m_flRadius: =
      {
        txt = "&"
        hint = "Search Radius (0=everywhere)"
      }
      m_flRepeat: =
      {
        txt = "&"
        hint = "Repeat Rate ms"
      }
      m_fMoveTo: =
      {
        txt = "&"
        hint = "Move to Position"
        typ = "C"
        items = "No"$0D"Walk"$0D"Run"$0D"Custom movement"$0D"Instantaneous"$0D
         "No - Turn to Face"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"
      }
      m_iszNextScript: =
      {
        txt = "&"
        hint = "Next Script"
      }
      input#BeginSequence: =
      {
        txt = "&"
        hint = "Summons an NPC to act out the scripted sequence."
      }
      input#MoveToPosition: =
      {
        txt = "&"
        hint = "Summons an NPC to the script location. They will play their sc"
         "ripted idle (or ACT_IDLE if none is specified) until BeginSequence i"
         "s triggered."
      }
      input#CancelSequence: =
      {
        txt = "&"
        hint = "Stops the scripted sequence. If fired after a sequence starts,"
         " this input will not take effect until the NPC finishes playing the "
         "scripted action animation."
      }
      output#OnBeginSequence: =
      {
        txt = "&"
        hint = "Fires when the action animation begins playing."
      }
      output#OnEndSequence: =
      {
        txt = "&"
        hint = "Fires when the action animation completes."
      }
      output#OnScriptEvent01: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 1 } in the QC."
      }
      output#OnScriptEvent02: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 2 } in the QC."
      }
      output#OnScriptEvent03: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 3 } in the QC."
      }
      output#OnScriptEvent04: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 4 } in the QC."
      }
      output#OnScriptEvent05: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 5 } in the QC."
      }
      output#OnScriptEvent06: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 6 } in the QC."
      }
      output#OnScriptEvent07: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 7 } in the QC."
      }
      output#OnScriptEvent08: =
      {
        txt = "&"
        hint = "Fires when a 'trigger' anim event occurs while playing the scr"
         "ipt. Use { event 1003 framenum 8 } in the QC."
      }
    }
    scripted_sentence:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Fire Once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Followers Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Interrupt Speech"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Concurrent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Speak to Activator"
      }
      sentence: =
      {
        txt = "&"
        hint = "Sentence Name"
      }
      entity: =
      {
        txt = "&"
        hint = "Speaker Type"
      }
      delay: =
      {
        txt = "&"
        hint = "Additional Sentence Time"
      }
      radius: =
      {
        txt = "&"
        hint = "Search Radius"
      }
      refire: =
      {
        txt = "&"
        hint = "Delay Before Refire"
      }
      listener: =
      {
        txt = "&"
        hint = "Listener Type"
      }
      volume: =
      {
        txt = "&"
        hint = "Volume 0-10"
      }
      attenuation: =
      {
        txt = "&"
        hint = "Sound Radius"
        typ = "C"
        items = "Small Radius"$0D"Medium Radius"$0D"Large  Radius"$0D"Play Eve"
         "rywhere"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      input#BeginSentence: =
      {
        txt = "&"
        hint = "Starts the scripted sentence."
      }
      output#OnBeginSentence: =
      {
        txt = "&"
        hint = "Fires when the sentence begins"
      }
      output#OnEndSentence: =
      {
        txt = "&"
        hint = "Fires when the sentence ends"
      }
    }
    scripted_target:form =
    {
      t_Targetname = !
      t_Parentname = !
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      m_iszEntity: =
      {
        txt = "&"
        hint = "Target NPC"
      }
      m_flRadius: =
      {
        txt = "&"
        hint = "Search Radius (0=everywhere)"
      }
      MoveSpeed: =
      {
        txt = "&"
        hint = "Move Speed"
      }
      PauseDuration: =
      {
        txt = "&"
        hint = "Pause Duration"
      }
      EffectDuration: =
      {
        txt = "&"
        hint = "Effect Duration"
      }
      target: =
      {
        txt = "&"
        hint = "Next Target"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this entity"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this entity"
      }
      output#AtTarget: =
      {
        txt = "&"
        hint = "Fires when NPC reaches this target"
      }
      output#LeaveTarget: =
      {
        txt = "&"
        hint = "Fires when NPC leaves this target"
      }
    }
    ai_relationship:form =
    {
      t_Targetname = !
      subject: =
      {
        txt = "&"
        hint = "Subject(s)"
      }
      target: =
      {
        txt = "&"
        hint = "Target(s)"
      }
      disposition: =
      {
        txt = "&"
        hint = "Disposition"
        typ = "C"
        items = "Hate"$0D"Fear"$0D"Like"$0D"Neutral"
        values = "1"$0D"2"$0D"3"$0D"4"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius for subject"
      }
      rank: =
      {
        txt = "&"
        hint = "Disposition Priority"
      }
      StartActive: =
      {
        txt = "&"
        hint = "Start Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Reciprocal: =
      {
        txt = "&"
        hint = "Reciprocal"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#ApplyRelationship: =
      {
        txt = "&"
        hint = "Apply relationship changes"
      }
      input#RevertRelationship: =
      {
        txt = "&"
        hint = "Revert relationship changes"
      }
    }
    ai_ally_manager:form =
    {
      t_Targetname = !
      maxallies: =
      {
        txt = "&"
        hint = "Maximum number of allies"
      }
      maxmedics: =
      {
        txt = "&"
        hint = "Maximum number of medics"
      }
      input#SetMaxAllies: =
      {
        txt = "&"
        hint = "Set maximum number of allies"
      }
      input#SetMaxMedics: =
      {
        txt = "&"
        hint = "Set maximum number of medic allies"
      }
      input#Replenish: =
      {
        txt = "&"
        hint = "Replenish player allies"
      }
      output#SpawnMedicAlly: =
      {
        txt = "&"
        hint = "Spawn Medic Ally"
      }
      output#SpawnAlly0: =
      {
        txt = "&"
        hint = "Spawn Ally 0"
      }
      output#SpawnAlly1: =
      {
        txt = "&"
        hint = "Spawn Ally 1"
      }
      output#SpawnAlly2: =
      {
        txt = "&"
        hint = "Spawn Ally 2"
      }
      output#SpawnAlly3: =
      {
        txt = "&"
        hint = "Spawn Ally 3"
      }
      output#SpawnAlly4: =
      {
        txt = "&"
        hint = "Spawn Ally 4"
      }
      output#SpawnAlly5: =
      {
        txt = "&"
        hint = "Spawn Ally 5"
      }
      output#SpawnAlly6: =
      {
        txt = "&"
        hint = "Spawn Ally 6"
      }
      output#SpawnAlly7: =
      {
        txt = "&"
        hint = "Spawn Ally 7"
      }
      output#SpawnAlly8: =
      {
        txt = "&"
        hint = "Spawn Ally 8"
      }
      output#SpawnAlly9: =
      {
        txt = "&"
        hint = "Spawn Ally 9"
      }
      output#OnZeroAllies: =
      {
        txt = "&"
        hint = "Fires when there are no more allies"
      }
      output#OnZeroMedicAllies: =
      {
        txt = "&"
        hint = "Fires when there are no more allies"
      }
    }
    t_LeadGoalBase:incl =
    {
      t_Targetname = !
      actor: =
      {
        txt = "&"
        hint = "Actor(s) to affect"
      }
      goal: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      WaitPointName: =
      {
        txt = "&"
        hint = "Point to wait at if the target's not visible."
      }
      WaitDistance: =
      {
        txt = "&"
        hint = "Wait until player gets this close."
      }
      LeadDistance: =
      {
        txt = "&"
        hint = "Lead Distance."
      }
      Run: =
      {
        txt = "&"
        hint = "Run instead of Walk"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Retrieve: =
      {
        txt = "&"
        hint = "Retrieve player?"
        typ = "C"
        items = "No, just idle and wait"$0D"Yes, move to retrieve"
        values = "0"$0D"1"
      }
      AttractPlayerConceptModifier: =
      {
        txt = "&"
        hint = "Attract player concept modifier"
      }
      WaitOverConceptModifier: =
      {
        txt = "&"
        hint = "Player wait over concept modifier"
      }
      ArrivalConceptModifier: =
      {
        txt = "&"
        hint = "Arrival concept modifier"
      }
      PostArrivalConceptModifier: =
      {
        txt = "&"
        hint = "Post-arrival concepts modifier"
      }
      SuccessConceptModifier: =
      {
        txt = "&"
        hint = "Success concept modifier"
      }
      FailureConceptModifier: =
      {
        txt = "&"
        hint = "Failure concept modifier"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No def success"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No def failure"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Use goal facing"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Begin the leading behavior"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Stop the leading behavior"
      }
      input#SetSuccess: =
      {
        txt = "&"
        hint = "Notify success of leading"
      }
      input#SetFailure: =
      {
        txt = "&"
        hint = "Notify failure of leading"
      }
      output#OnArrival: =
      {
        txt = "&"
        hint = "Fires when NPC reaches the lead point"
      }
      output#OnArrivalDone: =
      {
        txt = "&"
        hint = "Fires when NPC has played out any arrival speech"
      }
      output#OnSuccess: =
      {
        txt = "&"
        hint = "Fires when NPC achieves the goal"
      }
      output#OnFailure: =
      {
        txt = "&"
        hint = "Fires when NPC fails to achieves the goal"
      }
      output#OnDone: =
      {
        txt = "&"
        hint = "Fires when NPC completes behavior (any post-success or fail ac"
         "ting is complete)"
      }
    }
    ai_goal_lead:form =
    {
      t_LeadGoalBase = !
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
    }
    ai_goal_lead_weapon:form =
    {
      t_LeadGoalBase = !
      WeaponName: =
      {
        txt = "&"
        hint = "Weapon"
        typ = "C"
        items = "Bugbait"$0D"SMG1"$0D"AR2"
        values = "weapon_bugbait"$0D"weapon_smg1"$0D"weapon_ar2"
      }
      MissingWeaponConceptModifier: =
      {
        txt = "&"
        hint = "Missing weapon concept modifier"
      }
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
    }
    ai_goal_follow:form =
    {
      t_Targetname = !
      actor: =
      {
        txt = "&"
        hint = "Actor(s) to affect"
      }
      goal: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
      StartActive: =
      {
        txt = "&"
        hint = "Start Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      MaximumState: =
      {
        txt = "&"
        hint = "Maximum state"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      Formation: =
      {
        txt = "&"
        hint = "Formation"
        typ = "C"
        items = "Close circle"$0D"Wide circle"$0D"Medium circle"
        values = "0"$0D"1"$0D"5"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Begin the follow behavior"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Cease the follow behavior"
      }
    }
    ai_battle_line:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Angles = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Use parent's orientation"
      }
      actor: =
      {
        txt = "&"
        hint = "Actor(s) or squad to affect"
      }
      Active: =
      {
        txt = "&"
        hint = "Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Strict: =
      {
        txt = "&"
        hint = "Strict"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
      }
      input#Activate: =
      {
        txt = "&"
      }
      Deactivate: =
      {
        txt = "&"
      }
    }
    ai_goal_standoff:form =
    {
      t_Targetname = !
      actor: =
      {
        txt = "&"
        hint = "Actor(s) to affect"
      }
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
      StartActive: =
      {
        txt = "&"
        hint = "Start Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      HintGroupChangeReaction: =
      {
        txt = "&"
        hint = "Reaction to tactical change"
        typ = "C"
        items = "Move when ready (default AI)"$0D"Move when seek cover"$0D"Mov"
         "e immediately"
        values = "0"$0D"1"$0D"2"
      }
      Aggressiveness: =
      {
        txt = "&"
        hint = "Aggressiveness"
        typ = "C"
        items = "Very low"$0D"Low"$0D"Medium"$0D"High"$0D"Very High"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      PlayerBattleline: =
      {
        txt = "&"
        hint = "Player battleline"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      StayAtCover: =
      {
        txt = "&"
        hint = "Stay at cover location"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      AbandonIfEnemyHides: =
      {
        txt = "&"
        hint = "Abandon if enemies hide"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Begin contesting position"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Cease contesting position"
      }
      input#SetAggressiveness: =
      {
        txt = "&"
        hint = "Set aggressiveness"
      }
    }
    ai_goal_police:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Knock-out target past crossing plane"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Do not leave post"
      }
      policeradius: =
      {
        txt = "&"
        hint = "Radius"
      }
      policetarget: =
      {
        txt = "&"
        hint = "Target"
      }
      input#EnableKnockOut: =
      {
        txt = "&"
        hint = "Tells the goal to make the active policing NPC knock out its t"
         "arget"
      }
      input#DisableKnockOut: =
      {
        txt = "&"
        hint = "Stop the active policing NPC from trying to knock out its targ"
         "et"
      }
      output#OnFirstWarning: =
      {
        txt = "&"
        hint = "Fires the first time a policing cop warns a target"
      }
      output#OnSecondWarning: =
      {
        txt = "&"
        hint = "Fires the second time a policing cop warns a target"
      }
      output#OnLastWarning: =
      {
        txt = "&"
        hint = "Fires when a policing cop warns a target for the last time"
      }
      output#OnSupressingTarget: =
      {
        txt = "&"
        hint = "Fires when a policing cop starts to suppress (ie. beat) a targ"
         "et"
      }
      output#OnKnockOut: =
      {
        txt = "&"
        hint = "Fires when a target has been knocked out"
      }
    }
    assault_rallypoint:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      assaultpoint: =
      {
        txt = "&"
        hint = "Assault Point"
      }
      assaultdelay: =
      {
        txt = "&"
        hint = "Assault Delay"
      }
      rallysequence: =
      {
        txt = "&"
        hint = "Rally Sequence"
      }
      priority: =
      {
        txt = "&"
        hint = "Priority"
      }
      output#OnArrival: =
      {
        txt = "&"
        hint = "Fires when the NPC reaches this rally point"
      }
    }
    assault_assaultpoint:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      assaultgroup: =
      {
        txt = "&"
        hint = "Assault Hint Group"
      }
      nextassaultpoint: =
      {
        txt = "&"
        hint = "Next assault point (optional)"
      }
      assaulttimeout: =
      {
        txt = "&"
        hint = "Assault time out"
      }
      clearoncontact: =
      {
        txt = "&"
        hint = "Clear on contact with enemies"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      allowdiversion: =
      {
        txt = "&"
        hint = "Allow diversion"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      nevertimeout: =
      {
        txt = "&"
        hint = "Never Timeout"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Clear this point upon arrival, UNCONDITIONALLY"
      }
      input#SetClearOnContact: =
      {
        txt = "&"
        hint = "Set the clear on contact flag."
      }
      input#SetAllowDiversion: =
      {
        txt = "&"
        hint = "Set the allow diversion flag."
      }
      output#OnArrival: =
      {
        txt = "&"
        hint = "Fires when the NPC reaches this assault point"
      }
      output#OnAssaultClear: =
      {
        txt = "&"
        hint = "Fires when this assault point is cleared of enemies"
      }
    }
    ai_goal_assault:form =
    {
      t_Targetname = !
      actor: =
      {
        txt = "&"
        hint = "Actor(s) to affect"
      }
      rallypoint: =
      {
        txt = "&"
        hint = "Rally Point Set"
      }
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
      StartActive: =
      {
        txt = "&"
        hint = "Start Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      AssaultCue: =
      {
        txt = "&"
        hint = "Assault Cue"
        typ = "C"
        items = "Entity System Input"$0D"Gunfire"$0D"Don't wait for a cue."
        values = "1"$0D"2"$0D"3"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Begin the assault behavior"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Cease the assault behavior"
      }
      input#BeginAssault: =
      {
        txt = "&"
        hint = "Begin assault phase"
      }
    }
    t_BaseActBusy:incl =
    {
      t_Targetname = !
      actor: =
      {
        txt = "&"
        hint = "Actor(s) to affect"
      }
      StartActive: =
      {
        txt = "&"
        hint = "Start Active"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"
        values = "0"$0D"1"
      }
      busysearchrange: =
      {
        txt = "&"
        hint = "Search Range for Busy Hints"
      }
      visibleonly: =
      {
        txt = "&"
        hint = "Visible Busy Hints Only"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Begin acting busy"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Cease acting busy"
      }
      input#SetBusySearchRange: =
      {
        txt = "&"
        hint = "Update the busy search range for all actors."
      }
      input#ForceNPCToActBusy: =
      {
        txt = "&"
        hint = "Force an NPC to act busy. Takes parameters, separated by space"
         "s: <Targetname> <hint node targetname> <optional:teleport> <optional"
         ":$customactivityorsequence> <maximum time to actbusy>. If no hint no"
         "de targetname is specified, it'll search for a random one. If no max"
         " time is specified, it'll use the default. Specifying 0 as the max t"
         "ime will make the NPC act busy until disturbed. If the optional tele"
         "port parameter is specified, the NPC will teleport to the act busy p"
         "oint. A custom move animation can be specified by prepending $ to th"
         "e name of it. i.e. $ACT_RUN will make the NPC Run. Sequence names ca"
         "n be used instead of activities."
      }
      input#ForceThisNPCToActBusy: =
      {
        txt = "&"
        hint = "Force an NPC outputted from another entity to act busy. (only "
         "usable from an output that specifies an entity)"
      }
      input#ForceThisNPCToLeave: =
      {
        txt = "&"
        hint = "Force an NPC outputted from another entity to find a HINT_NPC_"
         "EXIT_POINT hintnode and vanish."
      }
      output#OnNPCStartedBusy: =
      {
        txt = "&"
        hint = "Fired when an NPC targeted by this goal starts an ActBusy anim"
         "ation."
      }
      output#OnNPCFinishedBusy: =
      {
        txt = "&"
        hint = "Fired when an NPC targeted by this goal finishes an ActBusy."
      }
      output#OnNPCLeft: =
      {
        txt = "&"
        hint = "Fired when an NPC target by this goal finishes a forced Leave."
      }
    }
    ai_goal_actbusy:form =
    {
      t_BaseActBusy = !
    }
    ai_goal_actbusy_queue:form =
    {
      t_BaseActBusy = !
      node_exit: =
      {
        txt = "&"
        hint = "Exit Node"
      }
      node01: =
      {
        txt = "&"
        hint = "Node 1"
      }
      node02: =
      {
        txt = "&"
        hint = "Node 2"
      }
      node03: =
      {
        txt = "&"
        hint = "Node 3"
      }
      node04: =
      {
        txt = "&"
        hint = "Node 4"
      }
      node05: =
      {
        txt = "&"
        hint = "Node 5"
      }
      node06: =
      {
        txt = "&"
        hint = "Node 6"
      }
      node07: =
      {
        txt = "&"
        hint = "Node 7"
      }
      node08: =
      {
        txt = "&"
        hint = "Node 8"
      }
      node09: =
      {
        txt = "&"
        hint = "Node 9"
      }
      node10: =
      {
        txt = "&"
        hint = "Node 10"
      }
      node11: =
      {
        txt = "&"
        hint = "Node 11"
      }
      node12: =
      {
        txt = "&"
        hint = "Node 12"
      }
      node13: =
      {
        txt = "&"
        hint = "Node 13"
      }
      node14: =
      {
        txt = "&"
        hint = "Node 14"
      }
      node15: =
      {
        txt = "&"
        hint = "Node 15"
      }
      node16: =
      {
        txt = "&"
        hint = "Node 16"
      }
      node17: =
      {
        txt = "&"
        hint = "Node 17"
      }
      node18: =
      {
        txt = "&"
        hint = "Node 18"
      }
      node19: =
      {
        txt = "&"
        hint = "Node 19"
      }
      node20: =
      {
        txt = "&"
        hint = "Node 20"
      }
      mustreachfront: =
      {
        txt = "&"
        hint = "Must Reach Front"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#PlayerStartedBlocking: =
      {
        txt = "&"
        hint = "Tell the queue manager that the player has started blocking a "
         "spot in the queue."
      }
      input#PlayerStoppedBlocking: =
      {
        txt = "&"
        hint = "Tell the queue manager that the player has stopped blocking a "
         "spot in the queue."
      }
      input#MoveQueueUp: =
      {
        txt = "&"
        hint = "Force the queue to move up, sending the front-most NPC out of "
         "the queue."
      }
      output#OnQueueMoved: =
      {
        txt = "&"
        hint = "Fired when the queue moves. Outputs the number of NPCs left in"
         " the queue."
      }
      output#OnNPCStartedLeavingQueue: =
      {
        txt = "&"
        hint = "Fired when the NPC at the head of the queue starts to leave. T"
         "he activator is the NPC, and the string is the name of the NPC."
      }
      output#OnNPCLeftQueue: =
      {
        txt = "&"
        hint = "Fired when the NPC at the head of the queue leaves. The activa"
         "tor is the NPC, and the string is the name of the NPC."
      }
    }
    ai_changetarget:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Target entity"
      }
      m_iszNewTarget: =
      {
        txt = "&"
        hint = "New Target"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Changes the entities target"
      }
    }
    ai_changehintgroup:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      SearchType: =
      {
        txt = "&"
        hint = "Search Type"
        typ = "C"
        items = "Entity Name"$0D"Classname"$0D"Old Hint Group"
        values = "0"$0D"1"$0D"2"
      }
      SearchName: =
      {
        txt = "&"
        hint = "Name to search for"
      }
      NewHintGroup: =
      {
        txt = "&"
        hint = "New Hint Group"
      }
      Radius: =
      {
        txt = "&"
        hint = "Search Radius"
      }
      hintlimiting: =
      {
        txt = "&"
        hint = "Hint Limit Nav"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Change the Hint Group"
      }
    }
    ai_script_conditions:form =
    {
      t_Targetname = !
      Actor: =
      {
        txt = "&"
        hint = "Actor"
      }
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      MinimumState: =
      {
        txt = "&"
        hint = "Minimum state"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      MaximumState: =
      {
        txt = "&"
        hint = "Maximum state"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      ScriptStatus: =
      {
        txt = "&"
        hint = "Actor is running a script?"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      RequiredTime: =
      {
        txt = "&"
        hint = "Required Time"
      }
      MinTimeout: =
      {
        txt = "&"
        hint = "Minimum time out"
      }
      MaxTimeout: =
      {
        txt = "&"
        hint = "Maximum time out"
      }
      ActorSeePlayer: =
      {
        txt = "&"
        hint = "Actor Sees Player"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      PlayerActorProximity: =
      {
        txt = "&"
        hint = "Player distance"
      }
      PlayerActorFOV: =
      {
        txt = "&"
        hint = "Player FOV for Actor "
      }
      PlayerActorFOVTrueCone: =
      {
        txt = "&"
        hint = "Play FOV to Actor is a true view cone"
        typ = "C"
        items = "No - Tall pie slice"$0D"Yes - True view cone"
        values = "0"$0D"1"
      }
      PlayerActorLOS: =
      {
        txt = "&"
        hint = "Player has LOS to Actor"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      target: =
      {
        txt = "&"
        hint = "Target (Optional)"
      }
      ActorSeeTarget: =
      {
        txt = "&"
        hint = "Actor Sees Target"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      ActorTargetProximity: =
      {
        txt = "&"
        hint = "Target distance"
      }
      PlayerTargetProximity: =
      {
        txt = "&"
        hint = "Player distance from Target"
      }
      PlayerTargetFOV: =
      {
        txt = "&"
        hint = "Player FOV for Target"
      }
      PlayerTargetFOVTrueCone: =
      {
        txt = "&"
        hint = "Play FOV to Target is a true view cone"
        typ = "C"
        items = "No - Tall pie slice"$0D"Yes - True view cone"
        values = "0"$0D"1"
      }
      PlayerTargetLOS: =
      {
        txt = "&"
        hint = "Player has LOS to Target"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      PlayerBlockingActor: =
      {
        txt = "&"
        hint = "Player blocking Actor"
        typ = "C"
        items = "No"$0D"Yes"$0D"Don't care"
        values = "0"$0D"1"$0D"2"
      }
      output#OnConditionsSatisfied: =
      {
        txt = "&"
        hint = "Fires when AI conditions satisfied"
      }
      output#OnConditionsTimeout: =
      {
        txt = "&"
        hint = "Fires when AI conditions timed out"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this entity"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this entity"
      }
    }
    scripted_sequence:form =
    {
      t_BaseScripted = !
      t_Angles = !
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Repeatable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Leave Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Start on Spawn"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No Interruptions"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Override AI"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "No Script Movement"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Loop in Post Idle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Priority Script"
      }
    }
    aiscripted_schedule:form =
    {
      t_Targetname = !
      m_iszEntity: =
      {
        txt = "&"
        hint = "Target NPC"
      }
      m_flRadius: =
      {
        txt = "&"
        hint = "Search Radius (0=everywhere)"
      }
      graball: =
      {
        txt = "&"
        hint = "All in radius"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Repeatable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Search Cyclically"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Don't Complain"
      }
      forcestate: =
      {
        txt = "&"
        hint = "AI state to set"
        typ = "C"
        items = "<None>"$0D"Set state to IDLE"$0D"Set state to ALERT"$0D"Set s"
         "tate to COMBAT"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      schedule: =
      {
        txt = "&"
        hint = "Schedule to run"
        typ = "C"
        items = "<None>"$0D"Walk to Goal Entity"$0D"Run to Goal Entity"$0D"Set"
         " enemy to Goal Entity"$0D"Walk Goal Path"$0D"Run Goal Path"$0D"Set e"
         "nemy to Goal Entity AND Run to Goal Entity"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"
      }
      interruptability: =
      {
        txt = "&"
        hint = "Interruptability"
        typ = "C"
        items = "General"$0D"Damage or Death"$0D"Death"
        values = "0"$0D"1"$0D"2"
      }
      goalent: =
      {
        txt = "&"
        hint = "Goal entity"
      }
      input#StartSchedule: =
      {
        txt = "&"
        hint = "Starts the scripted schedule. This will first locate an NPC th"
         "at matches the given target, then tell the NPC to run the specified "
         "schedule."
      }
    }
    ai_citizen_response_system:form =
    {
      t_Targetname = !
      input#ResponseVitalNPC: =
      {
        txt = "&"
        hint = "Fire the VitalNPC Died response."
      }
    }
    func_healthcharger:form =
    {
      t_EnableDisable = !
      t_Parentname = !
      t_Origin = !
      t_Global = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      output#OutRemainingHealth: =
      {
        txt = "&"
        hint = "Remaining Health."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player +USEs the charger."
      }
    }
    func_healthcharger:form =
    {
      t_EnableDisable = !
      t_Parentname = !
      t_Origin = !
      t_Global = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      output#OutRemainingHealth: =
      {
        txt = "&"
        hint = "Remaining Health."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player +USEs the charger."
      }
    }
    func_recharge:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Citadel recharger"
      }
      input#Recharge: =
      {
        txt = "&"
        hint = "Recharge to full"
      }
      output#OutRemainingCharge: =
      {
        txt = "&"
        hint = "Remaining Charge."
      }
      output#OnHalfEmpty: =
      {
        txt = "&"
        hint = "Half-Empty"
      }
      output#OnEmpty: =
      {
        txt = "&"
        hint = "Empty"
      }
      output#OnFull: =
      {
        txt = "&"
        hint = "Recharged to full."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player +USEs the charger."
      }
    }
    func_extinguishercharger:form =
    {
      t_Parentname = !
      t_Origin = !
      t_Global = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
    }
    func_vehicleclip:form =
    {
      t_Parentname = !
      t_Targetname = !
      t_Global = !
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world"
      }
    }
    func_lookdoor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Not Solid"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      blockdamage: =
      {
        txt = "&"
        hint = "Block Damage"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the brush stops moving."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the brush to the end position (starting position + (move "
         "direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the brush to a specific position between 0.0 and 1.0, whe"
         "re 0 is the starting position and 1 is the starting position + (move"
         " direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the end position (starting positi"
         "on + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the starting position."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "LookDoor Threshold"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "LookDoor Invert"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "LookDoor From Open"
      }
      ProximityDistance: =
      {
        txt = "&"
        hint = "Proximity Distance"
      }
      ProximityOffset: =
      {
        txt = "&"
        hint = "Proximity Offset"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      input#InvertOn: =
      {
        txt = "&"
        hint = "InvertOn - when set behavior of door is inverted."
      }
      input#InvertOff: =
      {
        txt = "&"
        hint = "InvertOff - when set behavior of door is normal."
      }
    }
    t_BaseTank:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Active"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Only Direct"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Controllable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Damage Kick"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "NPC Controllable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "NPC Set Controller"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Allow friendlies to hit player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Non-solid."
      }
      control_volume: =
      {
        txt = "&"
        hint = "Control Volume"
      }
      master: =
      {
        txt = "&"
        hint = "(Team) Master"
      }
      yawrate: =
      {
        txt = "&"
        hint = "Yaw rate"
      }
      yawrange: =
      {
        txt = "&"
        hint = "Yaw range"
      }
      yawtolerance: =
      {
        txt = "&"
        hint = "Yaw tolerance"
      }
      pitchrate: =
      {
        txt = "&"
        hint = "Pitch rate"
      }
      pitchrange: =
      {
        txt = "&"
        hint = "Pitch range"
      }
      pitchtolerance: =
      {
        txt = "&"
        hint = "Pitch tolerance"
      }
      barrel: =
      {
        txt = "&"
        hint = "Barrel Length"
      }
      barrely: =
      {
        txt = "&"
        hint = "Barrel Horizontal"
      }
      barrelz: =
      {
        txt = "&"
        hint = "Barrel Vertical"
      }
      spritesmoke: =
      {
        txt = "&"
        hint = "Smoke Sprite"
      }
      spriteflash: =
      {
        txt = "&"
        hint = "Flash Sprite"
      }
      spritescale: =
      {
        txt = "&"
        hint = "Sprite scale"
      }
      rotatestartsound: =
      {
        txt = "&"
        hint = "Rotate Start Sound"
      }
      rotatesound: =
      {
        txt = "&"
        hint = "Rotate Loop Sound"
      }
      rotatestopsound: =
      {
        txt = "&"
        hint = "Rotate Stop Sound"
      }
      firerate: =
      {
        txt = "&"
        hint = "Rate of Fire"
      }
      bullet_damage: =
      {
        txt = "&"
        hint = "Damage Per Bullet"
      }
      bullet_damage_vs_player: =
      {
        txt = "&"
        hint = "Damage Per Bullet Vs Player"
      }
      persistence: =
      {
        txt = "&"
        hint = "Firing persistence"
      }
      persistence2: =
      {
        txt = "&"
        hint = "Firing persistence2"
      }
      firespread: =
      {
        txt = "&"
        hint = "Bullet accuracy"
        typ = "C"
        items = "Perfect Shot"$0D"Small cone"$0D"Medium cone"$0D"Large cone"$0D
         "Extra-large cone"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      minRange: =
      {
        txt = "&"
        hint = "Minmum target range"
      }
      maxRange: =
      {
        txt = "&"
        hint = "Maximum target range"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      gun_base_attach: =
      {
        txt = "&"
        hint = "Gun Base Attachment"
      }
      gun_barrel_attach: =
      {
        txt = "&"
        hint = "Gun Barrel Attachment"
      }
      gun_yaw_pose_param: =
      {
        txt = "&"
        hint = "Gun Yaw Pose Param"
      }
      gun_yaw_pose_center: =
      {
        txt = "&"
        hint = "Gun Yaw Pose Center"
      }
      gun_pitch_pose_param: =
      {
        txt = "&"
        hint = "Gun Pitch Pose Param"
      }
      gun_pitch_pose_center: =
      {
        txt = "&"
        hint = "Gun Pitch Pose Center"
      }
      ammo_count: =
      {
        txt = "&"
        hint = "Ammunition Count"
      }
      LeadTarget: =
      {
        txt = "&"
        hint = "Lead Target"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      npc_man_point: =
      {
        txt = "&"
        hint = "NPC Man Point"
      }
      playergraceperiod: =
      {
        txt = "&"
        hint = "Post-NPC Attack Grace Period"
      }
      ignoregraceupto: =
      {
        txt = "&"
        hint = "Ignore Grace Upto"
      }
      playerlocktimebeforefire: =
      {
        txt = "&"
        hint = "Player Lock Time"
      }
      effecthandling: =
      {
        txt = "&"
        hint = "Effect Handling"
        typ = "C"
        items = "Use Individual Settings."$0D"AR2"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Turn the tank on"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Turn the tank off (go dormant)"
      }
      input#SetFireRate: =
      {
        txt = "&"
        hint = "How fast to fire (0 = don't fire)"
      }
      input#SetDamage: =
      {
        txt = "&"
        hint = "Set the Damage Per Bullet"
      }
      input#SetTargetPosition: =
      {
        txt = "&"
        hint = "World position that I should aim at"
      }
      input#SetTargetDir: =
      {
        txt = "&"
        hint = "Direction to aim at."
      }
      input#SetTargetEntityName: =
      {
        txt = "&"
        hint = "Name of entity I should follow/attack"
      }
      input#SetTargetEntity: =
      {
        txt = "&"
        hint = "Entity I should follow/attack (output from other entity only)"
      }
      input#ClearTargetEntity: =
      {
        txt = "&"
        hint = "Clear the entity I should be attacking."
      }
      input#FindNPCToManTank: =
      {
        txt = "&"
        hint = "Find a nearby NPC to man this func_tank."
      }
      input#StartFindingNPCs: =
      {
        txt = "&"
        hint = "Start searching for NPCs to man this func_tank."
      }
      input#StopFindingNPCs: =
      {
        txt = "&"
        hint = "Stop searching for NPCs to man this func_tank."
      }
      input#ForceNPCOff: =
      {
        txt = "&"
        hint = "Force the NPC manning this func_tank (if any) to leave."
      }
      input#SetMaxRange: =
      {
        txt = "&"
        hint = "Set the max range of the func_tank."
      }
      output#OnFire: =
      {
        txt = "&"
        hint = "Fires when the tank fires its bullets"
      }
      output#OnAquireTarget: =
      {
        txt = "&"
        hint = "Fires when target is newly in range and can be shot"
      }
      output#OnLoseTarget: =
      {
        txt = "&"
        hint = "Fires when when target goes out of range"
      }
      output#OnAmmoDepleted: =
      {
        txt = "&"
        hint = "Fires when tank runs out of ammo"
      }
      output#OnGotController: =
      {
        txt = "&"
        hint = "Fires when an NPC starts to control this tank. Players do NOT "
         "fire this input."
      }
      output#OnLostController: =
      {
        txt = "&"
        hint = "Fires when the NPC controller of the tank stops controlling it"
         ". Players do NOT fire this input."
      }
      output#OnGotPlayerController: =
      {
        txt = "&"
        hint = "Fires when a Player starts to control this tank. NPCs do NOT f"
         "ire this input."
      }
      output#OnLostPlayerController: =
      {
        txt = "&"
        hint = "Fires when the Player controller of the tank stops controlling"
         " it. NPCs do NOT fire this input."
      }
      output#OnReadyToFire: =
      {
        txt = "&"
        hint = "Fires once when the tank is done waiting to fire between round"
         "s"
      }
    }
    func_tank:form =
    {
      t_BaseTank = !
      bullet: =
      {
        txt = "&"
        hint = "Bullets"
        typ = "C"
        items = "None"$0D"Pistol"$0D"SMG1"$0D"AR2"$0D"Laser"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Ignore range when making viewcone checks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Aiming Assistance (Player Only)"
      }
    }
    func_tankpulselaser:form =
    {
      t_BaseTank = !
      PulseSpeed: =
      {
        txt = "&"
        hint = "Pulse Speed"
      }
      PulseColor: =
      {
        txt = "&"
        hint = "Pulse Color"
      }
      PulseWidth: =
      {
        txt = "&"
        hint = "Pulse Width"
      }
      PulseLife: =
      {
        txt = "&"
        hint = "Pulse Life"
      }
      PulseLag: =
      {
        txt = "&"
        hint = "Pulse Lag"
      }
      PulseFireSound: =
      {
        txt = "&"
        hint = "Pulse Fire Sound"
      }
    }
    func_tanklaser:form =
    {
      t_BaseTank = !
      laserentity: =
      {
        txt = "&"
        hint = "env_laser Entity"
      }
    }
    func_tankrocket:form =
    {
      t_BaseTank = !
      rocketspeed: =
      {
        txt = "&"
        hint = "Projectile speed"
      }
    }
    func_tankairboatgun:form =
    {
      t_BaseTank = !
      airboat_gun_model: =
      {
        txt = "&"
        hint = "Name of a prop_dynamic which is the airboat gun model"
      }
    }
    func_tankapcrocket:form =
    {
      t_BaseTank = !
      rocketspeed: =
      {
        txt = "&"
        hint = "Projectile speed"
      }
      burstcount: =
      {
        txt = "&"
        hint = "Burst shot count"
      }
      input#DeathVolley: =
      {
        txt = "&"
        hint = "Fire a burst of rockets cause we're dying."
      }
    }
    func_tankmortar:form =
    {
      t_BaseTank = !
      iMagnitude: =
      {
        txt = "&"
        hint = "Explosion Magnitude"
      }
      firedelay: =
      {
        txt = "&"
        hint = "Shell travel time"
      }
      firestartsound: =
      {
        txt = "&"
        hint = "Firing start sound"
      }
      fireendsound: =
      {
        txt = "&"
        hint = "Firing end sound"
      }
      incomingsound: =
      {
        txt = "&"
        hint = "Incoming Shell Sound"
      }
      warningtime: =
      {
        txt = "&"
        hint = "Incoming warning time"
      }
      firevariance: =
      {
        txt = "&"
        hint = "Fire time variance"
      }
      input#FireAtWill: =
      {
        txt = "&"
        hint = "Allow tank to fire next shot as soon as ready."
      }
    }
    func_tankphyscannister:form =
    {
      t_BaseTank = !
      barrel_volume: =
      {
        txt = "&"
        hint = "Barrel Volume"
      }
    }
    t_Item:incl =
    {
      t_Targetname = !
      t_Angles = !
      t_Shadow = !
      output#OnPlayerTouch: =
      {
        txt = "&"
        hint = "Fires when the player touches this object"
      }
    }
    item_dynamic_resupply:form =
    {
      t_Item = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Use Master's values"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Is Master"
      }
      DesiredHealth: =
      {
        txt = "&"
        hint = "Desired Health Ratio"
      }
      DesiredArmor: =
      {
        txt = "&"
        hint = "Desired Armor Ratio"
      }
      DesiredAmmoPistol: =
      {
        txt = "&"
        hint = "Desired Pistol Ammo Ratio"
      }
      DesiredAmmoSMG1: =
      {
        txt = "&"
        hint = "Desired SMG1 Ammo Ratio"
      }
      DesiredAmmoSMG1_Grenade: =
      {
        txt = "&"
        hint = "Desired SMG1 Grenade Ammo Ratio"
      }
      DesiredAmmoAR2: =
      {
        txt = "&"
        hint = "Desired AR2 Ammo Ratio"
      }
      DesiredAmmoBuckshot: =
      {
        txt = "&"
        hint = "Desired Shotgun Ammo Ratio"
      }
      DesiredAmmoRPG_Round: =
      {
        txt = "&"
        hint = "Desired RPG Ammo Ratio"
      }
      DesiredAmmoGrenade: =
      {
        txt = "&"
        hint = "Desired Grenade Ammo Ratio"
      }
      DesiredAmmo357: =
      {
        txt = "&"
        hint = "Desired 357 Ammo Ratio"
      }
      DesiredAmmoCrossbow: =
      {
        txt = "&"
        hint = "Desired Crossbow Ammo Ratio"
      }
      input#CalculateType: =
      {
        txt = "&"
        hint = "Force the dynamic resupply to calculate which item it should s"
         "pawn."
      }
      input#BecomeMaster: =
      {
        txt = "&"
        hint = "Make this resupply the master resupply. All other resupplies s"
         "et to Use Master's Values will now use this resupply's values."
      }
    }
    item_ammo_pistol:form =
    {
      t_Item = !
    }
    item_ammo_pistol_large:form =
    {
      t_Item = !
    }
    item_ammo_smg1:form =
    {
      t_Item = !
    }
    item_ammo_smg1_large:form =
    {
      t_Item = !
    }
    item_ammo_ar2:form =
    {
      t_Item = !
    }
    item_ammo_ar2_large:form =
    {
      t_Item = !
    }
    item_ammo_357:form =
    {
      t_Item = !
    }
    item_ammo_357_large:form =
    {
      t_Item = !
    }
    item_ammo_crossbow:form =
    {
      t_Item = !
    }
    item_box_buckshot:form =
    {
      t_Item = !
    }
    item_rpg_round:form =
    {
      t_Item = !
    }
    item_ammo_smg1_grenade:form =
    {
      t_Item = !
    }
    item_battery:form =
    {
      t_Item = !
    }
    item_healthkit:form =
    {
      t_Item = !
    }
    item_healthvial:form =
    {
      t_Item = !
    }
    item_ammo_ar2_altfire:form =
    {
      t_Item = !
    }
    item_suit:form =
    {
      t_Item = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Short Logon"
      }
    }
    item_ammo_crate:form =
    {
      t_Targetname = !
      t_Angles = !
      AmmoType: =
      {
        txt = "&"
        hint = "Ammo Type"
        typ = "C"
        items = "Pistol"$0D"SMG1"$0D"AR2"$0D"RPG Rounds"$0D"Buckshot"$0D"Grena"
         "des"$0D"357"$0D"XBowBolt"$0D"AR2 Alt-Fire Round"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Remove the ammo crate"
      }
      output#OnUsed: =
      {
        txt = "&"
        hint = "Fires when +used by the player."
      }
    }
    item_item_crate:form =
    {
      t_BasePropPhysics = !
      t_Targetname = !
      t_Angles = !
      t_DamageFilter = !
      CrateType: =
      {
        txt = "&"
        hint = "Crate Contains"
        typ = "C"
        items = "Contains specified item"
        values = "0"
      }
      ItemClass: =
      {
        txt = "&"
        hint = "Item Type"
      }
      ItemCount: =
      {
        txt = "&"
        hint = "Item Count"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Remove the item crate"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Breaks the breakable."
      }
      input#SetHealth: =
      {
        txt = "&"
        hint = "Sets a new value for health. If the breakable's health reaches"
         " zero it will break."
      }
      input#AddHealth: =
      {
        txt = "&"
        hint = "Adds health to the breakable. If the breakable's health reache"
         "s zero it will break."
      }
      input#RemoveHealth: =
      {
        txt = "&"
        hint = "Removes health from the breakable. If the breakable's health r"
         "eaches zero it will break."
      }
      output#OnBreak: =
      {
        txt = "&"
        hint = "Fires when broken."
      }
      output#OnHealthChanged: =
      {
        txt = "&"
        hint = "Fires when the health of this breakable changes, passing the n"
         "ew value of health as a percentage of max health, from [0..1]."
      }
    }
    item_healthcharger:form =
    {
      t_Targetname = !
      t_Angles = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      output#OutRemainingHealth: =
      {
        txt = "&"
        hint = "Remaining Health."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player +USEs the charger."
      }
    }
    item_suitcharger:form =
    {
      t_Targetname = !
      t_Angles = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Citadel recharger"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Kleiner's recharger"
      }
      input#Recharge: =
      {
        txt = "&"
        hint = "Recharge to full"
      }
      output#OutRemainingCharge: =
      {
        txt = "&"
        hint = "Remaining Charge."
      }
      output#OnHalfEmpty: =
      {
        txt = "&"
        hint = "Half-Empty"
      }
      output#OnEmpty: =
      {
        txt = "&"
        hint = "Empty"
      }
      output#OnFull: =
      {
        txt = "&"
        hint = "Recharged to full."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player +USEs the charger."
      }
    }
    t_Weapon:incl =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start constrained"
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fires when the player +uses this weapon"
      }
      output#OnPlayerPickup: =
      {
        txt = "&"
        hint = "Fires when the player picks up this weapon"
      }
      output#OnNPCPickup: =
      {
        txt = "&"
        hint = "Fires when an NPC picks up this weapon"
      }
    }
    weapon_crowbar:form =
    {
      t_Weapon = !
    }
    weapon_stunstick:form =
    {
      t_Weapon = !
    }
    weapon_pistol:form =
    {
      t_Weapon = !
    }
    weapon_ar2:form =
    {
      t_Weapon = !
    }
    weapon_rpg:form =
    {
      t_Weapon = !
    }
    weapon_smg1:form =
    {
      t_Weapon = !
    }
    weapon_357:form =
    {
      t_Weapon = !
    }
    weapon_crossbow:form =
    {
      t_Weapon = !
    }
    weapon_shotgun:form =
    {
      t_Weapon = !
    }
    weapon_frag:form =
    {
      t_Weapon = !
    }
    weapon_physgun:form =
    {
      t_Weapon = !
    }
    weapon_physcannon:form =
    {
      t_Weapon = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Start without grab functionality."
      }
      input#EnableGrab: =
      {
        txt = "&"
        hint = "Enable the grab functionality."
      }
    }
    weapon_extinguisher:form =
    {
      t_Weapon = !
    }
    weapon_bugbait:form =
    {
      t_Weapon = !
    }
    weapon_alyxgun:form =
    {
      t_Weapon = !
    }
    weapon_annabelle:form =
    {
      t_Weapon = !
    }
    trigger_rpgfire:form =
    {
      t_Trigger = !
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fires while the trigger is activated"
      }
    }
    trigger_vphysics_motion:form =
    {
      t_Trigger = !
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Can move (through hierarchical attachment)"
      }
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
      SetGravityScale: =
      {
        txt = "&"
        hint = "Scale gravity of objects in the field."
      }
      input#SetGravityScale: =
      {
        txt = "&"
        hint = "Scale gravity of objects in the field."
      }
      SetAdditionalAirDensity: =
      {
        txt = "&"
        hint = "Additional air density for drag"
      }
      input#SetAdditionalAirDensity: =
      {
        txt = "&"
        hint = "Additional air density for drag"
      }
      SetVelocityLimit: =
      {
        txt = "&"
        hint = "Max velocity in field (0 disables)"
      }
      input#SetVelocityLimit: =
      {
        txt = "&"
        hint = "Max velocity in field."
      }
      SetVelocityLimitDelta: =
      {
        txt = "&"
        hint = "Max amount to reduce velocity per second when it exceeds the v"
         "elocity limit (0 disables)"
      }
      input#SetVelocityLimitDelta: =
      {
        txt = "&"
        hint = "Max amount to reduce velocity per second"
      }
      input#SetVelocityLimitTime: =
      {
        txt = "&"
        hint = "Accepts two arguments: the first is the new velocity limit, th"
         "e second is the time it takes to ramp to that value"
      }
      SetVelocityScale: =
      {
        txt = "&"
        hint = "Velocity scale/drag"
      }
      input#SetVelocityScale: =
      {
        txt = "&"
        hint = "Velocity scale/drag"
      }
      SetAngVelocityLimit: =
      {
        txt = "&"
        hint = "Max angular velocity in field (degrees/s, 0 disables)"
      }
      input#SetAngVelocityLimit: =
      {
        txt = "&"
        hint = "Max angular velocity in field."
      }
      SetAngVelocityScale: =
      {
        txt = "&"
        hint = "Angular Velocity scale/drag"
      }
      input#SetAngVelocityScale: =
      {
        txt = "&"
        hint = "Angular Velocity scale/drag"
      }
      SetLinearForce: =
      {
        txt = "&"
        hint = "Linear force (0 disables)"
      }
      input#SetLinearForce: =
      {
        txt = "&"
        hint = "Linear force (0 disables)"
      }
      SetLinearForceAngles: =
      {
        txt = "&"
        hint = "Direction of linear force (Pitch Yaw Roll (Y Z X))"
      }
      ParticleTrailMaterial: =
      {
        txt = "&"
        hint = "Particle Trail Material"
      }
      ParticleTrailLifetime: =
      {
        txt = "&"
        hint = "Particle Trail Lifetime"
      }
      ParticleTrailStartSize: =
      {
        txt = "&"
        hint = "Particle Trail Starting Sprite Size"
      }
      ParticleTrailEndSize: =
      {
        txt = "&"
        hint = "Particle Trail Ending Sprite Size"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the trigger."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the trigger."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle enable/disable."
      }
    }
    point_bugbait:form =
    {
      t_Targetname = !
      Enabled: =
      {
        txt = "&"
        hint = "Start Enabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Do not call antlions to position"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Don't activate on thrown bugbait splashes"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Don't activate on squeezed bugbait"
      }
      radius: =
      {
        txt = "&"
        hint = "Sensor Radius"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the sensor."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the sensor."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the sensor."
      }
      output#OnBaited: =
      {
        txt = "&"
        hint = "Fires when bugbait lands within a radius of the sensor"
      }
    }
    weapon_brickbat:form =
    {
      t_Weapon = !
      BrickbatType: =
      {
        txt = "&"
        hint = "BrickbatType"
        typ = "C"
        items = "Rock"$0D"Beer Bottle"$0D"Headcrab"$0D"Cremator Head"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
    }
    weapon_slam:form =
    {
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world."
      }
      input#KillHierarchy: =
      {
        txt = "&"
        hint = "Removes this entity and all its children from the world."
      }
      input#AddOutput: =
      {
        txt = "&"
        hint = "Adds an entity I/O connection to this entity. Format: <output "
         "name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fir"
         "e (-1 == infinite)>. Very dangerous, use with care."
      }
      input#FireUser1: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser1 output to be fired."
      }
      input#FireUser2: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser2 output to be fired."
      }
      input#FireUser3: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser3 output to be fired."
      }
      input#FireUser4: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser4 output to be fired."
      }
      output#OnUser1: =
      {
        txt = "&"
        hint = "Fired in response to FireUser1 input."
      }
      output#OnUser2: =
      {
        txt = "&"
        hint = "Fired in response to FireUser2 input."
      }
      output#OnUser3: =
      {
        txt = "&"
        hint = "Fired in response to FireUser3 input."
      }
      output#OnUser4: =
      {
        txt = "&"
        hint = "Fired in response to FireUser4 input."
      }
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start constrained"
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fires when the player +uses this weapon"
      }
      output#OnPlayerPickup: =
      {
        txt = "&"
        hint = "Fires when the player picks up this weapon"
      }
      output#OnNPCPickup: =
      {
        txt = "&"
        hint = "Fires when an NPC picks up this weapon"
      }
    }
    path_corner:form =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Wait for retrigger"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Teleport to THIS path_corner"
      }
      target: =
      {
        txt = "&"
        hint = "Next stop target"
      }
      wait: =
      {
        txt = "&"
        hint = "Wait here (secs)"
      }
      speed: =
      {
        txt = "&"
        hint = "New Train Speed"
      }
      yaw_speed: =
      {
        txt = "&"
        hint = "New Train rot. Speed"
      }
      input#SetNextPathCorner: =
      {
        txt = "&"
        hint = "Sets next pathcorner"
      }
      output#OnPass: =
      {
        txt = "&"
        hint = "Fires when a path follower passes this point"
      }
    }
    path_corner_crash:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Next stop target"
      }
    }
    player_loadsaved:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      duration: =
      {
        txt = "&"
        hint = "Fade Duration (seconds)"
      }
      holdtime: =
      {
        txt = "&"
        hint = "Hold Fade (seconds)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Fade Alpha"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Fade Color (R G B)"
      }
      loadtime: =
      {
        txt = "&"
        hint = "Reload delay"
      }
      input#Reload: =
      {
        txt = "&"
        hint = "Ends this game and reloads"
      }
    }
    player_weaponstrip:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      input#Strip: =
      {
        txt = "&"
        hint = "Strip player's weapons"
      }
      input#StripWeaponsAndSuit: =
      {
        txt = "&"
        hint = "Strip player's weapons and his suit"
      }
    }
    player_speedmod:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      input#ModifySpeed: =
      {
        txt = "&"
        hint = "Modifies player speed by X ammount."
      }
    }
    logic_choreographed_scene:form =
    {
      t_Targetname = !
      SceneFile: =
      {
        txt = "&"
        hint = "Scene file"
      }
      target1: =
      {
        txt = "&"
        hint = "Target 1"
      }
      target2: =
      {
        txt = "&"
        hint = "Target 2"
      }
      target3: =
      {
        txt = "&"
        hint = "Target 3"
      }
      target4: =
      {
        txt = "&"
        hint = "Target 4"
      }
      target5: =
      {
        txt = "&"
        hint = "Target 5"
      }
      target6: =
      {
        txt = "&"
        hint = "Target 6"
      }
      target7: =
      {
        txt = "&"
        hint = "Target 7"
      }
      target8: =
      {
        txt = "&"
        hint = "Target 8"
      }
      busyactor: =
      {
        txt = "&"
        hint = "If an Actor is talking..."
        typ = "C"
        items = "Default"$0D"Wait for actor to finish"
        values = "0"$0D"1"
      }
      input#Start: =
      {
        txt = "&"
        hint = "Starts playback of the scene file"
      }
      input#Pause: =
      {
        txt = "&"
        hint = "Pauses playback of the scene file"
      }
      input#Resume: =
      {
        txt = "&"
        hint = "Resumes playback of the scene if it has been paused"
      }
      input#Cancel: =
      {
        txt = "&"
        hint = "Cancels playback of the scene"
      }
      input#InterjectResponse: =
      {
        txt = "&"
        hint = "Finds an actor who can respond to the specified concept string"
         " while the scene continues playing"
      }
      input#StopWaitingForActor: =
      {
        txt = "&"
        hint = "Stop waiting on an actor to stop talking."
      }
      output#OnStart: =
      {
        txt = "&"
        hint = "The scene has started"
      }
      output#OnCompletion: =
      {
        txt = "&"
        hint = "The scene has completed"
      }
      output#OnCanceled: =
      {
        txt = "&"
        hint = "The scene has been canceled"
      }
      output#OnTrigger1: =
      {
        txt = "&"
        hint = "Scene trigger 1"
      }
      output#OnTrigger2: =
      {
        txt = "&"
        hint = "Scene trigger 2"
      }
      output#OnTrigger3: =
      {
        txt = "&"
        hint = "Scene trigger 3"
      }
      output#OnTrigger4: =
      {
        txt = "&"
        hint = "Scene trigger 4"
      }
      output#OnTrigger5: =
      {
        txt = "&"
        hint = "Scene trigger 5"
      }
      output#OnTrigger6: =
      {
        txt = "&"
        hint = "Scene trigger 6"
      }
      output#OnTrigger7: =
      {
        txt = "&"
        hint = "Scene trigger 7"
      }
      output#OnTrigger8: =
      {
        txt = "&"
        hint = "Scene trigger 8"
      }
    }
    ai_sound:form =
    {
      t_Targetname = !
      t_Parentname = !
      input#InsertSound: =
      {
        txt = "&"
        hint = "Insert a sound in the AI sound list"
      }
      soundtype: =
      {
        txt = "&"
        hint = "Sound Type"
        typ = "C"
        items = "Combat"$0D"World"$0D"Danger"$0D"Bullet Impact"$0D"Carcass"$0D
         "Meat"$0D"Garbage"$0D"Thumper"$0D"Readiness - Low"$0D"Readiness - Med"
         "ium"$0D"Readiness - High"
        values = "1"$0D"2"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"256"$0D"16384"
         $0D"32768"$0D"65536"
      }
      locationproxy: =
      {
        txt = "&"
        hint = "Location Proxy"
      }
    }
    env_rotorwash:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Ignore solid"
      }
      input#DoEffect: =
      {
        txt = "&"
        hint = "Make a rotor puff"
      }
    }
    combine_mine:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      bounce: =
      {
        txt = "&"
        hint = "Bounce"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      LockSilently: =
      {
        txt = "&"
        hint = "Lock Silently"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      StartDisarmed: =
      {
        txt = "&"
        hint = "Start Disarmed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      output#OnPulledUp: =
      {
        txt = "&"
        hint = "Fires when this mine is uprooted with physgun"
      }
      input#Disarm: =
      {
        txt = "&"
        hint = "Disarm this mine (open hooks and shut off) if not placed by pl"
         "ayer."
      }
    }
    env_ar2explosion:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      input#Explode: =
      {
        txt = "&"
        hint = "Make the explosion effect."
      }
      material: =
      {
        txt = "&"
        hint = "Particle Material"
        typ = "ET"
        Cap = "texture..."
      }
    }
    env_starfield:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off"
      }
      input#SetDensity: =
      {
        txt = "&"
        hint = "Set the density of the starfield. It's a multiplier, so 1 is t"
         "he default."
      }
    }
    env_flare:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No DLight"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No Smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Infinite"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Start off"
      }
      input#Start: =
      {
        txt = "&"
        hint = "Start"
      }
      input#Die: =
      {
        txt = "&"
        hint = "Die"
      }
      input#Launch: =
      {
        txt = "&"
        hint = "Launch the flare forward with the specified speed."
      }
    }
    env_extinguisherjet:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      length: =
      {
        txt = "&"
        hint = "Length"
      }
      size: =
      {
        txt = "&"
        hint = "Size of jet"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius of extinguishment at impact point"
      }
      strength: =
      {
        txt = "&"
        hint = "Strength of the extinguisher"
      }
      enabled: =
      {
        txt = "&"
        hint = "Start On"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enables the extinguisher"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disables the extinguisher"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the extinguisher"
      }
    }
    env_muzzleflash:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      parentattachment: =
      {
        txt = "&"
        hint = "Parent Attachment"
      }
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      input#Fire: =
      {
        txt = "&"
        hint = "Fires the effect once."
      }
    }
    env_terrainmorph:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      startradius: =
      {
        txt = "&"
        hint = "Start Radius"
      }
      goalradius: =
      {
        txt = "&"
        hint = "Goal Radius"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration"
      }
      fraction: =
      {
        txt = "&"
        hint = "Displacement Fraction"
      }
      input#BeginMorph: =
      {
        txt = "&"
        hint = "Begin Morph"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Instant"
      }
    }
    point_camera:form =
    {
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Off"
      }
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      FOV: =
      {
        txt = "&"
        hint = "FOV"
      }
      UseScreenAspectRatio: =
      {
        txt = "&"
        hint = "Screen Aspect Ratio"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogEnable: =
      {
        txt = "&"
        hint = "Fog Enable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogColor: =
      {
        txt = "&"
        hint = "Fog Color"
      }
      fogStart: =
      {
        txt = "&"
        hint = "Fog Start"
      }
      fogEnd: =
      {
        txt = "&"
        hint = "Fog End"
      }
      input#ChangeFOV: =
      {
        txt = "&"
        hint = "Changes camera's FOV over time"
      }
      input#SetOnAndTurnOthersOff: =
      {
        txt = "&"
        hint = "Turn the camera on, and turn all other cameras off."
      }
      input#SetOn: =
      {
        txt = "&"
        hint = "Turn the camera on."
      }
      input#SetOff: =
      {
        txt = "&"
        hint = "Turn the camera off."
      }
    }
    func_monitor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Inputfilter = !
      t_EnableDisable = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Ignore player +USE"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      Solidity: =
      {
        txt = "&"
        hint = "Solidity"
        typ = "C"
        items = "Toggle"$0D"Never Solid"$0D"Always Solid"
        values = "0"$0D"1"$0D"2"
      }
      excludednpc: =
      {
        txt = "&"
        hint = "NPC class excluded from collisions"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      target: =
      {
        txt = "&"
        hint = "Camera name"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle - If on, turn off, if off, turn on."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable."
      }
      input#SetCamera: =
      {
        txt = "&"
        hint = "Sets the camera to use for this monitor. Takes the name of a p"
         "oint_camera entity in the map."
      }
    }
    t_BaseVehicle:incl =
    {
      t_Targetname = !
      t_Origin = !
      t_Global = !
      t_prop_static_base = !
      vehiclescript: =
      {
        txt = "&"
        hint = "Vehicle Script File"
      }
      actionScale: =
      {
        txt = "&"
        hint = "Scale of action input / framerate"
      }
      input#Action: =
      {
        txt = "&"
        hint = "Set the speed of the action animation"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on: Start engine & enable throttle"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off: Stop engine, disable throttle, engage brakes."
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Prevent the player from entering or exiting the vehicle."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Re-allow the player to enter or exit the vehicle."
      }
    }
    t_BaseDriveableVehicle:incl =
    {
      t_BaseVehicle = !
      VehicleLocked: =
      {
        txt = "&"
        hint = "Start locked"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      output#PlayerOn: =
      {
        txt = "&"
        hint = "Player entered the vehicle"
      }
      output#PlayerOff: =
      {
        txt = "&"
        hint = "Player exited the vehicle"
      }
      output#PressedAttack: =
      {
        txt = "&"
        hint = "Player Pressed attack key"
      }
      output#PressedAttack2: =
      {
        txt = "&"
        hint = "Player Pressed attack2 key"
      }
      output#AttackAxis: =
      {
        txt = "&"
        hint = "State of attack button [0,1]"
      }
      output#Attack2Axis: =
      {
        txt = "&"
        hint = "State of attack2 button [0,1]"
      }
      input#HandBrakeOn: =
      {
        txt = "&"
        hint = "Turns the handbrake on"
      }
      input#HandBrakeOff: =
      {
        txt = "&"
        hint = "Releases the handbrake"
      }
    }
    prop_vehicle:form =
    {
      t_BaseVehicle = !
      input#Steer: =
      {
        txt = "&"
        hint = "Steer the vehicle +/-1"
      }
      input#Throttle: =
      {
        txt = "&"
        hint = "Throttle +/-1"
      }
    }
    prop_vehicle_driveable:form =
    {
      t_BaseDriveableVehicle = !
    }
    point_apc_controller:form =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Active"
      }
      yawrate: =
      {
        txt = "&"
        hint = "Yaw rate"
      }
      yawtolerance: =
      {
        txt = "&"
        hint = "Yaw tolerance"
      }
      pitchrate: =
      {
        txt = "&"
        hint = "Pitch rate"
      }
      pitchtolerance: =
      {
        txt = "&"
        hint = "Pitch tolerance"
      }
      rotatestartsound: =
      {
        txt = "&"
        hint = "Rotate Start Sound"
      }
      rotatesound: =
      {
        txt = "&"
        hint = "Rotate Loop Sound"
      }
      rotatestopsound: =
      {
        txt = "&"
        hint = "Rotate Stop Sound"
      }
      minRange: =
      {
        txt = "&"
        hint = "Minmum target range"
      }
      maxRange: =
      {
        txt = "&"
        hint = "Maximum target range"
      }
      targetentityname: =
      {
        txt = "&"
        hint = "Name of entity I should follow/attack"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Turn the APC rockets on"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Turn the APC rockets off (go dormant)"
      }
      output#OnFireAtTarget: =
      {
        txt = "&"
        hint = "Fires when a valid target is found and the APC should shoot ro"
         "ckets"
      }
    }
    prop_vehicle_apc:form =
    {
      t_BaseDriveableVehicle = !
      missilehint: =
      {
        txt = "&"
        hint = "Missile Hint Target"
      }
      input#FireMissileAt: =
      {
        txt = "&"
        hint = "A target to fire a missile at"
      }
      input#Destroy: =
      {
        txt = "&"
        hint = "Causes the APC to blow up."
      }
      output#OnFiredMissile: =
      {
        txt = "&"
        hint = "Fired when the APC shoots a missile."
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fired when the APC is killed."
      }
    }
    info_apc_missile_hint:form =
    {
      t_Targetname = !
      t_Origin = !
      t_Angles = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Target Entity"
      }
    }
    prop_vehicle_jeep:form =
    {
      t_BaseDriveableVehicle = !
      input#StartRemoveTauCannon: =
      {
        txt = "&"
        hint = "Start the tau removal sequence."
      }
      input#FinishRemoveTauCannon: =
      {
        txt = "&"
        hint = "Finish the tau removal sequence."
      }
    }
    vehicle_viewcontroller:form =
    {
      t_BaseDriveableVehicle = !
      input#ForcePlayerIn: =
      {
        txt = "&"
        hint = "Force the player into the vehicle. The animation to use can be"
         " specified in the parameter. Without a parameter, the player just te"
         "leports."
      }
      input#ForcePlayerOut: =
      {
        txt = "&"
        hint = "Force the player out of the vehicle."
      }
    }
    prop_vehicle_airboat:form =
    {
      t_BaseDriveableVehicle = !
      t_modelselect = !
      vehiclescript: =
      {
        txt = "&"
        hint = "Vehicle Script File"
      }
      EnableGun: =
      {
        txt = "&"
        hint = "Has Gun"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableGun: =
      {
        txt = "&"
        hint = "Enables or disables the airboat gun and associated crosshair."
      }
      input#InputStartRotorWashForces: =
      {
        txt = "&"
        hint = "The airboat will start to be blown around by the helicopter ro"
         "tor wash."
      }
      input#InputStopRotorWashForces: =
      {
        txt = "&"
        hint = "The airboat will no longer be blown around by the helicopter r"
         "otor wash."
      }
    }
    prop_vehicle_cannon:form =
    {
      t_BaseDriveableVehicle = !
    }
    prop_vehicle_crane:form =
    {
      t_BaseDriveableVehicle = !
      magnetname: =
      {
        txt = "&"
        hint = "Magnet entity"
      }
      input#ForcePlayerIn: =
      {
        txt = "&"
        hint = "Force the player to get into the crane. Only works in singlepl"
         "ayer."
      }
    }
    prop_vehicle_prisoner_pod:form =
    {
      t_BaseDriveableVehicle = !
      t_Parentname = !
      t_modelselect = !
      vehiclescript: =
      {
        txt = "&"
        hint = "Vehicle Script File"
      }
      input#Open: =
      {
        txt = "&"
        hint = "Plays the pod's open animation and unlocks the pod for entry o"
         "r exit."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Plays the pod's close animation and locks the pod for entry or"
         " exit."
      }
      input#EnterVehicle: =
      {
        txt = "&"
        hint = "Forces the activator (or player) into the pod."
      }
      input#EnterVehicleImmediate: =
      {
        txt = "&"
        hint = "Forces the activator (or player) into the pod without enter/ex"
         "it animations."
      }
      input#ExitVehicle: =
      {
        txt = "&"
        hint = "Boots the prisoner out of the pod."
      }
      output#OnOpen: =
      {
        txt = "&"
        hint = "Fired when the pod is open enough to enter."
      }
      output#OnClose: =
      {
        txt = "&"
        hint = "Fired when the pod too closed to enter."
      }
    }
    phys_constraintsystem:form =
    {
      t_Targetname = !
    }
    env_speaker:form =
    {
      t_BaseSpeaker = !
    }
    script_tauremoval:form =
    {
      t_Angles = !
      t_Targetname = !
      t_Parentname = !
      vortigaunt: =
      {
        txt = "&"
        hint = "Vortigaunt to use"
      }
      input#StartScript: =
      {
        txt = "&"
        hint = "Start the script."
      }
      input#RemoveTau: =
      {
        txt = "&"
        hint = "Start removing the Tau cannon now."
      }
    }
    script_intro:form =
    {
      t_Targetname = !
      input#Activate: =
      {
        txt = "&"
        hint = "Take control of the player's view and start blending the two s"
         "cenes."
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Stop controlling the view."
      }
      input#SetCameraViewEntity: =
      {
        txt = "&"
        hint = "Set the viewpoint to blend with the player's viewpoint."
      }
      input#SetBlendMode: =
      {
        txt = "&"
        hint = "Set the blending mode to use."
      }
      input#SetFOV: =
      {
        txt = "&"
        hint = "Set the fov for the second camera."
      }
      input#SetNextFOV: =
      {
        txt = "&"
        hint = "Set the FOV to blend to over time. Follow this with a SetFOVBl"
         "endTime input to start the fov blend."
      }
      input#SetFOVBlendTime: =
      {
        txt = "&"
        hint = "Set the amount of time it should take to blend to the next fov"
         " target, and start blending."
      }
      input#SetNextBlendMode: =
      {
        txt = "&"
        hint = "Set the blending mode to blend to over time. Follow this with "
         "a SetNextBlendTime input to start the mode blend."
      }
      input#SetNextBlendTime: =
      {
        txt = "&"
        hint = "Set the amount of time it should take to blend to the next mod"
         "e, and start blending."
      }
      input#FadeTo: =
      {
        txt = "&"
        hint = "Fade to a specific alpha amount of an amount of time. Paramete"
         "rs: <alpha> <duration>"
      }
      input#SetFadeColor: =
      {
        txt = "&"
        hint = "Set the fade color. Parameters: <Red> <Green> <Blue>"
      }
    }
    env_citadel_energy_core:form =
    {
      t_Angles = !
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No small particles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Start on"
      }
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      input#StartCharge: =
      {
        txt = "&"
        hint = "Start charging the core over specified number of seconds."
      }
      input#StartDischarge: =
      {
        txt = "&"
        hint = "Start discharging the core over specified number of seconds."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stops the effect at any point."
      }
    }
    env_alyxemp:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Angles = !
      t_Targetname = !
      t_Parentname = !
      Type: =
      {
        txt = "&"
        hint = "EMP Type"
        typ = "C"
        items = "Small"$0D"Large"
        values = "0"$0D"1"
      }
      EndTargetName: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      input#StartCharge: =
      {
        txt = "&"
        hint = "Start charging the effect over specified number of seconds."
      }
      input#StartDischarge: =
      {
        txt = "&"
        hint = "Start discharging the effect over specified number of seconds."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stops the effect at any point."
      }
      input#SetTargetEnt: =
      {
        txt = "&"
        hint = "Sets the target entity for the effect."
      }
    }
    test_sidelist:form =
    {
      sides: =
      {
        txt = "&"
        hint = "Sides"
      }
    }
    info_teleporter_countdown:form =
    {
      t_Targetname = !
      input#StartCountdown: =
      {
        txt = "&"
        hint = "Starts the teleporter countdown. Requires an argument which is"
         " the number of seconds for the countdown."
      }
      input#StopCountdown: =
      {
        txt = "&"
        hint = "Stops the countdown permanently"
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Pauses the countdown due to a temporary malfunction. A warning"
         " sign will appear on the linked vgui screens."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Restarts the countdown since the malfunction is finished."
      }
    }
    info_player_deathmatch:form =
    {
      t_PlayerClass = !
      t_Angles = !
    }
    prop_physics_respawnable:form =
    {
      t_BasePropPhysics = !
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
      RespawnTime: =
      {
        txt = "&"
        hint = "Respawn Time"
      }
    }
  }
}
